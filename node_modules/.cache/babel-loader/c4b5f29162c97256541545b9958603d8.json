{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { h3ToGeoBoundary, h3GetResolution, h3ToGeo, geoToH3, h3IsPentagon, h3Distance, edgeLength, UNITS } from 'h3-js';\nimport { lerp } from 'math.gl';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nvar UPDATE_THRESHOLD_KM = 10;\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n\n  var _iterator = _createForOfIteratorHelper(vertices),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pt = _step.value;\n      var deltaLng = pt[0] - refLng;\n\n      if (deltaLng > 180) {\n        pt[0] -= 360;\n      } else if (deltaLng < -180) {\n        pt[0] += 360;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport function scalePolygon(hexId, vertices, factor) {\n  var _h3ToGeo = h3ToGeo(hexId),\n      _h3ToGeo2 = _slicedToArray(_h3ToGeo, 2),\n      lat = _h3ToGeo2[0],\n      lng = _h3ToGeo2[1];\n\n  var actualCount = vertices.length;\n  normalizeLongitudes(vertices, lng);\n  var vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n\n  for (var i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  var hexagonId = getHexagon(object, objectInfo);\n\n  var _h3ToGeo3 = h3ToGeo(hexagonId),\n      _h3ToGeo4 = _slicedToArray(_h3ToGeo3, 2),\n      lat = _h3ToGeo4[0],\n      lng = _h3ToGeo4[1];\n\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId) {\n  var coverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var flatten = arguments.length > 2 ? arguments[2] : undefined;\n  var vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    var positions = new Float64Array(vertices.length * 2);\n    var i = 0;\n\n    var _iterator2 = _createForOfIteratorHelper(vertices),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var pt = _step2.value;\n        positions[i++] = pt[0];\n        positions[i++] = pt[1];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  var trigger;\n\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (_typeof(getHexagon) === 'object') {\n    trigger = Object.assign({}, getHexagon, {\n      coverage: coverage\n    });\n  } else {\n    trigger = {\n      getHexagon: getHexagon,\n      coverage: coverage\n    };\n  }\n\n  return trigger;\n}\n\nvar defaultProps = Object.assign({}, PolygonLayer.defaultProps, {\n  highPrecision: false,\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.hexagon;\n    }\n  },\n  extruded: true\n});\ndelete defaultProps.getLineDashArray;\n\nvar H3HexagonLayer = function (_CompositeLayer) {\n  _inherits(H3HexagonLayer, _CompositeLayer);\n\n  var _super = _createSuper(H3HexagonLayer);\n\n  function H3HexagonLayer() {\n    _classCallCheck(this, H3HexagonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(H3HexagonLayer, [{\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (changeFlags.dataChanged || changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon) {\n        var resolution = -1;\n        var hasPentagon = false;\n        var hasMultipleRes = false;\n\n        var _createIterable = createIterable(props.data),\n            iterable = _createIterable.iterable,\n            objectInfo = _createIterable.objectInfo;\n\n        var _iterator3 = _createForOfIteratorHelper(iterable),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var object = _step3.value;\n            objectInfo.index++;\n            var hexId = props.getHexagon(object, objectInfo);\n            var hexResolution = h3GetResolution(hexId);\n            if (resolution < 0) resolution = hexResolution;else if (resolution !== hexResolution) {\n              hasMultipleRes = true;\n              break;\n            }\n\n            if (h3IsPentagon(hexId)) {\n              hasPentagon = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        this.setState({\n          resolution: resolution,\n          edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n          hasMultipleRes: hasMultipleRes,\n          hasPentagon: hasPentagon\n        });\n      }\n\n      this._updateVertices(this.context.viewport);\n    }\n  }, {\n    key: \"_shouldUseHighPrecision\",\n    value: function _shouldUseHighPrecision() {\n      var _this$state = this.state,\n          resolution = _this$state.resolution,\n          hasPentagon = _this$state.hasPentagon,\n          hasMultipleRes = _this$state.hasMultipleRes;\n      var viewport = this.context.viewport;\n      return this.props.highPrecision || viewport.resolution || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n    }\n  }, {\n    key: \"_updateVertices\",\n    value: function _updateVertices(viewport) {\n      if (this._shouldUseHighPrecision()) {\n        return;\n      }\n\n      var _this$state2 = this.state,\n          resolution = _this$state2.resolution,\n          edgeLengthKM = _this$state2.edgeLengthKM,\n          centerHex = _this$state2.centerHex;\n\n      if (resolution < 0) {\n        return;\n      }\n\n      var hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n\n      if (centerHex === hex) {\n        return;\n      }\n\n      if (centerHex) {\n        var distance = h3Distance(centerHex, hex);\n\n        if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      }\n\n      var unitsPerMeter = viewport.distanceScales.unitsPerMeter;\n      var vertices = h3ToPolygon(hex);\n\n      var _h3ToGeo5 = h3ToGeo(hex),\n          _h3ToGeo6 = _slicedToArray(_h3ToGeo5, 2),\n          centerLat = _h3ToGeo6[0],\n          centerLng = _h3ToGeo6[1];\n\n      var _viewport$projectFlat = viewport.projectFlat([centerLng, centerLat]),\n          _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),\n          centerX = _viewport$projectFlat2[0],\n          centerY = _viewport$projectFlat2[1];\n\n      vertices = vertices.map(function (p) {\n        var worldPosition = viewport.projectFlat(p);\n        return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];\n      });\n      this.setState({\n        centerHex: hex,\n        vertices: vertices\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n    }\n  }, {\n    key: \"_getForwardProps\",\n    value: function _getForwardProps() {\n      var _this$props = this.props,\n          elevationScale = _this$props.elevationScale,\n          material = _this$props.material,\n          coverage = _this$props.coverage,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe,\n          stroked = _this$props.stroked,\n          filled = _this$props.filled,\n          lineWidthUnits = _this$props.lineWidthUnits,\n          lineWidthScale = _this$props.lineWidthScale,\n          lineWidthMinPixels = _this$props.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props.lineWidthMaxPixels,\n          getFillColor = _this$props.getFillColor,\n          getElevation = _this$props.getElevation,\n          getLineColor = _this$props.getLineColor,\n          getLineWidth = _this$props.getLineWidth,\n          transitions = _this$props.transitions,\n          updateTriggers = _this$props.updateTriggers;\n      return {\n        elevationScale: elevationScale,\n        extruded: extruded,\n        coverage: coverage,\n        wireframe: wireframe,\n        stroked: stroked,\n        filled: filled,\n        lineWidthUnits: lineWidthUnits,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        material: material,\n        getElevation: getElevation,\n        getFillColor: getFillColor,\n        getLineColor: getLineColor,\n        getLineWidth: getLineWidth,\n        transitions: transitions,\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getElevation: updateTriggers.getElevation,\n          getLineColor: updateTriggers.getLineColor,\n          getLineWidth: updateTriggers.getLineWidth\n        }\n      };\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getHexagon = _this$props2.getHexagon,\n          updateTriggers = _this$props2.updateTriggers,\n          coverage = _this$props2.coverage;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n\n      var forwardProps = this._getForwardProps();\n\n      forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: function getPolygon(object, objectInfo) {\n          var hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      });\n    }\n  }, {\n    key: \"_renderColumnLayer\",\n    value: function _renderColumnLayer() {\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          getHexagon = _this$props3.getHexagon,\n          updateTriggers = _this$props3.updateTriggers;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n\n      var forwardProps = this._getForwardProps();\n\n      forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        diskResolution: 6,\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      });\n    }\n  }]);\n\n  return H3HexagonLayer;\n}(CompositeLayer);\n\nexport { H3HexagonLayer as default };\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';","map":{"version":3,"sources":["../../../src/h3-layers/h3-hexagon-layer.js"],"names":["UPDATE_THRESHOLD_KM","refLng","vertices","pt","deltaLng","lat","lng","h3ToGeo","actualCount","normalizeLongitudes","vertexCount","i","lerp","hexagonId","getHexagon","coverage","flatten","h3ToGeoBoundary","scalePolygon","positions","trigger","defaultProps","PolygonLayer","highPrecision","type","min","max","value","centerHexagon","x","extruded","H3HexagonLayer","CompositeLayer","changeFlags","props","oldProps","resolution","hasPentagon","hasMultipleRes","iterable","objectInfo","createIterable","object","hexId","hexResolution","h3GetResolution","h3IsPentagon","edgeLengthKM","edgeLength","UNITS","viewport","centerHex","hex","geoToH3","distance","h3Distance","unitsPerMeter","h3ToPolygon","centerLat","centerLng","centerX","centerY","worldPosition","elevationScale","material","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","getFillColor","getElevation","getLineColor","getLineWidth","transitions","updateTriggers","data","SubLayerClass","forwardProps","mergeTriggers","id","_normalize","_windingOrder","positionFormat","getPolygon","diskResolution","radius","getPosition","getHexagonCentroid"],"mappings":"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","sourcesContent":["import {\n  h3ToGeoBoundary,\n  h3GetResolution,\n  h3ToGeo,\n  geoToH3,\n  h3IsPentagon,\n  h3Distance,\n  edgeLength,\n  UNITS\n} from 'h3-js';\nimport {lerp} from 'math.gl';\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer} from '@deck.gl/layers';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId, vertices, factor) {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `h3ToGeoBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId, coverage = 1, flatten) {\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    const positions = new Float64Array(vertices.length * 2);\n    let i = 0;\n    for (const pt of vertices) {\n      positions[i++] = pt[0];\n      positions[i++] = pt[1];\n    }\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = Object.assign({}, getHexagon, {coverage});\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps = Object.assign({}, PolygonLayer.defaultProps, {\n  highPrecision: false,\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: x => x.hexagon},\n  extruded: true\n});\n\n// not supported\ndelete defaultProps.getLineDashArray;\n\n/**\n * A subclass of HexagonLayer that uses H3 hexagonIds in data objects\n * rather than centroid lat/longs. The shape of each hexagon is determined\n * based on a single \"center\" hexagon, which can be selected by passing in\n * a center lat/lon pair. If not provided, the map center will be used.\n *\n * Also sets the `hexagonId` field in the onHover/onClick callback's info\n * objects. Since this is calculated using math, hexagonId will be present\n * even when no corresponding hexagon is in the data set. You can check\n * index !== -1 to see if picking matches an actual object.\n */\nexport default class H3HexagonLayer extends CompositeLayer {\n  shouldUpdateState({changeFlags}) {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon)\n    ) {\n      let resolution = -1;\n      let hasPentagon = false;\n      let hasMultipleRes = false;\n      const {iterable, objectInfo} = createIterable(props.data);\n      for (const object of iterable) {\n        objectInfo.index++;\n        const hexId = props.getHexagon(object, objectInfo);\n        // Take the resolution of the first hex\n        const hexResolution = h3GetResolution(hexId);\n        if (resolution < 0) resolution = hexResolution;\n        else if (resolution !== hexResolution) {\n          hasMultipleRes = true;\n          break;\n        }\n        if (h3IsPentagon(hexId)) {\n          hasPentagon = true;\n          break;\n        }\n      }\n      this.setState({\n        resolution,\n        edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n        hasMultipleRes,\n        hasPentagon\n      });\n    }\n\n    this._updateVertices(this.context.viewport);\n  }\n\n  _shouldUseHighPrecision() {\n    const {resolution, hasPentagon, hasMultipleRes} = this.state;\n    const {viewport} = this.context;\n    return (\n      this.props.highPrecision ||\n      viewport.resolution ||\n      hasMultipleRes ||\n      hasPentagon ||\n      (resolution >= 0 && resolution <= 5)\n    );\n  }\n\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n      // h3Distance returns a negative number if the distance could not be computed\n      // due to the two indexes very far apart or on opposite sides of a pentagon.\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [\n        (worldPosition[0] - centerX) / unitsPerMeter[0],\n        (worldPosition[1] - centerY) / unitsPerMeter[1]\n      ];\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n\n  _renderPolygonLayer() {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      }\n    );\n  }\n\n  _renderColumnLayer() {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';\n"]},"metadata":{},"sourceType":"module"}