{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { log } from '@deck.gl/core';\nvar MISSING_CHAR_WIDTH = 32;\nvar SINGLE_LINE = [];\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\nexport function buildMapping(_ref) {\n  var characterSet = _ref.characterSet,\n      getFontWidth = _ref.getFontWidth,\n      fontHeight = _ref.fontHeight,\n      buffer = _ref.buffer,\n      maxCanvasWidth = _ref.maxCanvasWidth,\n      _ref$mapping = _ref.mapping,\n      mapping = _ref$mapping === void 0 ? {} : _ref$mapping,\n      _ref$xOffset = _ref.xOffset,\n      xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset,\n      _ref$yOffset = _ref.yOffset,\n      yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset;\n  var row = 0;\n  var x = xOffset;\n  var i = 0;\n\n  var _iterator = _createForOfIteratorHelper(characterSet),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n\n      if (!mapping[_char]) {\n        var width = getFontWidth(_char, i++);\n\n        if (x + width + buffer * 2 > maxCanvasWidth) {\n          x = 0;\n          row++;\n        }\n\n        mapping[_char] = {\n          x: x + buffer,\n          y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n          width: width,\n          height: fontHeight\n        };\n        x += width + buffer * 2;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var rowHeight = fontHeight + buffer * 2;\n  return {\n    mapping: mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  var width = 0;\n\n  for (var i = startIndex; i < endIndex; i++) {\n    var character = text[i];\n    var frameWidth = null;\n    var frame = mapping && mapping[character];\n\n    if (frame) {\n      frameWidth = frame.width;\n    }\n\n    width += frameWidth;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  var rowStartCharIndex = startIndex;\n  var rowOffsetLeft = 0;\n\n  for (var i = startIndex; i < endIndex; i++) {\n    var textWidth = getTextWidth(text, i, i + 1, iconMapping);\n\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  var rowStartCharIndex = startIndex;\n  var groupStartCharIndex = startIndex;\n  var groupEndCharIndex = startIndex;\n  var rowOffsetLeft = 0;\n\n  for (var i = startIndex; i < endIndex; i++) {\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      var groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping) {\n  var startIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var endIndex = arguments.length > 5 ? arguments[5] : undefined;\n\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n\n  var result = [];\n\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  var x = 0;\n  var rowHeight = 0;\n\n  for (var i = startIndex; i < endIndex; i++) {\n    var character = line[i];\n    var frame = iconMapping[character];\n\n    if (frame) {\n      if (!rowHeight) {\n        rowHeight = frame.height;\n      }\n\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(\"Missing character: \".concat(character, \" (\").concat(character.codePointAt(0), \")\"))();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  paragraph = Array.from(paragraph);\n  var numCharacters = paragraph.length;\n  var x = new Array(numCharacters);\n  var y = new Array(numCharacters);\n  var rowWidth = new Array(numCharacters);\n  var autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n  var size = [0, 0];\n  var rowSize = [];\n  var rowOffsetTop = 0;\n  var lineStartIndex = 0;\n  var lineEndIndex = 0;\n\n  for (var i = 0; i <= numCharacters; i++) {\n    var _char2 = paragraph[i];\n\n    if (_char2 === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      var rows = autoWrappingEnabled ? autoWrapping(paragraph, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;\n\n      for (var rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        var rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        var rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(paragraph, rowStart, rowEnd, iconMapping, x, rowSize);\n\n        for (var j = rowStart; j < rowEnd; j++) {\n          y[j] = rowOffsetTop + rowSize[1] / 2;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowSize[0]);\n      }\n\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (_char2 === '\\n') {\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  size[1] = rowOffsetTop;\n  return {\n    x: x,\n    y: y,\n    rowWidth: rowWidth,\n    size: size\n  };\n}\nexport function getTextFromBuffer(_ref2) {\n  var value = _ref2.value,\n      length = _ref2.length,\n      stride = _ref2.stride,\n      offset = _ref2.offset,\n      startIndices = _ref2.startIndices;\n  var bytesPerElement = value.BYTES_PER_ELEMENT;\n  var elementStride = stride ? stride / bytesPerElement : 1;\n  var elementOffset = offset ? offset / bytesPerElement : 0;\n  var characterCount = startIndices[length] || Math.floor((value.length - elementOffset - bytesPerElement) / elementStride) + 1;\n  var texts = new Array(length);\n  var codes = value;\n\n  if (elementStride > 1 || elementOffset > 0) {\n    codes = new value.constructor(characterCount);\n\n    for (var i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (var index = 0; index < length; index++) {\n    var startIndex = startIndices[index];\n    var endIndex = startIndices[index + 1] || characterCount;\n    texts[index] = String.fromCodePoint.apply(null, codes.subarray(startIndex, endIndex));\n  }\n\n  return {\n    texts: texts,\n    characterCount: characterCount\n  };\n}","map":{"version":3,"sources":["../../../src/text-layer/utils.js"],"names":["MISSING_CHAR_WIDTH","SINGLE_LINE","Math","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","i","char","width","y","height","rowHeight","canvasHeight","nextPowOfTwo","character","text","frameWidth","frame","rowStartCharIndex","rowOffsetLeft","textWidth","getTextWidth","target","groupStartCharIndex","groupEndCharIndex","groupWidth","breakAll","startIndex","endIndex","result","wordBreak","breakWord","line","iconMapping","leftOffsets","log","rowSize","paragraph","Array","numCharacters","rowWidth","autoWrappingEnabled","isFinite","maxWidth","size","rowOffsetTop","lineStartIndex","lineEndIndex","rows","autoWrapping","rowIndex","rowStart","rowEnd","transformRow","j","value","length","stride","offset","startIndices","bytesPerElement","elementStride","elementOffset","characterCount","texts","codes","index","String"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-params, complexity, max-depth */\n// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\nconst SINGLE_LINE = [];\n\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n * @param characterSet {Array|Set} new characters\n * @param getFontWidth {Function} function to get width of each character\n * @param fontHeight {Number} height of font\n * @param buffer {Number} buffer surround each character\n * @param maxCanvasWidth {Number} max width of font atlas\n * @param mapping {Object} old mapping table\n * @param xOffset {Number} x position of last character in old mapping table\n * @param yOffset {Number} y position of last character in old mapping table\n * @returns {{\n *   mapping: Object,\n *   xOffset: Number, x position of last character\n *   yOffset: Number, y position of last character in old mapping table\n *   canvasHeight: Number, height of the font atlas canvas, power of 2\n *  }}\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n\n  let i = 0;\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char, i++);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, startIndex, endIndex, mapping) {\n  let width = 0;\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = text[i];\n    let frameWidth = null;\n    const frame = mapping && mapping[character];\n    if (frame) {\n      frameWidth = frame.width;\n    }\n\n    width += frameWidth;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text, i, i + 1, iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        target.push(i);\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  return rowOffsetLeft;\n}\n\nfunction breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {\n  let rowStartCharIndex = startIndex;\n  let groupStartCharIndex = startIndex;\n  let groupEndCharIndex = startIndex;\n  let rowOffsetLeft = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      groupEndCharIndex = i + 1;\n    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {\n      groupEndCharIndex = i + 1;\n    }\n\n    if (groupEndCharIndex > groupStartCharIndex) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        if (rowStartCharIndex < groupStartCharIndex) {\n          target.push(groupStartCharIndex);\n          rowStartCharIndex = groupStartCharIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          groupWidth = breakAll(\n            text,\n            groupStartCharIndex,\n            groupEndCharIndex,\n            maxWidth,\n            iconMapping,\n            target\n          );\n          // move reference to last row\n          rowStartCharIndex = target[target.length - 1];\n        }\n      }\n      groupStartCharIndex = groupEndCharIndex;\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  return rowOffsetLeft;\n}\n\n// Returns a list of indices where line breaks should be inserted\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {\n  if (endIndex === undefined) {\n    endIndex = text.length;\n  }\n  const result = [];\n  if (wordBreak === 'break-all') {\n    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  } else {\n    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);\n  }\n  return result;\n}\n\nfunction transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {\n  let x = 0;\n  let rowHeight = 0;\n\n  for (let i = startIndex; i < endIndex; i++) {\n    const character = line[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.height;\n      }\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  rowSize[0] = x;\n  rowSize[1] = rowHeight;\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n * @param paragraph: {String}\n * @param iconMapping {Object} character mapping table for retrieving a character from font atlas\n * @param lineHeight {Number} css line-height\n * @param wordBreak {String} css word-break option\n * @param maxWidth {number} css max-width\n * @param transformedData {Array} output transformed data array, each datum contains\n *   - text: character\n *   - index: character index in the paragraph\n *   - x: x offset in the row,\n *   - y: y offset in the paragraph\n *   - size: [width, height] size of the paragraph\n *   - rowSize: [rowWidth, rowHeight] size of the row\n *   - len: length of the paragraph\n */\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  // Break into an array of characters\n  // When dealing with double-length unicode characters, `str.length` or `str[i]` do not work\n  paragraph = Array.from(paragraph);\n  const numCharacters = paragraph.length;\n  const x = new Array(numCharacters);\n  const y = new Array(numCharacters);\n  const rowWidth = new Array(numCharacters);\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size = [0, 0];\n  const rowSize = [];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n  let lineEndIndex = 0;\n\n  for (let i = 0; i <= numCharacters; i++) {\n    const char = paragraph[i];\n    if (char === '\\n' || i === numCharacters) {\n      lineEndIndex = i;\n    }\n\n    if (lineEndIndex > lineStartIndex) {\n      const rows = autoWrappingEnabled\n        ? autoWrapping(paragraph, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex)\n        : SINGLE_LINE;\n\n      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {\n        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];\n        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;\n        transformRow(paragraph, rowStart, rowEnd, iconMapping, x, rowSize);\n        for (let j = rowStart; j < rowEnd; j++) {\n          y[j] = rowOffsetTop + rowSize[1] / 2;\n          rowWidth[j] = rowSize[0];\n        }\n\n        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;\n        size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowSize[0]);\n      }\n      lineStartIndex = lineEndIndex;\n    }\n\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      x[lineStartIndex] = 0;\n      y[lineStartIndex] = 0;\n      rowWidth[lineStartIndex] = 0;\n      lineStartIndex++;\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n  return {x, y, rowWidth, size};\n}\n\nexport function getTextFromBuffer({value, length, stride, offset, startIndices}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount =\n    startIndices[length] ||\n    Math.floor((value.length - elementOffset - bytesPerElement) / elementStride) + 1;\n\n  const texts = new Array(length);\n\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    codes = new value.constructor(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    texts[index] = String.fromCodePoint.apply(null, codes.subarray(startIndex, endIndex));\n  }\n\n  return {texts, characterCount};\n}\n"]},"metadata":{},"sourceType":"module"}