{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar _marked = _regeneratorRuntime.mark(makeMeshPrimitiveIterator);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { getZeroOffsetArrayBuffer } from '@loaders.gl/loader-utils';\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport { KHR_DRACO_MESH_COMPRESSION } from '../gltf-constants';\nimport { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';\nexport function decode(_x, _x2, _x3) {\n  return _decode.apply(this, arguments);\n}\n\nfunction _decode() {\n  _decode = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(gltfData, options, context) {\n    var scenegraph, promises, _iterator4, _step4, primitive;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (options.gltf.decompressMeshes) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 2:\n            scenegraph = new GLTFScenegraph(gltfData);\n            promises = [];\n            _iterator4 = _createForOfIteratorHelper(makeMeshPrimitiveIterator(scenegraph));\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                primitive = _step4.value;\n\n                if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n                  promises.push(decompressPrimitive(primitive, scenegraph, options, context));\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            _context2.next = 8;\n            return Promise.all(promises);\n\n          case 8:\n            scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\n\nexport function encode(gltfData) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var scenegraph = new GLTFScenegraph(gltfData);\n\n  var _iterator = _createForOfIteratorHelper(scenegraph.json.meshes || []),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var mesh = _step.value;\n      compressMesh(mesh, options);\n      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction decompressPrimitive(_x4, _x5, _x6, _x7) {\n  return _decompressPrimitive.apply(this, arguments);\n}\n\nfunction _decompressPrimitive() {\n  _decompressPrimitive = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(primitive, scenegraph, options, context) {\n    var compressedPrimitive, buffer, bufferCopy, parse, dracoOptions, decodedData, originalAccessors, _i, _arr, _arr$_i, name, index;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            compressedPrimitive = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n            buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);\n            bufferCopy = getZeroOffsetArrayBuffer(buffer.buffer, buffer.byteOffset);\n            parse = context.parse;\n            dracoOptions = _objectSpread({}, options);\n            delete dracoOptions['3d-tiles'];\n            _context3.next = 8;\n            return parse(bufferCopy, DracoLoader, dracoOptions, context);\n\n          case 8:\n            decodedData = _context3.sent;\n            originalAccessors = {};\n\n            for (_i = 0, _arr = [].concat(_toConsumableArray(Object.entries(primitive.attributes)), [['indices', primitive.indices]]); _i < _arr.length; _i++) {\n              _arr$_i = _slicedToArray(_arr[_i], 2), name = _arr$_i[0], index = _arr$_i[1];\n              originalAccessors[name] = scenegraph.getAccessor(index);\n            }\n\n            primitive.attributes = getGLTFAccessors(decodedData.attributes, originalAccessors);\n\n            if (decodedData.indices) {\n              primitive.indices = getGLTFAccessor(decodedData.indices, originalAccessors.indices || {});\n            }\n\n            checkPrimitive(primitive);\n\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _decompressPrimitive.apply(this, arguments);\n}\n\nfunction compressMesh(attributes, indices) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  var options = arguments.length > 3 ? arguments[3] : undefined;\n  var context = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (!options.DracoWriter || !options.DracoLoader) {\n    throw new Error('DracoWriter/DracoLoader not available');\n  }\n\n  var compressedData = options.DracoWriter.encodeSync({\n    attributes: attributes\n  });\n  var parseSync = context.parseSync;\n  var decodedData = parseSync({\n    attributes: attributes\n  });\n\n  var fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  var bufferViewIndex = options.addBufferView(compressedData);\n  var glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode: mode,\n      extensions: _defineProperty({}, KHR_DRACO_MESH_COMPRESSION, {\n        bufferView: bufferViewIndex,\n        attributes: fauxAccessors\n      })\n    }]\n  };\n  return glTFMesh;\n}\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('Empty glTF primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction makeMeshPrimitiveIterator(scenegraph) {\n  var _iterator2, _step2, mesh, _iterator3, _step3, primitive;\n\n  return _regeneratorRuntime.wrap(function makeMeshPrimitiveIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator2 = _createForOfIteratorHelper(scenegraph.json.meshes || []);\n          _context.prev = 1;\n\n          _iterator2.s();\n\n        case 3:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 24;\n            break;\n          }\n\n          mesh = _step2.value;\n          _iterator3 = _createForOfIteratorHelper(mesh.primitives);\n          _context.prev = 6;\n\n          _iterator3.s();\n\n        case 8:\n          if ((_step3 = _iterator3.n()).done) {\n            _context.next = 14;\n            break;\n          }\n\n          primitive = _step3.value;\n          _context.next = 12;\n          return primitive;\n\n        case 12:\n          _context.next = 8;\n          break;\n\n        case 14:\n          _context.next = 19;\n          break;\n\n        case 16:\n          _context.prev = 16;\n          _context.t0 = _context[\"catch\"](6);\n\n          _iterator3.e(_context.t0);\n\n        case 19:\n          _context.prev = 19;\n\n          _iterator3.f();\n\n          return _context.finish(19);\n\n        case 22:\n          _context.next = 3;\n          break;\n\n        case 24:\n          _context.next = 29;\n          break;\n\n        case 26:\n          _context.prev = 26;\n          _context.t1 = _context[\"catch\"](1);\n\n          _iterator2.e(_context.t1);\n\n        case 29:\n          _context.prev = 29;\n\n          _iterator2.f();\n\n          return _context.finish(29);\n\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 26, 29, 32], [6, 16, 19, 22]]);\n}","map":{"version":3,"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.js"],"names":["options","scenegraph","promises","primitive","makeMeshPrimitiveIterator","decompressPrimitive","Promise","mesh","compressMesh","compressedPrimitive","buffer","bufferCopy","getZeroOffsetArrayBuffer","parse","context","dracoOptions","decodedData","originalAccessors","name","index","Object","getGLTFAccessors","getGLTFAccessor","checkPrimitive","mode","compressedData","attributes","parseSync","fauxAccessors","bufferViewIndex","glTFMesh","primitives","extensions","bufferView"],"mappings":"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","sourcesContent":["// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n\n/* eslint-disable camelcase */\n\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\n// Note: We have a \"soft dependency\" on Draco to avoid bundling it when not needed\nexport async function decode(gltfData, options, context) {\n  if (!options.gltf.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new GLTFScenegraph(gltfData);\n  const promises = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(primitive, scenegraph, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options = {}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(primitive, scenegraph, options, context) {\n  const compressedPrimitive = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n\n  const buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = getZeroOffsetArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  // this will generate an exception if DracoLoader is not installed\n  const {parse} = context;\n  const dracoOptions = {...options};\n  // The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parse(bufferCopy, DracoLoader, dracoOptions, context);\n\n  const originalAccessors = {};\n  for (const [name, index] of [\n    ...Object.entries(primitive.attributes),\n    ['indices', primitive.indices]\n  ]) {\n    originalAccessors[name] = scenegraph.getAccessor(index);\n  }\n\n  primitive.attributes = getGLTFAccessors(decodedData.attributes, originalAccessors);\n\n  if (decodedData.indices) {\n    primitive.indices = getGLTFAccessor(decodedData.indices, originalAccessors.indices || {});\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode = 4, options, context) {\n  if (!options.DracoWriter || !options.DracoLoader) {\n    throw new Error('DracoWriter/DracoLoader not available');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  const {parseSync} = context;\n  const decodedData = parseSync({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('Empty glTF primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}