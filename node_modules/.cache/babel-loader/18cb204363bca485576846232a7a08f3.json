{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport { geojsonToBinary } from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport { transformCoordinates, transformToLocalCoordinates } from './transform-to-local-range';\nexport default function parseMVT(arrayBuffer, options) {\n  options = options || {};\n  options.mvt = options.mvt || {};\n  options.gis = options.gis || {};\n  var features = [];\n\n  if (arrayBuffer.byteLength > 0) {\n    var tile = new VectorTile(new Protobuf(arrayBuffer));\n    var loaderOptions = options.mvt;\n    var selectedLayers = Array.isArray(loaderOptions.layers) ? loaderOptions.layers : Object.keys(tile.layers);\n    selectedLayers.forEach(function (layerName) {\n      var vectorTileLayer = tile.layers[layerName];\n\n      var featureOptions = _objectSpread(_objectSpread({}, loaderOptions), {}, {\n        layerName: layerName\n      });\n\n      if (!vectorTileLayer) {\n        return;\n      }\n\n      for (var i = 0; i < vectorTileLayer.length; i++) {\n        var vectorTileFeature = vectorTileLayer.feature(i);\n        var decodedFeature = getDecodedFeature(vectorTileFeature, featureOptions);\n        features.push(decodedFeature);\n      }\n    });\n  }\n\n  if (options.gis.format === 'binary') {\n    var data = geojsonToBinary(features);\n    data.byteLength = arrayBuffer.byteLength;\n    return data;\n  }\n\n  return features;\n}\n\nfunction getDecodedFeature(feature) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var wgs84Coordinates = options.coordinates === 'wgs84';\n  var hasTileIndex = options.tileIndex && Number.isFinite(options.tileIndex.x) && Number.isFinite(options.tileIndex.y) && Number.isFinite(options.tileIndex.z);\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n  }\n\n  var decodedFeature = wgs84Coordinates && hasTileIndex ? feature.toGeoJSON(options.tileIndex.x, options.tileIndex.y, options.tileIndex.z) : transformCoordinates(feature, transformToLocalCoordinates);\n\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}","map":{"version":3,"sources":["../../../src/lib/parse-mvt.js"],"names":["options","features","arrayBuffer","tile","loaderOptions","selectedLayers","Array","Object","vectorTileLayer","featureOptions","layerName","i","vectorTileFeature","decodedFeature","getDecodedFeature","data","geojsonToBinary","wgs84Coordinates","hasTileIndex","Number","feature","transformCoordinates"],"mappings":"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","sourcesContent":["// import {VectorTile} from '@mapbox/vector-tile';\nimport VectorTile from './mapbox-vector-tile/vector-tile';\n\nimport {geojsonToBinary} from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport {transformCoordinates, transformToLocalCoordinates} from './transform-to-local-range';\n\n/*\n  * Parse MVT arrayBuffer and return GeoJSON.\n  *\n  * @param {arrayBuffer} _ A MVT arrayBuffer\n  * @return {?Object} A GeoJSON geometry object\n  */\nexport default function parseMVT(arrayBuffer, options) {\n  options = options || {};\n  options.mvt = options.mvt || {};\n  options.gis = options.gis || {};\n\n  const features = [];\n\n  if (arrayBuffer.byteLength > 0) {\n    const tile = new VectorTile(new Protobuf(arrayBuffer));\n    const loaderOptions = options.mvt;\n\n    const selectedLayers = Array.isArray(loaderOptions.layers)\n      ? loaderOptions.layers\n      : Object.keys(tile.layers);\n\n    selectedLayers.forEach(layerName => {\n      const vectorTileLayer = tile.layers[layerName];\n      const featureOptions = {...loaderOptions, layerName};\n\n      if (!vectorTileLayer) {\n        return;\n      }\n\n      for (let i = 0; i < vectorTileLayer.length; i++) {\n        const vectorTileFeature = vectorTileLayer.feature(i);\n\n        const decodedFeature = getDecodedFeature(vectorTileFeature, featureOptions);\n        features.push(decodedFeature);\n      }\n    });\n  }\n\n  if (options.gis.format === 'binary') {\n    const data = geojsonToBinary(features);\n    // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n    // TODO decide where to store extra fields like byteLength (header etc) and document\n    // @ts-ignore\n    data.byteLength = arrayBuffer.byteLength;\n    return data;\n  }\n\n  return features;\n}\n\nfunction getDecodedFeature(feature, options = {}) {\n  const wgs84Coordinates = options.coordinates === 'wgs84';\n  const hasTileIndex =\n    options.tileIndex &&\n    Number.isFinite(options.tileIndex.x) &&\n    Number.isFinite(options.tileIndex.y) &&\n    Number.isFinite(options.tileIndex.z);\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n  }\n\n  const decodedFeature =\n    wgs84Coordinates && hasTileIndex\n      ? feature.toGeoJSON(options.tileIndex.x, options.tileIndex.y, options.tileIndex.z)\n      : transformCoordinates(feature, transformToLocalCoordinates);\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n"]},"metadata":{},"sourceType":"module"}