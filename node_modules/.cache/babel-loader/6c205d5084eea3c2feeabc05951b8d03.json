{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport { WebMercatorViewport, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { TerrainLoader } from '@loaders.gl/terrain';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { urlType, getURLFromTemplate } from '../tile-layer/utils';\nvar DUMMY_DATA = [1];\n\nvar defaultProps = _objectSpread(_objectSpread({}, TileLayer.defaultProps), {}, {\n  elevationData: urlType,\n  texture: urlType,\n  meshMaxError: {\n    type: 'number',\n    value: 4.0\n  },\n  bounds: {\n    type: 'array',\n    value: null,\n    optional: true,\n    compare: true\n  },\n  color: {\n    type: 'color',\n    value: [255, 255, 255]\n  },\n  elevationDecoder: {\n    type: 'object',\n    value: {\n      rScaler: 1,\n      gScaler: 0,\n      bScaler: 0,\n      offset: 0\n    }\n  },\n  workerUrl: {\n    type: 'string',\n    value: null\n  },\n  wireframe: false,\n  material: true,\n  loaders: [TerrainLoader]\n});\n\nfunction urlTemplateToUpdateTrigger(template) {\n  if (Array.isArray(template)) {\n    return template.join(';');\n  }\n\n  return template;\n}\n\nvar TerrainLayer = function (_CompositeLayer) {\n  _inherits(TerrainLayer, _CompositeLayer);\n\n  var _super = _createSuper(TerrainLayer);\n\n  function TerrainLayer() {\n    _classCallCheck(this, TerrainLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TerrainLayer, [{\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps;\n      var elevationDataChanged = props.elevationData !== oldProps.elevationData;\n\n      if (elevationDataChanged) {\n        var elevationData = props.elevationData;\n        var isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes('{x}') && elevationData.includes('{y}'));\n        this.setState({\n          isTiled: isTiled\n        });\n      }\n\n      var shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;\n\n      if (!this.state.isTiled && shouldReload) {\n        var terrain = this.loadTerrain(props);\n        this.setState({\n          terrain: terrain\n        });\n      }\n    }\n  }, {\n    key: \"loadTerrain\",\n    value: function loadTerrain(_ref2) {\n      var elevationData = _ref2.elevationData,\n          bounds = _ref2.bounds,\n          elevationDecoder = _ref2.elevationDecoder,\n          meshMaxError = _ref2.meshMaxError,\n          workerUrl = _ref2.workerUrl;\n\n      if (!elevationData) {\n        return null;\n      }\n\n      var options = {\n        terrain: {\n          bounds: bounds,\n          meshMaxError: meshMaxError,\n          elevationDecoder: elevationDecoder\n        }\n      };\n\n      if (workerUrl !== null) {\n        options.terrain.workerUrl = workerUrl;\n      }\n\n      return load(elevationData, this.props.loaders, options);\n    }\n  }, {\n    key: \"getTiledTerrainData\",\n    value: function getTiledTerrainData(tile) {\n      var _this$props = this.props,\n          elevationData = _this$props.elevationData,\n          texture = _this$props.texture,\n          elevationDecoder = _this$props.elevationDecoder,\n          meshMaxError = _this$props.meshMaxError,\n          workerUrl = _this$props.workerUrl;\n      var dataUrl = getURLFromTemplate(elevationData, tile);\n      var textureUrl = getURLFromTemplate(texture, tile);\n      var bbox = tile.bbox,\n          z = tile.z;\n      var viewport = new WebMercatorViewport({\n        longitude: (bbox.west + bbox.east) / 2,\n        latitude: (bbox.north + bbox.south) / 2,\n        zoom: z\n      });\n      var bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);\n      var topRight = viewport.projectFlat([bbox.east, bbox.north]);\n      var bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];\n      var terrain = this.loadTerrain({\n        elevationData: dataUrl,\n        bounds: bounds,\n        elevationDecoder: elevationDecoder,\n        meshMaxError: meshMaxError,\n        workerUrl: workerUrl\n      });\n      var surface = textureUrl ? load(textureUrl)[\"catch\"](function (_) {\n        return null;\n      }) : Promise.resolve(null);\n      return Promise.all([terrain, surface]);\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n      var data = props.data,\n          color = props.color;\n\n      if (!data) {\n        return null;\n      }\n\n      var _data = _slicedToArray(data, 2),\n          mesh = _data[0],\n          texture = _data[1];\n\n      return new SubLayerClass(props, {\n        data: DUMMY_DATA,\n        mesh: mesh,\n        texture: texture,\n        coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n        getPosition: function getPosition(d) {\n          return [0, 0, 0];\n        },\n        getColor: color\n      });\n    }\n  }, {\n    key: \"onViewportLoad\",\n    value: function onViewportLoad(tiles) {\n      if (!tiles) {\n        return;\n      }\n\n      var zRange = this.state.zRange;\n      var ranges = tiles.map(function (tile) {\n        return tile.content;\n      }).filter(Boolean).map(function (arr) {\n        var bounds = arr[0].header.boundingBox;\n        return bounds.map(function (bound) {\n          return bound[2];\n        });\n      });\n\n      if (ranges.length === 0) {\n        return;\n      }\n\n      var minZ = Math.min.apply(Math, _toConsumableArray(ranges.map(function (x) {\n        return x[0];\n      })));\n      var maxZ = Math.max.apply(Math, _toConsumableArray(ranges.map(function (x) {\n        return x[1];\n      })));\n\n      if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {\n        this.setState({\n          zRange: [minZ, maxZ]\n        });\n      }\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$props2 = this.props,\n          color = _this$props2.color,\n          material = _this$props2.material,\n          elevationData = _this$props2.elevationData,\n          texture = _this$props2.texture,\n          wireframe = _this$props2.wireframe,\n          meshMaxError = _this$props2.meshMaxError,\n          elevationDecoder = _this$props2.elevationDecoder,\n          tileSize = _this$props2.tileSize,\n          maxZoom = _this$props2.maxZoom,\n          minZoom = _this$props2.minZoom,\n          extent = _this$props2.extent,\n          maxRequests = _this$props2.maxRequests;\n\n      if (this.state.isTiled) {\n        return new TileLayer(this.getSubLayerProps({\n          id: 'tiles'\n        }), {\n          wireframe: wireframe,\n          color: color,\n          material: material,\n          getTileData: this.getTiledTerrainData.bind(this),\n          renderSubLayers: this.renderSubLayers.bind(this),\n          updateTriggers: {\n            getTileData: {\n              elevationData: urlTemplateToUpdateTrigger(elevationData),\n              texture: urlTemplateToUpdateTrigger(texture),\n              meshMaxError: meshMaxError,\n              elevationDecoder: elevationDecoder\n            }\n          },\n          onViewportLoad: this.onViewportLoad.bind(this),\n          zRange: this.state.zRange || null,\n          tileSize: tileSize,\n          maxZoom: maxZoom,\n          minZoom: minZoom,\n          extent: extent,\n          maxRequests: maxRequests\n        });\n      }\n\n      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        data: DUMMY_DATA,\n        mesh: this.state.terrain,\n        texture: texture,\n        _instanced: false,\n        getPosition: function getPosition(d) {\n          return [0, 0, 0];\n        },\n        getColor: color,\n        material: material,\n        wireframe: wireframe\n      });\n    }\n  }]);\n\n  return TerrainLayer;\n}(CompositeLayer);\n\nexport { TerrainLayer as default };\nTerrainLayer.layerName = 'TerrainLayer';\nTerrainLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/terrain-layer/terrain-layer.js"],"names":["DUMMY_DATA","defaultProps","TileLayer","elevationData","texture","meshMaxError","type","value","bounds","optional","compare","color","elevationDecoder","rScaler","gScaler","bScaler","offset","workerUrl","wireframe","material","loaders","Array","template","TerrainLayer","CompositeLayer","props","oldProps","elevationDataChanged","isTiled","shouldReload","terrain","options","load","tile","dataUrl","getURLFromTemplate","textureUrl","bbox","z","viewport","longitude","latitude","zoom","bottomLeft","topRight","surface","Promise","SubLayerClass","data","mesh","coordinateSystem","COORDINATE_SYSTEM","getPosition","getColor","tiles","zRange","ranges","arr","bound","minZ","Math","x","maxZ","tileSize","maxZoom","minZoom","extent","maxRequests","id","getTileData","renderSubLayers","updateTriggers","urlTemplateToUpdateTrigger","onViewportLoad","_instanced"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer} from '@deck.gl/core';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {WebMercatorViewport, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {load} from '@loaders.gl/core';\nimport {TerrainLoader} from '@loaders.gl/terrain';\nimport TileLayer from '../tile-layer/tile-layer';\nimport {urlType, getURLFromTemplate} from '../tile-layer/utils';\n\nconst DUMMY_DATA = [1];\n\nconst defaultProps = {\n  ...TileLayer.defaultProps,\n  // Image url that encodes height data\n  elevationData: urlType,\n  // Image url to use as texture\n  texture: urlType,\n  // Martini error tolerance in meters, smaller number -> more detailed mesh\n  meshMaxError: {type: 'number', value: 4.0},\n  // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates\n  bounds: {type: 'array', value: null, optional: true, compare: true},\n  // Color to use if texture is unavailable\n  color: {type: 'color', value: [255, 255, 255]},\n  // Object to decode height data, from (r, g, b) to height in meters\n  elevationDecoder: {\n    type: 'object',\n    value: {\n      rScaler: 1,\n      gScaler: 0,\n      bScaler: 0,\n      offset: 0\n    }\n  },\n  // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.\n  workerUrl: {type: 'string', value: null},\n  // Same as SimpleMeshLayer wireframe\n  wireframe: false,\n  material: true,\n\n  loaders: [TerrainLoader]\n};\n\n// Turns array of templates into a single string to work around shallow change\nfunction urlTemplateToUpdateTrigger(template) {\n  if (Array.isArray(template)) {\n    return template.join(';');\n  }\n  return template;\n}\n\n/**\n * state: {\n *   isTiled: True renders TileLayer of many SimpleMeshLayers, false renders one SimpleMeshLayer\n *   terrain: Mesh object. Only defined when isTiled is false.\n * }\n */\nexport default class TerrainLayer extends CompositeLayer {\n  updateState({props, oldProps}) {\n    const elevationDataChanged = props.elevationData !== oldProps.elevationData;\n    if (elevationDataChanged) {\n      const {elevationData} = props;\n      const isTiled =\n        elevationData &&\n        (Array.isArray(elevationData) ||\n          (elevationData.includes('{x}') && elevationData.includes('{y}')));\n      this.setState({isTiled});\n    }\n\n    // Reloading for single terrain mesh\n    const shouldReload =\n      elevationDataChanged ||\n      props.meshMaxError !== oldProps.meshMaxError ||\n      props.elevationDecoder !== oldProps.elevationDecoder ||\n      props.bounds !== oldProps.bounds;\n\n    if (!this.state.isTiled && shouldReload) {\n      const terrain = this.loadTerrain(props);\n      this.setState({terrain});\n    }\n  }\n\n  loadTerrain({elevationData, bounds, elevationDecoder, meshMaxError, workerUrl}) {\n    if (!elevationData) {\n      return null;\n    }\n    const options = {\n      terrain: {\n        bounds,\n        meshMaxError,\n        elevationDecoder\n      }\n    };\n    if (workerUrl !== null) {\n      options.terrain.workerUrl = workerUrl;\n    }\n    return load(elevationData, this.props.loaders, options);\n  }\n\n  getTiledTerrainData(tile) {\n    const {elevationData, texture, elevationDecoder, meshMaxError, workerUrl} = this.props;\n    const dataUrl = getURLFromTemplate(elevationData, tile);\n    const textureUrl = getURLFromTemplate(texture, tile);\n\n    const {bbox, z} = tile;\n    const viewport = new WebMercatorViewport({\n      longitude: (bbox.west + bbox.east) / 2,\n      latitude: (bbox.north + bbox.south) / 2,\n      zoom: z\n    });\n    const bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);\n    const topRight = viewport.projectFlat([bbox.east, bbox.north]);\n    const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];\n\n    const terrain = this.loadTerrain({\n      elevationData: dataUrl,\n      bounds,\n      elevationDecoder,\n      meshMaxError,\n      workerUrl\n    });\n    const surface = textureUrl\n      ? // If surface image fails to load, the tile should still be displayed\n        load(textureUrl).catch(_ => null)\n      : Promise.resolve(null);\n\n    return Promise.all([terrain, surface]);\n  }\n\n  renderSubLayers(props) {\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n    const {data, color} = props;\n\n    if (!data) {\n      return null;\n    }\n\n    const [mesh, texture] = data;\n\n    return new SubLayerClass(props, {\n      data: DUMMY_DATA,\n      mesh,\n      texture,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      getPosition: d => [0, 0, 0],\n      getColor: color\n    });\n  }\n\n  // Update zRange of viewport\n  onViewportLoad(tiles) {\n    if (!tiles) {\n      return;\n    }\n\n    const {zRange} = this.state;\n    const ranges = tiles\n      .map(tile => tile.content)\n      .filter(Boolean)\n      .map(arr => {\n        const bounds = arr[0].header.boundingBox;\n        return bounds.map(bound => bound[2]);\n      });\n    if (ranges.length === 0) {\n      return;\n    }\n    const minZ = Math.min(...ranges.map(x => x[0]));\n    const maxZ = Math.max(...ranges.map(x => x[1]));\n\n    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {\n      this.setState({zRange: [minZ, maxZ]});\n    }\n  }\n\n  renderLayers() {\n    const {\n      color,\n      material,\n      elevationData,\n      texture,\n      wireframe,\n      meshMaxError,\n      elevationDecoder,\n      tileSize,\n      maxZoom,\n      minZoom,\n      extent,\n      maxRequests\n    } = this.props;\n\n    if (this.state.isTiled) {\n      return new TileLayer(\n        this.getSubLayerProps({\n          id: 'tiles'\n        }),\n        {\n          wireframe,\n          color,\n          material,\n          getTileData: this.getTiledTerrainData.bind(this),\n          renderSubLayers: this.renderSubLayers.bind(this),\n          updateTriggers: {\n            getTileData: {\n              elevationData: urlTemplateToUpdateTrigger(elevationData),\n              texture: urlTemplateToUpdateTrigger(texture),\n              meshMaxError,\n              elevationDecoder\n            }\n          },\n          onViewportLoad: this.onViewportLoad.bind(this),\n          zRange: this.state.zRange || null,\n          tileSize,\n          maxZoom,\n          minZoom,\n          extent,\n          maxRequests\n        }\n      );\n    }\n\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        data: DUMMY_DATA,\n        mesh: this.state.terrain,\n        texture,\n        _instanced: false,\n        getPosition: d => [0, 0, 0],\n        getColor: color,\n        material,\n        wireframe\n      }\n    );\n  }\n}\n\nTerrainLayer.layerName = 'TerrainLayer';\nTerrainLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}