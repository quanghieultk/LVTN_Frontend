{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport lightingShader from './lights.glsl';\nvar INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\nfunction convertColor() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$color = _ref.color,\n      color = _ref$color === void 0 ? [0, 0, 0] : _ref$color,\n      _ref$intensity = _ref.intensity,\n      intensity = _ref$intensity === void 0 ? 1.0 : _ref$intensity;\n\n  return color.map(function (component) {\n    return component * intensity / 255.0;\n  });\n}\n\nfunction getLightSourceUniforms(_ref2) {\n  var ambientLight = _ref2.ambientLight,\n      _ref2$pointLights = _ref2.pointLights,\n      pointLights = _ref2$pointLights === void 0 ? [] : _ref2$pointLights,\n      _ref2$directionalLigh = _ref2.directionalLights,\n      directionalLights = _ref2$directionalLigh === void 0 ? [] : _ref2$directionalLigh;\n  var lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach(function (pointLight, index) {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach(function (directionalLight, index) {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    var _ref3 = opts.lightSources || {},\n        ambientLight = _ref3.ambientLight,\n        pointLights = _ref3.pointLights,\n        directionalLights = _ref3.directionalLights;\n\n    var hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight: ambientLight,\n      pointLights: pointLights,\n      directionalLights: directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    var lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n\n    var _iterator = _createForOfIteratorHelper(opts.lights || []),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var light = _step.value;\n\n        switch (light.type) {\n          case 'ambient':\n            lightSources.ambientLight = light;\n            break;\n\n          case 'directional':\n            lightSources.directionalLights.push(light);\n            break;\n\n          case 'point':\n            lightSources.pointLights.push(light);\n            break;\n\n          default:\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return getUniforms({\n      lightSources: lightSources\n    });\n  }\n\n  return {};\n}\n\nexport var lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms: getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};","map":{"version":3,"sources":["../../../../src/modules/lights/lights.js"],"names":["INITIAL_MODULE_OPTIONS","lightSources","color","intensity","component","ambientLight","pointLights","directionalLights","lightSourceUniforms","convertColor","pointLight","directionalLight","opts","hasLights","lighting_uEnabled","getLightSourceUniforms","light","getUniforms","lights","name","vs","fs","defines","MAX_LIGHTS"],"mappings":"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","sourcesContent":["/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport lightingShader from './lights.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1,\n      0,\n      0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    // @ts-ignore\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/** @type {ShaderModule} */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n"]},"metadata":{},"sourceType":"module"}