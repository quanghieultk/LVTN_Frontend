{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport View from './view';\nimport Viewport from '../viewports/viewport';\nimport { Matrix4 } from 'math.gl';\nimport OrbitController from '../controllers/orbit-controller';\nvar DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction getViewMatrix(_ref) {\n  var height = _ref.height,\n      fovy = _ref.fovy,\n      orbitAxis = _ref.orbitAxis,\n      rotationX = _ref.rotationX,\n      rotationOrbit = _ref.rotationOrbit,\n      zoom = _ref.zoom;\n  var distance = 0.5 / Math.tan(fovy * DEGREES_TO_RADIANS / 2);\n  var up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];\n  var eye = orbitAxis === 'Z' ? [0, -distance, 0] : [0, 0, distance];\n  var viewMatrix = new Matrix4().lookAt({\n    eye: eye,\n    up: up\n  });\n  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);\n\n  if (orbitAxis === 'Z') {\n    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);\n  } else {\n    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);\n  }\n\n  var projectionScale = Math.pow(2, zoom) / (height || 1);\n  viewMatrix.scale(projectionScale);\n  return viewMatrix;\n}\n\nvar OrbitViewport = function (_Viewport) {\n  _inherits(OrbitViewport, _Viewport);\n\n  var _super = _createSuper(OrbitViewport);\n\n  function OrbitViewport(props) {\n    _classCallCheck(this, OrbitViewport);\n\n    var height = props.height,\n        _props$fovy = props.fovy,\n        fovy = _props$fovy === void 0 ? 50 : _props$fovy,\n        _props$orbitAxis = props.orbitAxis,\n        orbitAxis = _props$orbitAxis === void 0 ? 'Z' : _props$orbitAxis,\n        _props$target = props.target,\n        target = _props$target === void 0 ? [0, 0, 0] : _props$target,\n        _props$rotationX = props.rotationX,\n        rotationX = _props$rotationX === void 0 ? 0 : _props$rotationX,\n        _props$rotationOrbit = props.rotationOrbit,\n        rotationOrbit = _props$rotationOrbit === void 0 ? 0 : _props$rotationOrbit,\n        _props$zoom = props.zoom,\n        zoom = _props$zoom === void 0 ? 0 : _props$zoom;\n    return _super.call(this, _objectSpread(_objectSpread({}, props), {}, {\n      longitude: null,\n      viewMatrix: getViewMatrix({\n        height: height,\n        fovy: fovy,\n        orbitAxis: orbitAxis,\n        rotationX: rotationX,\n        rotationOrbit: rotationOrbit,\n        zoom: zoom\n      }),\n      fovy: fovy,\n      position: target,\n      zoom: zoom\n    }));\n  }\n\n  return OrbitViewport;\n}(Viewport);\n\nvar OrbitView = function (_View) {\n  _inherits(OrbitView, _View);\n\n  var _super2 = _createSuper(OrbitView);\n\n  function OrbitView(props) {\n    _classCallCheck(this, OrbitView);\n\n    return _super2.call(this, Object.assign({}, props, {\n      type: OrbitViewport\n    }));\n  }\n\n  _createClass(OrbitView, [{\n    key: \"controller\",\n    get: function get() {\n      return this._getControllerProps({\n        type: OrbitController\n      });\n    }\n  }]);\n\n  return OrbitView;\n}(View);\n\nexport { OrbitView as default };\nOrbitView.displayName = 'OrbitView';","map":{"version":3,"sources":["../../../src/views/orbit-view.js"],"names":["DEGREES_TO_RADIANS","Math","height","fovy","orbitAxis","rotationX","rotationOrbit","zoom","distance","up","eye","viewMatrix","projectionScale","OrbitViewport","Viewport","target","props","longitude","getViewMatrix","position","OrbitView","View","type","OrbitController"],"mappings":"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","sourcesContent":["import View from './view';\nimport Viewport from '../viewports/viewport';\n\nimport {Matrix4} from 'math.gl';\nimport OrbitController from '../controllers/orbit-controller';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction getViewMatrix({height, fovy, orbitAxis, rotationX, rotationOrbit, zoom}) {\n  // We position the camera so that one common space unit (world space unit scaled by zoom)\n  // at the target maps to one screen pixel.\n  // This is a similar technique to that used in web mercator projection\n  // By doing so we are able to convert between common space and screen space sizes efficiently\n  // in the vertex shader.\n  const distance = 0.5 / Math.tan((fovy * DEGREES_TO_RADIANS) / 2);\n  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];\n  const eye = orbitAxis === 'Z' ? [0, -distance, 0] : [0, 0, distance];\n\n  const viewMatrix = new Matrix4().lookAt({eye, up});\n\n  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);\n  if (orbitAxis === 'Z') {\n    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);\n  } else {\n    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);\n  }\n\n  // When height increases, we need to increase the distance from the camera to the target to\n  // keep the 1:1 mapping. However, this also changes the projected depth of each position by\n  // moving them further away between the near/far plane.\n  // Without modifying the default near/far planes, we instead scale down the common space to\n  // remove the distortion to the depth field.\n  const projectionScale = Math.pow(2, zoom) / (height || 1);\n  viewMatrix.scale(projectionScale);\n\n  return viewMatrix;\n}\n\nclass OrbitViewport extends Viewport {\n  constructor(props) {\n    const {\n      height,\n      fovy = 50, // From eye position to lookAt\n      orbitAxis = 'Z', // Orbit axis with 360 degrees rotating freedom, can only be 'Y' or 'Z'\n      target = [0, 0, 0], // Which point is camera looking at, default origin\n\n      rotationX = 0, // Rotating angle around X axis\n      rotationOrbit = 0, // Rotating angle around orbit axis\n\n      zoom = 0\n    } = props;\n\n    super({\n      ...props,\n      // in case viewState contains longitude/latitude values,\n      // make sure that the base Viewport class does not treat this as a geospatial viewport\n      longitude: null,\n      viewMatrix: getViewMatrix({\n        height,\n        fovy,\n        orbitAxis,\n        rotationX,\n        rotationOrbit,\n        zoom\n      }),\n      fovy,\n      position: target,\n      zoom\n    });\n  }\n}\n\nexport default class OrbitView extends View {\n  constructor(props) {\n    super(\n      Object.assign({}, props, {\n        type: OrbitViewport\n      })\n    );\n  }\n\n  get controller() {\n    return this._getControllerProps({\n      type: OrbitController\n    });\n  }\n}\n\nOrbitView.displayName = 'OrbitView';\n"]},"metadata":{},"sourceType":"module"}