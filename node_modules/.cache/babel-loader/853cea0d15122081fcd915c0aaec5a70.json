{"ast":null,"code":"import { equals } from '@math.gl/core';\nexport var WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirection(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var area = 0;\n  forEachSegmentInPolygon(points, function (p1x, p1y, p2x, p2y) {\n    area += areaCalcCallback(p1x, p1y, p2x, p2y);\n  }, options);\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$start = options.start,\n      start = _options$start === void 0 ? 0 : _options$start,\n      _options$end = options.end,\n      end = _options$end === void 0 ? points.length : _options$end,\n      _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      isClosed = options.isClosed;\n  var numPoints = (end - start) / size;\n\n  for (var i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  var endPointIndex = start + (numPoints - 1) * size;\n  var isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  var _options$start2 = options.start,\n      start = _options$start2 === void 0 ? 0 : _options$start2,\n      _options$end2 = options.end,\n      end = _options$end2 === void 0 ? points.length : _options$end2,\n      _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2;\n  var numPoints = (end - start) / size;\n  var numSwaps = Math.floor(numPoints / 2);\n\n  for (var i = 0; i < numSwaps; ++i) {\n    var b1 = start + i * size;\n    var b2 = start + (numPoints - 1 - i) * size;\n\n    for (var j = 0; j < size; ++j) {\n      var tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nexport function modifyPolygonWindingDirectionPoints(points, direction) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var currentDirection = getPolygonWindingDirectionPoints(points, params);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Math.sign(getPolygonSignedAreaPoints(points, params));\n}\nexport function getPolygonSignedAreaPoints(points) {\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var area = 0;\n  forEachSegmentInPolygonPoints(points, function (p1, p2) {\n    area += areaCalcCallback(p1[0], p1[1], p2[0], p2[1]);\n  }, params);\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor) {\n  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _params$start = params.start,\n      start = _params$start === void 0 ? 0 : _params$start,\n      _params$end = params.end,\n      end = _params$end === void 0 ? points.length : _params$end,\n      isClosed = params.isClosed;\n\n  for (var i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  var isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n\nfunction areaCalcCallback(p1x, p1y, p2x, p2y) {\n  return (p1x + p2x) * (p1y - p2y);\n}","map":{"version":3,"sources":["../../src/polygon-utils.js"],"names":["WINDING","CLOCKWISE","COUNTER_CLOCKWISE","options","windingDirection","getPolygonWindingDirection","reversePolygon","Math","getPolygonSignedArea","area","forEachSegmentInPolygon","areaCalcCallback","start","end","points","size","isClosed","numPoints","i","visitor","endPointIndex","isClosedEx","equals","numSwaps","b1","b2","j","tmp","params","currentDirection","getPolygonWindingDirectionPoints","getPolygonSignedAreaPoints","forEachSegmentInPolygonPoints","p1","p2","p1x","p1y"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\n\n/** @type {typeof import('./polygon-utils').WINDING} */\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\n\n/** @type {typeof import('./polygon-utils').modifyPolygonWindingDirection} */\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonWindingDirection} */\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonSignedArea} */\nexport function getPolygonSignedArea(points, options = {}) {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  let area = 0;\n  forEachSegmentInPolygon(\n    points,\n    (p1x, p1y, p2x, p2y) => {\n      area += areaCalcCallback(p1x, p1y, p2x, p2y);\n    },\n    options\n  );\n\n  return area / 2;\n}\n\n/** @type {typeof import('./polygon-utils').forEachSegmentInPolygon} */\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/** @type {typeof import('./polygon-utils').modifyPolygonWindingDirectionPoints} */\nexport function modifyPolygonWindingDirectionPoints(points, direction, params = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, params);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonWindingDirectionPoints} */\nexport function getPolygonWindingDirectionPoints(points, params = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, params));\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonSignedAreaPoints} */\nexport function getPolygonSignedAreaPoints(points, params = {}) {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  let area = 0;\n  forEachSegmentInPolygonPoints(\n    points,\n    (p1, p2) => {\n      area += areaCalcCallback(p1[0], p1[1], p2[0], p2[1]);\n    },\n    params\n  );\n  return area / 2;\n}\n\n/** @type {typeof import('./polygon-utils').forEachSegmentInPolygonPoints} */\nexport function forEachSegmentInPolygonPoints(points, visitor, params = {}) {\n  const {start = 0, end = points.length, isClosed} = params;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n\nfunction areaCalcCallback(p1x, p1y, p2x, p2y) {\n  // the \"cancelling\" cross-products: (p1.x + p2.x) * (p1.y - p2.y)\n  return (p1x + p2x) * (p1y - p2y);\n}\n"]},"metadata":{},"sourceType":"module"}