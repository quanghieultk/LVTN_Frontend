{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { getMeshBoundingBox } from '@loaders.gl/loader-utils';\nvar GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\nvar DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\nvar DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nvar DracoParser = function () {\n  function DracoParser(draco) {\n    _classCallCheck(this, DracoParser);\n\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n    this.metadataQuerier = {};\n  }\n\n  _createClass(DracoParser, [{\n    key: \"destroy\",\n    value: function destroy() {}\n  }, {\n    key: \"destroyGeometry\",\n    value: function destroyGeometry(dracoGeometry) {\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry.dracoGeometry);\n      }\n    }\n  }, {\n    key: \"parseSync\",\n    value: function parseSync(arrayBuffer) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.metadataQuerier = new this.draco.MetadataQuerier();\n      var buffer = new this.draco.DecoderBuffer();\n      buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n      var decoder = new this.draco.Decoder();\n      var data = {};\n      var dracoStatus;\n      var dracoGeometry;\n      var header;\n\n      try {\n        var geometryType = decoder.GetEncodedGeometryType(buffer);\n\n        switch (geometryType) {\n          case this.draco.TRIANGULAR_MESH:\n            dracoGeometry = new this.draco.Mesh();\n            dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n            header = {\n              type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n              faceCount: dracoGeometry.num_faces(),\n              attributeCount: dracoGeometry.num_attributes(),\n              vertexCount: dracoGeometry.num_points()\n            };\n            break;\n\n          case this.draco.POINT_CLOUD:\n            dracoGeometry = new this.draco.PointCloud();\n            dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n            header = {\n              type: GEOMETRY_TYPE.POINT_CLOUD,\n              attributeCount: dracoGeometry.num_attributes(),\n              vertexCount: dracoGeometry.num_points()\n            };\n            break;\n\n          default:\n            throw new Error('Unknown DRACO geometry type.');\n        }\n\n        if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n          var message = \"DRACO decompression failed: \".concat(dracoStatus.error_msg());\n\n          if (dracoGeometry) {\n            this.draco.destroy(dracoGeometry);\n          }\n\n          throw new Error(message);\n        }\n\n        data.loaderData = {\n          header: header\n        };\n\n        this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);\n\n        var metadata = this._getGeometryMetadata(decoder, dracoGeometry);\n\n        data.header = {\n          vertexCount: header.vertexCount,\n          boundingBox: getMeshBoundingBox(data.attributes),\n          metadata: metadata\n        };\n      } finally {\n        this.draco.destroy(decoder);\n        this.draco.destroy(buffer);\n        this.draco.destroy(dracoGeometry);\n        this.draco.destroy(this.metadataQuerier);\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_extractDRACOGeometry\",\n    value: function _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {\n      var attributes = this._getAttributes(decoder, dracoGeometry, options);\n\n      var positionAttribute = attributes.POSITION;\n\n      if (!positionAttribute) {\n        throw new Error('DRACO decompressor: No position attribute found.');\n      }\n\n      if (geometryType === this.draco.TRIANGULAR_MESH) {\n        attributes.indices = this.drawMode === 'TRIANGLE_STRIP' ? this._getMeshStripIndices(decoder, dracoGeometry) : this._getMeshFaceIndices(decoder, dracoGeometry);\n        geometry.mode = this.drawMode === 'TRIANGLE_STRIP' ? 5 : 4;\n      } else {\n        geometry.mode = 0;\n      }\n\n      if (attributes.indices) {\n        geometry.indices = {\n          value: attributes.indices,\n          size: 1\n        };\n        delete attributes.indices;\n      }\n\n      geometry.attributes = attributes;\n      return geometry;\n    }\n  }, {\n    key: \"getPositionAttributeMetadata\",\n    value: function getPositionAttributeMetadata(positionAttribute) {\n      this.metadata = this.metadata || {};\n      this.metadata.attributes = this.metadata.attributes || {};\n      var posTransform = new this.draco.AttributeQuantizationTransform();\n\n      if (posTransform.InitFromAttribute(positionAttribute)) {\n        this.metadata.attributes.position.isQuantized = true;\n        this.metadata.attributes.position.maxRange = posTransform.range();\n        this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n        this.metadata.attributes.position.minValues = new Float32Array(3);\n\n        for (var i = 0; i < 3; ++i) {\n          this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n        }\n      }\n\n      this.draco.destroy(posTransform);\n    }\n  }, {\n    key: \"_getAttributes\",\n    value: function _getAttributes(decoder, dracoGeometry, options) {\n      var attributes = {};\n      var numPoints = dracoGeometry.num_points();\n\n      for (var attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n        var dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n\n        var attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);\n\n        var attributeData = {\n          uniqueId: dracoAttribute.unique_id(),\n          attributeType: dracoAttribute.attribute_type(),\n          dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],\n          size: dracoAttribute.size(),\n          numComponents: dracoAttribute.num_components(),\n          byteOffset: dracoAttribute.byte_offset(),\n          byteStride: dracoAttribute.byte_stride(),\n          normalized: dracoAttribute.normalized(),\n          metadata: attributeMetadata\n        };\n\n        var attributeName = this._deduceAttributeName(attributeData, options);\n\n        var _this$_getAttributeTy = this._getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName),\n            typedArray = _this$_getAttributeTy.typedArray;\n\n        attributes[attributeName] = {\n          value: typedArray,\n          size: typedArray.length / numPoints,\n          metadata: attributeMetadata\n        };\n      }\n\n      return attributes;\n    }\n  }, {\n    key: \"_getMeshFaceIndices\",\n    value: function _getMeshFaceIndices(decoder, dracoGeometry) {\n      var numFaces = dracoGeometry.num_faces();\n      var numIndices = numFaces * 3;\n      var indices = new Uint32Array(numIndices);\n      var dracoArray = new this.draco.DracoInt32Array();\n\n      for (var i = 0; i < numFaces; ++i) {\n        decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n        var index = i * 3;\n        indices[index] = dracoArray.GetValue(0);\n        indices[index + 1] = dracoArray.GetValue(1);\n        indices[index + 2] = dracoArray.GetValue(2);\n      }\n\n      this.draco.destroy(dracoArray);\n      return indices;\n    }\n  }, {\n    key: \"_getMeshStripIndices\",\n    value: function _getMeshStripIndices(decoder, dracoGeometry) {\n      var dracoArray = new this.draco.DracoInt32Array();\n      decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      var indices = new Uint32Array(dracoArray.size());\n\n      for (var i = 0; i < dracoArray.size(); ++i) {\n        indices[i] = dracoArray.GetValue(i);\n      }\n\n      this.draco.destroy(dracoArray);\n      return indices;\n    }\n  }, {\n    key: \"_getAttributeTypedArray\",\n    value: function _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n      if (dracoAttribute.ptr === 0) {\n        var message = \"DRACO decode bad attribute \".concat(attributeName);\n        throw new Error(message);\n      }\n\n      var attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n      var numComponents = dracoAttribute.num_components();\n      var numPoints = dracoGeometry.num_points();\n      var numValues = numPoints * numComponents;\n      var dracoArray;\n      var typedArray;\n\n      switch (attributeType) {\n        case Float32Array:\n          dracoArray = new this.draco.DracoFloat32Array();\n          decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Float32Array(numValues);\n          break;\n\n        case Int8Array:\n          dracoArray = new this.draco.DracoInt8Array();\n          decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int8Array(numValues);\n          break;\n\n        case Int16Array:\n          dracoArray = new this.draco.DracoInt16Array();\n          decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int16Array(numValues);\n          break;\n\n        case Int32Array:\n          dracoArray = new this.draco.DracoInt32Array();\n          decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Int32Array(numValues);\n          break;\n\n        case Uint8Array:\n          dracoArray = new this.draco.DracoUInt8Array();\n          decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint8Array(numValues);\n          break;\n\n        case Uint16Array:\n          dracoArray = new this.draco.DracoUInt16Array();\n          decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint16Array(numValues);\n          break;\n\n        case Uint32Array:\n          dracoArray = new this.draco.DracoUInt32Array();\n          decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n          typedArray = new Uint32Array(numValues);\n          break;\n\n        default:\n          var errorMsg = 'DRACO decoder: unexpected attribute type.';\n          throw new Error(errorMsg);\n      }\n\n      for (var i = 0; i < numValues; i++) {\n        typedArray[i] = dracoArray.GetValue(i);\n      }\n\n      this.draco.destroy(dracoArray);\n      return {\n        typedArray: typedArray,\n        components: numComponents\n      };\n    }\n  }, {\n    key: \"_deduceAttributeName\",\n    value: function _deduceAttributeName(attributeData, options) {\n      var _options$extraAttribu = options.extraAttributes,\n          extraAttributes = _options$extraAttribu === void 0 ? {} : _options$extraAttribu;\n\n      if (extraAttributes && _typeof(extraAttributes) === 'object') {\n        for (var _i = 0, _Object$entries = Object.entries(extraAttributes); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              attributeName = _Object$entries$_i[0],\n              attributeUniqueId = _Object$entries$_i[1];\n\n          if (attributeUniqueId === attributeData.uniqueId) {\n            return attributeName;\n          }\n        }\n      }\n\n      for (var dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n        var attributeType = this.draco[dracoAttributeConstant];\n\n        if (attributeData.attributeType === attributeType) {\n          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n        }\n      }\n\n      if (attributeData.metadata) {\n        var entryName = options.attributeNameEntry || 'name';\n\n        if (attributeData.metadata[entryName]) {\n          return attributeData.metadata[entryName].string;\n        }\n      }\n\n      return \"CUSTOM_ATTRIBUTE_\".concat(attributeData.uniqueId);\n    }\n  }, {\n    key: \"_getGeometryMetadata\",\n    value: function _getGeometryMetadata(decoder, dracoGeometry) {\n      var dracoMetadata = decoder.GetMetadata(dracoGeometry);\n      return this._queryDracoMetadata(dracoMetadata);\n    }\n  }, {\n    key: \"_getAttributeMetadata\",\n    value: function _getAttributeMetadata(decoder, dracoGeometry, attributeId) {\n      var dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n      return this._queryDracoMetadata(dracoMetadata);\n    }\n  }, {\n    key: \"_queryDracoMetadata\",\n    value: function _queryDracoMetadata(dracoMetadata) {\n      if (!dracoMetadata || !dracoMetadata.ptr) {\n        return {};\n      }\n\n      var result = {};\n      var numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n\n      for (var entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n        var entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n        result[entryName] = {\n          \"int\": this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n          \"double\": this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n          intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)\n        };\n      }\n\n      return result;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(arrayBuffer, options) {\n      return this.parseSync(arrayBuffer, options);\n    }\n  }]);\n\n  return DracoParser;\n}();\n\nexport { DracoParser as default };","map":{"version":3,"sources":["../../../src/lib/draco-parser.js"],"names":["GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Float32Array","DracoParser","dracoGeometry","arrayBuffer","options","buffer","decoder","data","geometryType","dracoStatus","header","type","faceCount","attributeCount","vertexCount","message","metadata","boundingBox","getMeshBoundingBox","geometry","attributes","positionAttribute","value","size","posTransform","i","numPoints","attributeId","dracoAttribute","attributeMetadata","attributeData","uniqueId","attributeType","dataType","numComponents","byteOffset","byteStride","normalized","attributeName","typedArray","numFaces","numIndices","indices","dracoArray","index","numValues","errorMsg","components","extraAttributes","attributeUniqueId","Object","entryName","dracoMetadata","result","numEntries","entryIndex","string","intArray"],"mappings":"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","sourcesContent":["// This code is inspired by example code in the DRACO repository\n/** @typedef {import('../types/draco-types')} Draco3D */\n/** @typedef {import('../types/draco-types').Decoder} Decoder */\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nexport default class DracoParser {\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco) {\n    /** @type {Draco3D} */\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n    this.metadataQuerier = {};\n  }\n\n  destroy() {}\n\n  destroyGeometry(dracoGeometry) {\n    if (dracoGeometry) {\n      this.draco.destroy(dracoGeometry.dracoGeometry);\n    }\n  }\n\n  // NOTE: caller must call `destroyGeometry` on the return value after using it\n  parseSync(arrayBuffer, options = {}) {\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    const decoder = new this.draco.Decoder();\n\n    const data = {};\n    let dracoStatus;\n    let dracoGeometry;\n    let header;\n\n    try {\n      const geometryType = decoder.GetEncodedGeometryType(buffer);\n      switch (geometryType) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoGeometry = new this.draco.Mesh();\n          dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n            faceCount: dracoGeometry.num_faces(),\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoGeometry = new this.draco.PointCloud();\n          dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.POINT_CLOUD,\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        default:\n          throw new Error('Unknown DRACO geometry type.');\n      }\n\n      // @ts-ignore .ptr\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        if (dracoGeometry) {\n          this.draco.destroy(dracoGeometry);\n        }\n        throw new Error(message);\n      }\n\n      data.loaderData = {header};\n\n      this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);\n      const metadata = this._getGeometryMetadata(decoder, dracoGeometry);\n\n      data.header = {\n        vertexCount: header.vertexCount,\n        boundingBox: getMeshBoundingBox(data.attributes),\n        metadata\n      };\n    } finally {\n      this.draco.destroy(decoder);\n      this.draco.destroy(buffer);\n      this.draco.destroy(dracoGeometry);\n      this.draco.destroy(this.metadataQuerier);\n    }\n\n    return data;\n  }\n\n  /**\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} geometryType\n   * @param {*} geometry\n   * @param {object} options\n   */\n  _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {\n    const attributes = this._getAttributes(decoder, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO decompressor: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (geometryType === this.draco.TRIANGULAR_MESH) {\n      attributes.indices =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? /**\n             *\n             * @param {*} decoder\n             * @param {*} dracoGeometry\n             */\n            this._getMeshStripIndices(decoder, dracoGeometry)\n          : this._getMeshFaceIndices(decoder, dracoGeometry);\n      geometry.mode =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? 5 // GL.TRIANGLE_STRIP\n          : 4; // GL.TRIANGLES\n    } else {\n      geometry.mode = 0; // GL.POINTS\n    }\n\n    if (attributes.indices) {\n      geometry.indices = {value: attributes.indices, size: 1};\n      delete attributes.indices;\n    }\n    geometry.attributes = attributes;\n\n    return geometry;\n  }\n\n  getPositionAttributeMetadata(positionAttribute) {\n    this.metadata = this.metadata || {};\n    this.metadata.attributes = this.metadata.attributes || {};\n\n    const posTransform = new this.draco.AttributeQuantizationTransform();\n    if (posTransform.InitFromAttribute(positionAttribute)) {\n      // Quantized attribute. Store the quantization parameters into the attribute\n      this.metadata.attributes.position.isQuantized = true;\n      this.metadata.attributes.position.maxRange = posTransform.range();\n      this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n      this.metadata.attributes.position.minValues = new Float32Array(3);\n      for (let i = 0; i < 3; ++i) {\n        this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n      }\n    }\n    this.draco.destroy(posTransform);\n  }\n\n  _getAttributes(decoder, dracoGeometry, options) {\n    const attributes = {};\n    const numPoints = dracoGeometry.num_points();\n    // const attributeUniqueIdMap = {};\n\n    // Note: Draco docs do not seem clear on `GetAttribute` accepting a zero-based index,\n    // but it seems to work this way\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);\n      const attributeData = {\n        uniqueId: dracoAttribute.unique_id(),\n        attributeType: dracoAttribute.attribute_type(),\n        dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],\n        size: dracoAttribute.size(),\n        numComponents: dracoAttribute.num_components(),\n        byteOffset: dracoAttribute.byte_offset(),\n        byteStride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        metadata: attributeMetadata\n      };\n\n      // DRACO does not store attribute names - We need to deduce an attribute name\n      const attributeName = this._deduceAttributeName(attributeData, options);\n\n      const {typedArray} = this._getAttributeTypedArray(\n        decoder,\n        dracoGeometry,\n        dracoAttribute,\n        attributeName\n      );\n      attributes[attributeName] = {\n        value: typedArray,\n        size: typedArray.length / numPoints,\n        metadata: attributeMetadata\n      };\n    }\n\n    return attributes;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshFaceIndices(decoder, dracoGeometry) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n\n    const numIndices = numFaces * 3;\n    const indices = new Uint32Array(numIndices);\n    const dracoArray = new this.draco.DracoInt32Array();\n    for (let i = 0; i < numFaces; ++i) {\n      decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n      const index = i * 3;\n      indices[index] = dracoArray.GetValue(0);\n      indices[index + 1] = dracoArray.GetValue(1);\n      indices[index + 2] = dracoArray.GetValue(2);\n    }\n\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshStripIndices(decoder, dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    /* const numStrips = */ decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n    const indices = new Uint32Array(dracoArray.size());\n    for (let i = 0; i < dracoArray.size(); ++i) {\n      indices[i] = dracoArray.GetValue(i);\n    }\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   *\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} dracoAttribute\n   * @param {*} attributeName\n   */\n  _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n    if (dracoAttribute.ptr === 0) {\n      const message = `DRACO decode bad attribute ${attributeName}`;\n      // console.error(message);\n      throw new Error(message);\n    }\n\n    const attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n    const numComponents = dracoAttribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    let dracoArray;\n    let typedArray;\n\n    switch (attributeType) {\n      case Float32Array:\n        dracoArray = new this.draco.DracoFloat32Array();\n        decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Float32Array(numValues);\n        break;\n\n      case Int8Array:\n        dracoArray = new this.draco.DracoInt8Array();\n        decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int8Array(numValues);\n        break;\n\n      case Int16Array:\n        dracoArray = new this.draco.DracoInt16Array();\n        decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int16Array(numValues);\n        break;\n\n      case Int32Array:\n        dracoArray = new this.draco.DracoInt32Array();\n        decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int32Array(numValues);\n        break;\n\n      case Uint8Array:\n        dracoArray = new this.draco.DracoUInt8Array();\n        decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint8Array(numValues);\n        break;\n\n      case Uint16Array:\n        dracoArray = new this.draco.DracoUInt16Array();\n        decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint16Array(numValues);\n        break;\n\n      case Uint32Array:\n        dracoArray = new this.draco.DracoUInt32Array();\n        decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint32Array(numValues);\n        break;\n\n      default:\n        const errorMsg = 'DRACO decoder: unexpected attribute type.';\n        // console.error(errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    // Copy data from decoder.\n    for (let i = 0; i < numValues; i++) {\n      typedArray[i] = dracoArray.GetValue(i);\n    }\n\n    this.draco.destroy(dracoArray);\n\n    return {typedArray, components: numComponents};\n  }\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param {object} attributeData\n   */\n  _deduceAttributeName(attributeData, options) {\n    const {extraAttributes = {}} = options;\n    if (extraAttributes && typeof extraAttributes === 'object') {\n      for (const [attributeName, attributeUniqueId] of Object.entries(extraAttributes)) {\n        if (attributeUniqueId === attributeData.uniqueId) {\n          return attributeName;\n        }\n      }\n    }\n\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeData.attributeType === attributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    if (attributeData.metadata) {\n      const entryName = options.attributeNameEntry || 'name';\n      if (attributeData.metadata[entryName]) {\n        return attributeData.metadata[entryName].string;\n      }\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${attributeData.uniqueId}`;\n  }\n\n  _getGeometryMetadata(decoder, dracoGeometry) {\n    const dracoMetadata = decoder.GetMetadata(dracoGeometry);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  _getAttributeMetadata(decoder, dracoGeometry, attributeId) {\n    const dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  // The not so wonderful world of undocumented Draco APIs :(\n  _queryDracoMetadata(dracoMetadata) {\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)\n      };\n    }\n    return result;\n  }\n\n  // DEPRECATED\n\n  decode(arrayBuffer, options) {\n    return this.parseSync(arrayBuffer, options);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}