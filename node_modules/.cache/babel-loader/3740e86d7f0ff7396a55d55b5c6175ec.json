{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar ES300_REPLACEMENTS = [[/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'], [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('], [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']];\nvar ES300_VERTEX_REPLACEMENTS = [].concat(ES300_REPLACEMENTS, [[/^[ \\t]*attribute[ \\t]+(.+;)/gm, 'in $1'], [/^[ \\t]*varying[ \\t]+(.+;)/gm, 'out $1']]);\nvar ES300_FRAGMENT_REPLACEMENTS = [].concat(ES300_REPLACEMENTS, [[/^[ \\t]*varying[ \\t]+(.+;)/gm, 'in $1']]);\nvar ES100_REPLACEMENTS = [[/^#version[ \\t]+300[ \\t]+es/, '#version 100'], [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('], [/\\btexture\\(/g, 'texture2D('], [/\\btextureLod\\(/g, 'texture2DLodEXT(']];\nvar ES100_VERTEX_REPLACEMENTS = [].concat(ES100_REPLACEMENTS, [[/^[ \\t]*in[ \\t]+(.+;)/gm, 'attribute $1'], [/^[ \\t]*out[ \\t]+(.+;)/gm, 'varying $1']]);\nvar ES100_FRAGMENT_REPLACEMENTS = [].concat(ES100_REPLACEMENTS, [[/^[ \\t]*in[ \\t]+/gm, 'varying ']]);\nvar FS_OUTPUT_REGEX = /^[ \\t]*out[ \\t]+vec4[ \\t]+(\\w+)[ \\t]*;\\s+/m;\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return convertShader(source, isVertex ? ES300_VERTEX_REPLACEMENTS : ES300_FRAGMENT_REPLACEMENTS);\n\n    case 100:\n      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);\n\n    default:\n      throw new Error(\"unknown GLSL version \".concat(targetGLSLVersion));\n  }\n}\n\nfunction convertShader(source, replacements) {\n  var _iterator = _createForOfIteratorHelper(replacements),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          pattern = _step$value[0],\n          replacement = _step$value[1];\n\n      source = source.replace(pattern, replacement);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return source;\n}\n\nfunction convertFragmentShaderTo100(source) {\n  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);\n  var outputMatch = source.match(FS_OUTPUT_REGEX);\n\n  if (outputMatch) {\n    var outputName = outputMatch[1];\n    source = source.replace(FS_OUTPUT_REGEX, '').replace(new RegExp(\"\\\\b\".concat(outputName, \"\\\\b\"), 'g'), 'gl_FragColor');\n  }\n\n  return source;\n}","map":{"version":3,"sources":["../../../src/lib/transpile-shader.js"],"names":["ES300_REPLACEMENTS","ES300_VERTEX_REPLACEMENTS","ES300_FRAGMENT_REPLACEMENTS","ES100_REPLACEMENTS","ES100_VERTEX_REPLACEMENTS","ES100_FRAGMENT_REPLACEMENTS","FS_OUTPUT_REGEX","convertShader","isVertex","convertFragmentShaderTo100","pattern","replacement","source","outputMatch","outputName"],"mappings":"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","sourcesContent":["// TRANSPILATION TABLES\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS = [\n  // Fix poorly formatted version directive\n  [/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n  // The individual `texture...()` functions were replaced with `texture()` overloads\n  [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('],\n  [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']\n];\n\nconst ES300_VERTEX_REPLACEMENTS = [\n  ...ES300_REPLACEMENTS,\n  // `attribute` keyword replaced with `in`\n  [/^[ \\t]*attribute[ \\t]+(.+;)/gm, 'in $1'],\n  // `varying` keyword replaced with `out`\n  [/^[ \\t]*varying[ \\t]+(.+;)/gm, 'out $1']\n];\n\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS = [\n  ...ES300_REPLACEMENTS,\n  // `varying` keyword replaced with `in`\n  [/^[ \\t]*varying[ \\t]+(.+;)/gm, 'in $1']\n];\n\nconst ES100_REPLACEMENTS = [\n  [/^#version[ \\t]+300[ \\t]+es/, '#version 100'],\n\n  // In GLSL 1.00 ES these functions are provided by an extension\n  [/\\btexture(2D|2DProj|Cube)Lod\\(/g, 'texture$1LodEXT('],\n\n  // Overloads in GLSL 3.00 map to individual functions. Note that we cannot\n  // differentiate 2D,2DProj,Cube without type analysis so we choose the most common variant.\n  [/\\btexture\\(/g, 'texture2D('],\n  [/\\btextureLod\\(/g, 'texture2DLodEXT(']\n];\n\nconst ES100_VERTEX_REPLACEMENTS = [\n  ...ES100_REPLACEMENTS,\n  [/^[ \\t]*in[ \\t]+(.+;)/gm, 'attribute $1'],\n  [/^[ \\t]*out[ \\t]+(.+;)/gm, 'varying $1']\n];\n\nconst ES100_FRAGMENT_REPLACEMENTS = [\n  ...ES100_REPLACEMENTS,\n  // Replace `in` with `varying`\n  [/^[ \\t]*in[ \\t]+/gm, 'varying ']\n];\n\nconst FS_OUTPUT_REGEX = /^[ \\t]*out[ \\t]+vec4[ \\t]+(\\w+)[ \\t]*;\\s+/m;\n\n// Transpiles shader source code to target GLSL version\n// Note: We always run transpiler even if same version e.g. 3.00 => 3.00\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\nexport default function transpileShader(source, targetGLSLVersion, isVertex) {\n  switch (targetGLSLVersion) {\n    case 300:\n      return convertShader(\n        source,\n        isVertex ? ES300_VERTEX_REPLACEMENTS : ES300_FRAGMENT_REPLACEMENTS\n      );\n    case 100:\n      return isVertex\n        ? convertShader(source, ES100_VERTEX_REPLACEMENTS)\n        : convertFragmentShaderTo100(source);\n    default:\n      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);\n  }\n}\n\nfunction convertShader(source, replacements) {\n  for (const [pattern, replacement] of replacements) {\n    source = source.replace(pattern, replacement);\n  }\n  return source;\n}\n\nfunction convertFragmentShaderTo100(source) {\n  // /gm - treats each line as a string, so that ^ matches after newlines\n  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);\n\n  const outputMatch = source.match(FS_OUTPUT_REGEX);\n  if (outputMatch) {\n    const outputName = outputMatch[1];\n    source = source\n      .replace(FS_OUTPUT_REGEX, '')\n      .replace(new RegExp(`\\\\b${outputName}\\\\b`, 'g'), 'gl_FragColor');\n  }\n\n  return source;\n}\n"]},"metadata":{},"sourceType":"module"}