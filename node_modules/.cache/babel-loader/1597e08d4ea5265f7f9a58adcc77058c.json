{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { getCode, getVertices, CONTOUR_TYPE } from './marching-squares';\nexport function generateContours(_ref) {\n  var thresholdData = _ref.thresholdData,\n      colors = _ref.colors,\n      cellWeights = _ref.cellWeights,\n      gridSize = _ref.gridSize,\n      gridOrigin = _ref.gridOrigin,\n      cellSize = _ref.cellSize;\n  var contourSegments = [];\n  var contourPolygons = [];\n  var width = gridSize[0];\n  var height = gridSize[1];\n  var segmentIndex = 0;\n  var polygonIndex = 0;\n\n  var _iterator = _createForOfIteratorHelper(thresholdData),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var data = _step.value;\n      var contour = data.contour;\n      var threshold = contour.threshold;\n\n      for (var x = -1; x < width; x++) {\n        for (var y = -1; y < height; y++) {\n          var _getCode = getCode({\n            cellWeights: cellWeights,\n            threshold: threshold,\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          }),\n              code = _getCode.code,\n              meanCode = _getCode.meanCode;\n\n          var opts = {\n            gridOrigin: gridOrigin,\n            cellSize: cellSize,\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            code: code,\n            meanCode: meanCode,\n            thresholdData: data\n          };\n\n          if (Array.isArray(threshold)) {\n            opts.type = CONTOUR_TYPE.ISO_BANDS;\n            var polygons = getVertices(opts);\n\n            var _iterator2 = _createForOfIteratorHelper(polygons),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var polygon = _step2.value;\n                contourPolygons[polygonIndex++] = {\n                  vertices: polygon,\n                  contour: contour\n                };\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          } else {\n            opts.type = CONTOUR_TYPE.ISO_LINES;\n            var vertices = getVertices(opts);\n\n            for (var i = 0; i < vertices.length; i += 2) {\n              contourSegments[segmentIndex++] = {\n                start: vertices[i],\n                end: vertices[i + 1],\n                contour: contour\n              };\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    contourSegments: contourSegments,\n    contourPolygons: contourPolygons\n  };\n}","map":{"version":3,"sources":["../../../src/contour-layer/contour-utils.js"],"names":["thresholdData","colors","cellWeights","gridSize","gridOrigin","cellSize","contourSegments","contourPolygons","width","height","segmentIndex","polygonIndex","data","contour","threshold","x","y","code","meanCode","getCode","opts","Array","CONTOUR_TYPE","polygons","getVertices","polygon","vertices","i","start","end"],"mappings":"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","sourcesContent":["import {getCode, getVertices, CONTOUR_TYPE} from './marching-squares';\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  thresholdData,\n  colors,\n  cellWeights,\n  gridSize,\n  gridOrigin,\n  cellSize\n}) {\n  const contourSegments = [];\n  const contourPolygons = [];\n  const width = gridSize[0];\n  const height = gridSize[1];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (const data of thresholdData) {\n    const {contour} = data;\n    const {threshold} = contour;\n    for (let x = -1; x < width; x++) {\n      for (let y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          cellWeights,\n          threshold,\n          x,\n          y,\n          width,\n          height\n        });\n        const opts = {\n          gridOrigin,\n          cellSize,\n          x,\n          y,\n          width,\n          height,\n          code,\n          meanCode,\n          thresholdData: data\n        };\n        if (Array.isArray(threshold)) {\n          opts.type = CONTOUR_TYPE.ISO_BANDS;\n          const polygons = getVertices(opts);\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // Get the intersection vertices based on MarchingSquares code.\n          opts.type = CONTOUR_TYPE.ISO_LINES;\n          const vertices = getVertices(opts);\n          for (let i = 0; i < vertices.length; i += 2) {\n            contourSegments[segmentIndex++] = {\n              start: vertices[i],\n              end: vertices[i + 1],\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {contourSegments, contourPolygons};\n}\n/* eslint-enable max-depth */\n"]},"metadata":{},"sourceType":"module"}