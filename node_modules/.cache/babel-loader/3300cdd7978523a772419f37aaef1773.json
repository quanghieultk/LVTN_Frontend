{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport Pass from './pass';\nimport { clear, setParameters, withParameters, cssToDeviceRatio } from '@luma.gl/core';\nimport log from '../utils/log';\n\nvar LayersPass = function (_Pass) {\n  _inherits(LayersPass, _Pass);\n\n  var _super = _createSuper(LayersPass);\n\n  function LayersPass() {\n    _classCallCheck(this, LayersPass);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(LayersPass, [{\n    key: \"render\",\n    value: function render(props) {\n      var gl = this.gl;\n      setParameters(gl, {\n        framebuffer: props.target\n      });\n      return this._drawLayers(props);\n    }\n  }, {\n    key: \"_drawLayers\",\n    value: function _drawLayers(props) {\n      var viewports = props.viewports,\n          views = props.views,\n          onViewportActive = props.onViewportActive,\n          _props$clearCanvas = props.clearCanvas,\n          clearCanvas = _props$clearCanvas === void 0 ? true : _props$clearCanvas;\n      var gl = this.gl;\n\n      if (clearCanvas) {\n        clearGLCanvas(gl);\n      }\n\n      var renderStats = [];\n\n      var _iterator = _createForOfIteratorHelper(viewports),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var viewportOrDescriptor = _step.value;\n          var viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;\n          var view = views && views[viewport.id];\n          onViewportActive(viewport);\n\n          var drawLayerParams = this._getDrawLayerParams(viewport, props);\n\n          props.view = view;\n          var subViewports = viewport.subViewports || [viewport];\n\n          var _iterator2 = _createForOfIteratorHelper(subViewports),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var subViewport = _step2.value;\n              props.viewport = subViewport;\n\n              var stats = this._drawLayersInViewport(gl, props, drawLayerParams);\n\n              renderStats.push(stats);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return renderStats;\n    }\n  }, {\n    key: \"_getDrawLayerParams\",\n    value: function _getDrawLayerParams(viewport, _ref) {\n      var layers = _ref.layers,\n          _ref$pass = _ref.pass,\n          pass = _ref$pass === void 0 ? 'unknown' : _ref$pass,\n          layerFilter = _ref.layerFilter,\n          effects = _ref.effects,\n          moduleParameters = _ref.moduleParameters;\n      var drawLayerParams = [];\n      var indexResolver = layerIndexResolver();\n\n      for (var layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n        var layer = layers[layerIndex];\n\n        var shouldDrawLayer = this._shouldDrawLayer(layer, viewport, pass, layerFilter);\n\n        var layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n        var layerParam = {\n          shouldDrawLayer: shouldDrawLayer,\n          layerRenderIndex: layerRenderIndex\n        };\n\n        if (shouldDrawLayer) {\n          layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);\n          layerParam.layerParameters = this.getLayerParameters(layer, layerIndex);\n        }\n\n        drawLayerParams[layerIndex] = layerParam;\n      }\n\n      return drawLayerParams;\n    }\n  }, {\n    key: \"_drawLayersInViewport\",\n    value: function _drawLayersInViewport(gl, _ref2, drawLayerParams) {\n      var layers = _ref2.layers,\n          onError = _ref2.onError,\n          viewport = _ref2.viewport,\n          view = _ref2.view;\n      var glViewport = getGLViewport(gl, {\n        viewport: viewport\n      });\n\n      if (view && view.props.clear) {\n        var clearOpts = view.props.clear === true ? {\n          color: true,\n          depth: true\n        } : view.props.clear;\n        withParameters(gl, {\n          scissorTest: true,\n          scissor: glViewport\n        }, function () {\n          return clear(gl, clearOpts);\n        });\n      }\n\n      var renderStatus = {\n        totalCount: layers.length,\n        visibleCount: 0,\n        compositeCount: 0,\n        pickableCount: 0\n      };\n      setParameters(gl, {\n        viewport: glViewport\n      });\n\n      for (var layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n        var layer = layers[layerIndex];\n        var _drawLayerParams$laye = drawLayerParams[layerIndex],\n            shouldDrawLayer = _drawLayerParams$laye.shouldDrawLayer,\n            layerRenderIndex = _drawLayerParams$laye.layerRenderIndex,\n            moduleParameters = _drawLayerParams$laye.moduleParameters,\n            layerParameters = _drawLayerParams$laye.layerParameters;\n\n        if (shouldDrawLayer && layer.props.pickable) {\n          renderStatus.pickableCount++;\n        }\n\n        if (layer.isComposite) {\n          renderStatus.compositeCount++;\n        } else if (shouldDrawLayer) {\n          renderStatus.visibleCount++;\n          moduleParameters.viewport = viewport;\n\n          try {\n            layer.drawLayer({\n              moduleParameters: moduleParameters,\n              uniforms: {\n                layerIndex: layerRenderIndex\n              },\n              parameters: layerParameters\n            });\n          } catch (err) {\n            if (onError) {\n              onError(err, layer);\n            } else {\n              log.error(\"error during drawing of \".concat(layer), err)();\n            }\n          }\n        }\n      }\n\n      return renderStatus;\n    }\n  }, {\n    key: \"shouldDrawLayer\",\n    value: function shouldDrawLayer(layer) {\n      return true;\n    }\n  }, {\n    key: \"getModuleParameters\",\n    value: function getModuleParameters(layer, effects) {\n      return null;\n    }\n  }, {\n    key: \"getLayerParameters\",\n    value: function getLayerParameters(layer, layerIndex) {\n      return layer.props.parameters;\n    }\n  }, {\n    key: \"_shouldDrawLayer\",\n    value: function _shouldDrawLayer(layer, viewport, pass, layerFilter) {\n      var shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;\n\n      if (shouldDrawLayer && layerFilter) {\n        shouldDrawLayer = layerFilter({\n          layer: layer,\n          viewport: viewport,\n          isPicking: pass.startsWith('picking'),\n          renderPass: pass\n        });\n      }\n\n      if (shouldDrawLayer) {\n        layer.activateViewport(viewport);\n      }\n\n      return shouldDrawLayer;\n    }\n  }, {\n    key: \"_getModuleParameters\",\n    value: function _getModuleParameters(layer, effects, pass, overrides) {\n      var moduleParameters = Object.assign(Object.create(layer.props), {\n        autoWrapLongitude: layer.wrapLongitude,\n        viewport: layer.context.viewport,\n        mousePosition: layer.context.mousePosition,\n        pickingActive: 0,\n        devicePixelRatio: cssToDeviceRatio(this.gl)\n      });\n\n      if (effects) {\n        var _iterator3 = _createForOfIteratorHelper(effects),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var effect = _step3.value;\n            Object.assign(moduleParameters, effect.getModuleParameters(layer));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n    }\n  }]);\n\n  return LayersPass;\n}(Pass);\n\nexport { LayersPass as default };\nexport function layerIndexResolver() {\n  var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var layerIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var resolvers = {};\n\n  var resolveLayerIndex = function resolveLayerIndex(layer, isDrawn) {\n    var indexOverride = layer.props._offset;\n    var layerId = layer.id;\n    var parentId = layer.parent && layer.parent.id;\n    var index;\n\n    if (parentId && !(parentId in layerIndices)) {\n      resolveLayerIndex(layer.parent, false);\n    }\n\n    if (parentId in resolvers) {\n      var resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n\n  return resolveLayerIndex;\n}\n\nfunction getGLViewport(gl, _ref3) {\n  var viewport = _ref3.viewport;\n  var height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;\n  var dimensions = viewport;\n  var pixelRatio = cssToDeviceRatio(gl);\n  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}\n\nfunction clearGLCanvas(gl) {\n  var width = gl.drawingBufferWidth;\n  var height = gl.drawingBufferHeight;\n  setParameters(gl, {\n    viewport: [0, 0, width, height]\n  });\n  gl.clear(16384 | 256);\n}","map":{"version":3,"sources":["../../../src/passes/layers-pass.js"],"names":["LayersPass","Pass","props","gl","setParameters","framebuffer","target","viewports","views","onViewportActive","clearCanvas","clearGLCanvas","renderStats","viewportOrDescriptor","viewport","view","drawLayerParams","subViewports","subViewport","stats","layers","pass","layerFilter","effects","moduleParameters","indexResolver","layerIndexResolver","layerIndex","layer","shouldDrawLayer","layerRenderIndex","layerParam","onError","glViewport","getGLViewport","clearOpts","color","depth","withParameters","scissorTest","scissor","clear","renderStatus","totalCount","visibleCount","compositeCount","pickableCount","layerParameters","uniforms","parameters","log","isPicking","renderPass","overrides","Object","autoWrapLongitude","mousePosition","pickingActive","devicePixelRatio","cssToDeviceRatio","effect","startIndex","layerIndices","resolvers","resolveLayerIndex","indexOverride","layerId","parentId","resolver","index","Number","isDrawn","height","dimensions","pixelRatio","width"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Pass from './pass';\nimport {clear, setParameters, withParameters, cssToDeviceRatio} from '@luma.gl/core';\nimport log from '../utils/log';\n\nexport default class LayersPass extends Pass {\n  render(props) {\n    const gl = this.gl;\n\n    setParameters(gl, {framebuffer: props.target});\n    return this._drawLayers(props);\n  }\n\n  // PRIVATE\n  // Draw a list of layers in a list of viewports\n  _drawLayers(props) {\n    const {viewports, views, onViewportActive, clearCanvas = true} = props;\n\n    const gl = this.gl;\n    if (clearCanvas) {\n      clearGLCanvas(gl);\n    }\n\n    const renderStats = [];\n\n    for (const viewportOrDescriptor of viewports) {\n      // Get a viewport from a viewport descriptor (which can be a plain viewport)\n      const viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;\n      const view = views && views[viewport.id];\n\n      // Update context to point to this viewport\n      onViewportActive(viewport);\n\n      const drawLayerParams = this._getDrawLayerParams(viewport, props);\n\n      props.view = view;\n\n      // render this viewport\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        props.viewport = subViewport;\n\n        const stats = this._drawLayersInViewport(gl, props, drawLayerParams);\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n\n  // Resolve the parameters needed to draw each layer\n  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),\n  // this is only done once for the parent viewport\n  _getDrawLayerParams(\n    viewport,\n    {layers, pass = 'unknown', layerFilter, effects, moduleParameters}\n  ) {\n    const drawLayerParams = [];\n    const indexResolver = layerIndexResolver();\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(layer, viewport, pass, layerFilter);\n\n      // This is the \"logical\" index for ordering this layer in the stack\n      // used to calculate polygon offsets\n      // It can be the same as another layer\n      const layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n\n      const layerParam = {\n        shouldDrawLayer,\n        layerRenderIndex\n      };\n\n      if (shouldDrawLayer) {\n        layerParam.moduleParameters = this._getModuleParameters(\n          layer,\n          effects,\n          pass,\n          moduleParameters\n        );\n        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex);\n      }\n      drawLayerParams[layerIndex] = layerParam;\n    }\n    return drawLayerParams;\n  }\n\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  _drawLayersInViewport(gl, {layers, onError, viewport, view}, drawLayerParams) {\n    const glViewport = getGLViewport(gl, {viewport});\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {color: true, depth: true} : view.props.clear;\n      withParameters(\n        gl,\n        {\n          scissorTest: true,\n          scissor: glViewport\n        },\n        () => clear(gl, clearOpts)\n      );\n    }\n\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n\n    setParameters(gl, {viewport: glViewport});\n\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      const {\n        shouldDrawLayer,\n        layerRenderIndex,\n        moduleParameters,\n        layerParameters\n      } = drawLayerParams[layerIndex];\n\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      } else if (shouldDrawLayer) {\n        // Draw the layer\n        renderStatus.visibleCount++;\n\n        // overwrite layer.context.viewport with the sub viewport\n        moduleParameters.viewport = viewport;\n\n        try {\n          layer.drawLayer({\n            moduleParameters,\n            uniforms: {layerIndex: layerRenderIndex},\n            parameters: layerParameters\n          });\n        } catch (err) {\n          if (onError) {\n            onError(err, layer);\n          } else {\n            log.error(`error during drawing of ${layer}`, err)();\n          }\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  /* Methods for subclass overrides */\n  shouldDrawLayer(layer) {\n    return true;\n  }\n\n  getModuleParameters(layer, effects) {\n    return null;\n  }\n\n  getLayerParameters(layer, layerIndex) {\n    return layer.props.parameters;\n  }\n\n  /* Private */\n  _shouldDrawLayer(layer, viewport, pass, layerFilter) {\n    let shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;\n\n    if (shouldDrawLayer && layerFilter) {\n      shouldDrawLayer = layerFilter({\n        layer,\n        viewport,\n        isPicking: pass.startsWith('picking'),\n        renderPass: pass\n      });\n    }\n    if (shouldDrawLayer) {\n      // If a layer is drawn, update its viewportChanged flag\n      layer.activateViewport(viewport);\n    }\n\n    return shouldDrawLayer;\n  }\n\n  _getModuleParameters(layer, effects, pass, overrides) {\n    const moduleParameters = Object.assign(Object.create(layer.props), {\n      autoWrapLongitude: layer.wrapLongitude,\n      viewport: layer.context.viewport,\n      mousePosition: layer.context.mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(this.gl)\n    });\n\n    if (effects) {\n      for (const effect of effects) {\n        Object.assign(moduleParameters, effect.getModuleParameters(layer));\n      }\n    }\n\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n}\n\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(startIndex = 0, layerIndices = {}) {\n  const resolvers = {};\n\n  const resolveLayerIndex = (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n\n    let index;\n\n    if (parentId && !(parentId in layerIndices)) {\n      // Populate layerIndices with the parent layer's index\n      resolveLayerIndex(layer.parent, false);\n    }\n\n    if (parentId in resolvers) {\n      const resolver = (resolvers[parentId] =\n        resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n  return resolveLayerIndex;\n}\n\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(gl, {viewport}) {\n  // TODO - dummy default for node\n  // Fallback to width/height when clientWidth/clientHeight are 0 or undefined.\n  const height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  const pixelRatio = cssToDeviceRatio(gl);\n  return [\n    dimensions.x * pixelRatio,\n    (height - dimensions.y - dimensions.height) * pixelRatio,\n    dimensions.width * pixelRatio,\n    dimensions.height * pixelRatio\n  ];\n}\n\nfunction clearGLCanvas(gl) {\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  // clear depth and color buffers, restoring transparency\n  setParameters(gl, {viewport: [0, 0, width, height]});\n  gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n}\n"]},"metadata":{},"sourceType":"module"}