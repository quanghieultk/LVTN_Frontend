{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\nimport log from '../utils/log';\nimport { isAsyncIterable } from '../utils/iterable-utils';\nimport { PROP_SYMBOLS } from './constants';\nvar ASYNC_ORIGINAL = PROP_SYMBOLS.ASYNC_ORIGINAL,\n    ASYNC_RESOLVED = PROP_SYMBOLS.ASYNC_RESOLVED,\n    ASYNC_DEFAULTS = PROP_SYMBOLS.ASYNC_DEFAULTS;\nvar EMPTY_PROPS = Object.freeze({});\n\nvar ComponentState = function () {\n  function ComponentState() {\n    var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, ComponentState);\n\n    this.component = component;\n    this.asyncProps = {};\n\n    this.onAsyncPropUpdated = function () {};\n\n    this.oldProps = EMPTY_PROPS;\n    this.oldAsyncProps = null;\n  }\n\n  _createClass(ComponentState, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var propName in this.asyncProps) {\n        var asyncProp = this.asyncProps[propName];\n\n        if (asyncProp.type && asyncProp.type.release) {\n          asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n        }\n      }\n    }\n  }, {\n    key: \"getOldProps\",\n    value: function getOldProps() {\n      return this.oldAsyncProps || this.oldProps;\n    }\n  }, {\n    key: \"resetOldProps\",\n    value: function resetOldProps() {\n      this.oldAsyncProps = null;\n      this.oldProps = this.component.props;\n    }\n  }, {\n    key: \"freezeAsyncOldProps\",\n    value: function freezeAsyncOldProps() {\n      if (!this.oldAsyncProps) {\n        this.oldProps = this.oldProps || this.component.props;\n        this.oldAsyncProps = Object.create(this.oldProps);\n\n        for (var propName in this.asyncProps) {\n          Object.defineProperty(this.oldAsyncProps, propName, {\n            enumerable: true,\n            value: this.oldProps[propName]\n          });\n        }\n      }\n    }\n  }, {\n    key: \"hasAsyncProp\",\n    value: function hasAsyncProp(propName) {\n      return propName in this.asyncProps;\n    }\n  }, {\n    key: \"getAsyncProp\",\n    value: function getAsyncProp(propName) {\n      var asyncProp = this.asyncProps[propName];\n      return asyncProp && asyncProp.resolvedValue;\n    }\n  }, {\n    key: \"isAsyncPropLoading\",\n    value: function isAsyncPropLoading(propName) {\n      if (propName) {\n        var asyncProp = this.asyncProps[propName];\n        return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n      }\n\n      for (var key in this.asyncProps) {\n        if (this.isAsyncPropLoading(key)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reloadAsyncProp\",\n    value: function reloadAsyncProp(propName, value) {\n      this._watchPromise(propName, Promise.resolve(value));\n    }\n  }, {\n    key: \"setAsyncProps\",\n    value: function setAsyncProps(props) {\n      var resolvedValues = props[ASYNC_RESOLVED] || {};\n      var originalValues = props[ASYNC_ORIGINAL] || props;\n      var defaultValues = props[ASYNC_DEFAULTS] || {};\n\n      for (var propName in resolvedValues) {\n        var value = resolvedValues[propName];\n\n        this._createAsyncPropData(propName, defaultValues[propName]);\n\n        this._updateAsyncProp(propName, value);\n\n        resolvedValues[propName] = this.getAsyncProp(propName);\n      }\n\n      for (var _propName in originalValues) {\n        var _value2 = originalValues[_propName];\n\n        this._createAsyncPropData(_propName, defaultValues[_propName]);\n\n        this._updateAsyncProp(_propName, _value2);\n      }\n    }\n  }, {\n    key: \"_updateAsyncProp\",\n    value: function _updateAsyncProp(propName, value) {\n      if (!this._didAsyncInputValueChange(propName, value)) {\n        return;\n      }\n\n      if (typeof value === 'string') {\n        var fetch = this.layer && this.layer.props.fetch;\n        var url = value;\n\n        if (fetch) {\n          value = fetch(url, {\n            propName: propName,\n            layer: this.layer\n          });\n        }\n      }\n\n      if (value instanceof Promise) {\n        this._watchPromise(propName, value);\n\n        return;\n      }\n\n      if (isAsyncIterable(value)) {\n        this._resolveAsyncIterable(propName, value);\n\n        return;\n      }\n\n      this._setPropValue(propName, value);\n    }\n  }, {\n    key: \"_didAsyncInputValueChange\",\n    value: function _didAsyncInputValueChange(propName, value) {\n      var asyncProp = this.asyncProps[propName];\n\n      if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n        return false;\n      }\n\n      asyncProp.lastValue = value;\n      return true;\n    }\n  }, {\n    key: \"_setPropValue\",\n    value: function _setPropValue(propName, value) {\n      var asyncProp = this.asyncProps[propName];\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }, {\n    key: \"_setAsyncPropValue\",\n    value: function _setAsyncPropValue(propName, value, loadCount) {\n      var asyncProp = this.asyncProps[propName];\n\n      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n        this.freezeAsyncOldProps();\n        asyncProp.resolvedValue = value;\n        asyncProp.resolvedLoadCount = loadCount;\n        this.onAsyncPropUpdated(propName, value);\n      }\n    }\n  }, {\n    key: \"_watchPromise\",\n    value: function _watchPromise(propName, promise) {\n      var _this = this;\n\n      var asyncProp = this.asyncProps[propName];\n      asyncProp.pendingLoadCount++;\n      var loadCount = asyncProp.pendingLoadCount;\n      promise.then(function (data) {\n        data = _this._postProcessValue(asyncProp, data);\n\n        _this._setAsyncPropValue(propName, data, loadCount);\n\n        var onDataLoad = _this.layer && _this.layer.props.onDataLoad;\n\n        if (propName === 'data' && onDataLoad) {\n          onDataLoad(data, {\n            propName: propName,\n            layer: _this.layer\n          });\n        }\n      })[\"catch\"](function (error) {\n        return log.error(error)();\n      });\n    }\n  }, {\n    key: \"_resolveAsyncIterable\",\n    value: function () {\n      var _resolveAsyncIterable2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(propName, iterable) {\n        var asyncProp, loadCount, data, count, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, _ref, dataTransform, onDataLoad;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (propName !== 'data') {\n                  this._setPropValue(propName, iterable);\n                }\n\n                asyncProp = this.asyncProps[propName];\n                asyncProp.pendingLoadCount++;\n                loadCount = asyncProp.pendingLoadCount;\n                data = [];\n                count = 0;\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 8;\n                _iterator = _asyncIterator(iterable);\n\n              case 10:\n                _context.next = 12;\n                return _iterator.next();\n\n              case 12:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 16;\n                return _step.value;\n\n              case 16:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 27;\n                  break;\n                }\n\n                chunk = _value;\n                _ref = this.component ? this.component.props : {}, dataTransform = _ref.dataTransform;\n\n                if (dataTransform) {\n                  data = dataTransform(chunk, data);\n                } else {\n                  data = data.concat(chunk);\n                }\n\n                Object.defineProperty(data, '__diff', {\n                  enumerable: false,\n                  value: [{\n                    startRow: count,\n                    endRow: data.length\n                  }]\n                });\n                count = data.length;\n\n                this._setAsyncPropValue(propName, data, loadCount);\n\n              case 24:\n                _iteratorNormalCompletion = true;\n                _context.next = 10;\n                break;\n\n              case 27:\n                _context.next = 33;\n                break;\n\n              case 29:\n                _context.prev = 29;\n                _context.t0 = _context[\"catch\"](8);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 33:\n                _context.prev = 33;\n                _context.prev = 34;\n\n                if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n                  _context.next = 38;\n                  break;\n                }\n\n                _context.next = 38;\n                return _iterator[\"return\"]();\n\n              case 38:\n                _context.prev = 38;\n\n                if (!_didIteratorError) {\n                  _context.next = 41;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 41:\n                return _context.finish(38);\n\n              case 42:\n                return _context.finish(33);\n\n              case 43:\n                onDataLoad = this.layer && this.layer.props.onDataLoad;\n\n                if (onDataLoad) {\n                  onDataLoad(data, {\n                    propName: propName,\n                    layer: this.layer\n                  });\n                }\n\n              case 45:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[8, 29, 33, 43], [34,, 38, 42]]);\n      }));\n\n      function _resolveAsyncIterable(_x, _x2) {\n        return _resolveAsyncIterable2.apply(this, arguments);\n      }\n\n      return _resolveAsyncIterable;\n    }()\n  }, {\n    key: \"_postProcessValue\",\n    value: function _postProcessValue(asyncProp, value) {\n      var propType = asyncProp.type;\n\n      if (propType) {\n        if (propType.release) {\n          propType.release(asyncProp.resolvedValue, propType, this.component);\n        }\n\n        if (propType.transform) {\n          return propType.transform(value, propType, this.component);\n        }\n      }\n\n      return value;\n    }\n  }, {\n    key: \"_createAsyncPropData\",\n    value: function _createAsyncPropData(propName, defaultValue) {\n      var asyncProp = this.asyncProps[propName];\n\n      if (!asyncProp) {\n        var propTypes = this.component && this.component.constructor._propTypes;\n        this.asyncProps[propName] = {\n          type: propTypes && propTypes[propName],\n          lastValue: null,\n          resolvedValue: defaultValue,\n          pendingLoadCount: 0,\n          resolvedLoadCount: 0\n        };\n      }\n    }\n  }]);\n\n  return ComponentState;\n}();\n\nexport { ComponentState as default };","map":{"version":3,"sources":["../../../src/lifecycle/component-state.js"],"names":["ASYNC_ORIGINAL","ASYNC_RESOLVED","ASYNC_DEFAULTS","PROP_SYMBOLS","EMPTY_PROPS","Object","ComponentState","component","asyncProp","enumerable","value","propName","Boolean","Promise","props","resolvedValues","originalValues","defaultValues","fetch","url","layer","isAsyncIterable","loadCount","promise","data","onDataLoad","log","iterable","pendingLoadCount","count","chunk","dataTransform","startRow","endRow","length","propType","defaultValue","propTypes","type","lastValue","resolvedValue","resolvedLoadCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport {isAsyncIterable} from '../utils/iterable-utils';\nimport {PROP_SYMBOLS} from './constants';\nconst {ASYNC_ORIGINAL, ASYNC_RESOLVED, ASYNC_DEFAULTS} = PROP_SYMBOLS;\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport default class ComponentState {\n  constructor(component = null) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = EMPTY_PROPS; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n      if (asyncProp.type && asyncProp.type.release) {\n        // Release any resources created by transforms\n        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n      }\n    }\n  }\n\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  freezeAsyncOldProps() {\n    if (!this.oldAsyncProps) {\n      // Make sure oldProps is set\n      this.oldProps = this.oldProps || this.component.props;\n\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  // ASYNC PROP HANDLING\n  //\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName) {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(\n        asyncProp &&\n          asyncProp.pendingLoadCount > 0 &&\n          asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n      );\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName, value) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props) {\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED] || {};\n    const originalValues = props[ASYNC_ORIGINAL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS] || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n      // Use transformed value\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      const fetch = this.layer && this.layer.props.fetch;\n      const url = value;\n      if (fetch) {\n        value = fetch(url, {propName, layer: this.layer});\n      }\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value);\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  _didAsyncInputValueChange(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  _setPropValue(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n    value = this._postProcessValue(asyncProp, value);\n    asyncProp.resolvedValue = value;\n    asyncProp.pendingLoadCount++;\n    asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  _setAsyncPropValue(propName, value, loadCount) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // A chance to copy old props before updating\n      this.freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    promise\n      .then(data => {\n        data = this._postProcessValue(asyncProp, data);\n        this._setAsyncPropValue(propName, data, loadCount);\n\n        const onDataLoad = this.layer && this.layer.props.onDataLoad;\n        if (propName === 'data' && onDataLoad) {\n          onDataLoad(data, {propName, layer: this.layer});\n        }\n      })\n      .catch(error => log.error(error)());\n  }\n\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n    }\n\n    const asyncProp = this.asyncProps[propName];\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      const {dataTransform} = this.component ? this.component.props : {};\n      if (dataTransform) {\n        data = dataTransform(chunk, data);\n      } else {\n        data = data.concat(chunk);\n      }\n\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{startRow: count, endRow: data.length}]\n      });\n\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    const onDataLoad = this.layer && this.layer.props.onDataLoad;\n    if (onDataLoad) {\n      onDataLoad(data, {propName, layer: this.layer});\n    }\n  }\n\n  // Give the app a chance to post process the loaded data\n  _postProcessValue(asyncProp, value) {\n    const propType = asyncProp.type;\n    if (propType) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n    return value;\n  }\n\n  // Creating an asyncProp record if needed\n  _createAsyncPropData(propName, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      const propTypes = this.component && this.component.constructor._propTypes;\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null, // Supplied prop value (can be url/promise, not visible to layer)\n        resolvedValue: defaultValue, // Resolved prop value (valid data, can be \"shown\" to layer)\n        pendingLoadCount: 0, // How many loads have been issued\n        resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n      };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}