{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { Matrix4 } from 'math.gl';\nimport { MVTLoader } from '@loaders.gl/mvt';\nimport { binaryToGeoJson } from '@loaders.gl/gis';\nimport { load } from '@loaders.gl/core';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { _binaryToFeature, _findIndexBinary } from '@deck.gl/layers';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { getURLFromTemplate, isURLTemplate } from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\nimport { transform } from './coordinate-transform';\nvar WORLD_SIZE = 512;\nvar defaultProps = {\n  uniqueIdProperty: {\n    type: 'string',\n    value: ''\n  },\n  highlightedFeatureId: null,\n  loaders: [MVTLoader],\n  binary: false\n};\n\nfunction fetchTileJSON(_x) {\n  return _fetchTileJSON.apply(this, arguments);\n}\n\nfunction _fetchTileJSON() {\n  _fetchTileJSON = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(url) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return load(url);\n\n          case 3:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 6:\n            _context2.prev = 6;\n            _context2.t0 = _context2[\"catch\"](0);\n            throw new Error(\"An error occurred fetching TileJSON: \".concat(_context2.t0));\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 6]]);\n  }));\n  return _fetchTileJSON.apply(this, arguments);\n}\n\nvar MVTLayer = function (_TileLayer) {\n  _inherits(MVTLayer, _TileLayer);\n\n  var _super = _createSuper(MVTLayer);\n\n  function MVTLayer() {\n    _classCallCheck(this, MVTLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MVTLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      _get(_getPrototypeOf(MVTLayer.prototype), \"initializeState\", this).call(this);\n\n      this.setState({\n        data: null,\n        tileJSON: null\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          context = _ref.context,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.dataChanged) {\n        this._updateTileData({\n          props: props\n        });\n      }\n\n      if (this.state.data) {\n        _get(_getPrototypeOf(MVTLayer.prototype), \"updateState\", this).call(this, {\n          props: props,\n          oldProps: oldProps,\n          context: context,\n          changeFlags: changeFlags\n        });\n\n        this._setWGS84PropertyForTiles();\n      }\n    }\n  }, {\n    key: \"_updateTileData\",\n    value: function () {\n      var _updateTileData2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(_ref2) {\n        var props, onDataLoad, data, tileJSON, minZoom, maxZoom;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                props = _ref2.props;\n                onDataLoad = this.props.onDataLoad;\n                data = props.data;\n                tileJSON = null;\n                minZoom = props.minZoom, maxZoom = props.maxZoom;\n\n                if (!(typeof data === 'string' && !isURLTemplate(data))) {\n                  _context.next = 13;\n                  break;\n                }\n\n                this.setState({\n                  data: null,\n                  tileJSON: null\n                });\n                _context.next = 9;\n                return fetchTileJSON(data);\n\n              case 9:\n                tileJSON = _context.sent;\n\n                if (onDataLoad) {\n                  onDataLoad(tileJSON);\n                }\n\n                _context.next = 14;\n                break;\n\n              case 13:\n                if (data.tilejson) {\n                  tileJSON = data;\n                }\n\n              case 14:\n                if (tileJSON) {\n                  data = tileJSON.tiles;\n\n                  if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {\n                    minZoom = tileJSON.minzoom;\n                  }\n\n                  if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {\n                    maxZoom = tileJSON.maxzoom;\n                  }\n                }\n\n                this.setState({\n                  data: data,\n                  tileJSON: tileJSON,\n                  minZoom: minZoom,\n                  maxZoom: maxZoom\n                });\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _updateTileData(_x2) {\n        return _updateTileData2.apply(this, arguments);\n      }\n\n      return _updateTileData;\n    }()\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.data) return null;\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"renderLayers\", this).call(this);\n    }\n  }, {\n    key: \"getTileData\",\n    value: function getTileData(tile) {\n      var url = getURLFromTemplate(this.state.data, tile);\n\n      if (!url) {\n        return Promise.reject('Invalid URL');\n      }\n\n      var options = this.getLoadOptions();\n      options = _objectSpread(_objectSpread({}, options), {}, {\n        mvt: _objectSpread(_objectSpread({}, options && options.mvt), {}, {\n          coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n          tileIndex: {\n            x: tile.x,\n            y: tile.y,\n            z: tile.z\n          }\n        }),\n        gis: this.props.binary ? {\n          format: 'binary'\n        } : {}\n      });\n      return load(url, this.props.loaders[0], options);\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      var tile = props.tile;\n      var worldScale = Math.pow(2, tile.z);\n      var xScale = WORLD_SIZE / worldScale;\n      var yScale = -xScale;\n      var xOffset = WORLD_SIZE * tile.x / worldScale;\n      var yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n      var modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n      props.autoHighlight = false;\n\n      if (!this.context.viewport.resolution) {\n        props.modelMatrix = modelMatrix;\n        props.coordinateOrigin = [xOffset, yOffset, 0];\n        props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n        props.extensions = [].concat(_toConsumableArray(props.extensions || []), [new ClipExtension()]);\n      }\n\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"renderSubLayers\", this).call(this, props);\n    }\n  }, {\n    key: \"onHover\",\n    value: function onHover(info, pickingEvent) {\n      var _this$props = this.props,\n          uniqueIdProperty = _this$props.uniqueIdProperty,\n          autoHighlight = _this$props.autoHighlight;\n\n      if (autoHighlight) {\n        var hoveredFeatureId = this.state.hoveredFeatureId;\n        var hoveredFeature = info.object;\n        var newHoveredFeatureId;\n\n        if (hoveredFeature) {\n          newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n        }\n\n        if (hoveredFeatureId !== newHoveredFeatureId && newHoveredFeatureId !== -1) {\n          this.setState({\n            hoveredFeatureId: newHoveredFeatureId\n          });\n        }\n      }\n\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"onHover\", this).call(this, info, pickingEvent);\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(params) {\n      var info = _get(_getPrototypeOf(MVTLayer.prototype), \"getPickingInfo\", this).call(this, params);\n\n      var isWGS84 = this.context.viewport.resolution;\n\n      if (info.object && !isWGS84) {\n        info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);\n      } else if (this.props.binary && info.index !== -1) {\n        var data = params.sourceLayer.props.data;\n        info.object = _binaryToFeature(data.points, info.index) || _binaryToFeature(data.lines, info.index) || _binaryToFeature(data.polygons, info.index);\n      }\n\n      return info;\n    }\n  }, {\n    key: \"getHighlightedObjectIndex\",\n    value: function getHighlightedObjectIndex(tile) {\n      var hoveredFeatureId = this.state.hoveredFeatureId;\n      var _this$props2 = this.props,\n          uniqueIdProperty = _this$props2.uniqueIdProperty,\n          highlightedFeatureId = _this$props2.highlightedFeatureId,\n          binary = _this$props2.binary;\n      var data = tile.data;\n      var isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n\n      if (!isFeatureIdPresent) {\n        return -1;\n      }\n\n      var featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId) ? highlightedFeatureId : hoveredFeatureId;\n\n      if (Array.isArray(data)) {\n        return data.findIndex(function (feature) {\n          return getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        });\n      } else if (data && binary) {\n        var featureIdIndex = _findIndexBinary(data, uniqueIdProperty, featureIdToHighlight);\n\n        var geometries = ['points', 'lines', 'polygons'];\n\n        for (var _i = 0, _geometries = geometries; _i < _geometries.length; _i++) {\n          var geometry = _geometries[_i];\n          var index = data[geometry] && data[geometry].featureIds.value[featureIdIndex];\n          if (index !== undefined) return index;\n        }\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"_pickObjects\",\n    value: function _pickObjects(maxObjects) {\n      var _this$context = this.context,\n          deck = _this$context.deck,\n          viewport = _this$context.viewport;\n      var width = viewport.width;\n      var height = viewport.height;\n      var x = viewport.x;\n      var y = viewport.y;\n      var layerIds = [this.id];\n      return deck.pickObjects({\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        layerIds: layerIds,\n        maxObjects: maxObjects\n      });\n    }\n  }, {\n    key: \"getRenderedFeatures\",\n    value: function getRenderedFeatures() {\n      var maxFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var features = this._pickObjects(maxFeatures);\n\n      var featureCache = new Set();\n      var renderedFeatures = [];\n\n      var _iterator = _createForOfIteratorHelper(features),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var f = _step.value;\n          var featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n          if (featureId === -1) {\n            renderedFeatures.push(f.object);\n          } else if (!featureCache.has(featureId)) {\n            featureCache.add(featureId);\n            renderedFeatures.push(f.object);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return renderedFeatures;\n    }\n  }, {\n    key: \"_setWGS84PropertyForTiles\",\n    value: function _setWGS84PropertyForTiles() {\n      var _this = this;\n\n      var propName = 'dataInWGS84';\n      var tileset = this.state.tileset;\n      tileset.selectedTiles.forEach(function (tile) {\n        if (!tile.hasOwnProperty(propName)) {\n          Object.defineProperty(tile, propName, {\n            get: function get() {\n              if (!tile.content) {\n                return null;\n              }\n\n              if (_this.props.binary && Array.isArray(tile.content) && !tile.content.length) {\n                return [];\n              }\n\n              if (tile._contentWGS84 === undefined) {\n                var content = _this.props.binary ? binaryToGeoJson(tile.content) : tile.content;\n                tile._contentWGS84 = content.map(function (feature) {\n                  return transformTileCoordsToWGS84(feature, tile.bbox, _this.context.viewport);\n                });\n              }\n\n              return tile._contentWGS84;\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this.state.data && this.state.tileset && _get(_getPrototypeOf(MVTLayer.prototype), \"isLoaded\", this);\n    }\n  }]);\n\n  return MVTLayer;\n}(TileLayer);\n\nexport { MVTLayer as default };\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return -1;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  var feature = _objectSpread(_objectSpread({}, object), {}, {\n    geometry: {\n      type: object.geometry.type\n    }\n  });\n\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: function get() {\n      var wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n  return feature;\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/mvt-layer/mvt-layer.js"],"names":["WORLD_SIZE","defaultProps","uniqueIdProperty","type","value","highlightedFeatureId","loaders","binary","fetchTileJSON","load","MVTLayer","TileLayer","data","tileJSON","props","oldProps","context","changeFlags","onDataLoad","minZoom","maxZoom","isURLTemplate","Number","tile","url","getURLFromTemplate","Promise","options","mvt","coordinates","tileIndex","x","y","z","gis","format","worldScale","Math","xScale","yScale","xOffset","yOffset","modelMatrix","COORDINATE_SYSTEM","info","pickingEvent","autoHighlight","hoveredFeatureId","hoveredFeature","newHoveredFeatureId","getFeatureUniqueId","params","isWGS84","transformTileCoordsToWGS84","_binaryToFeature","isFeatureIdPresent","isFeatureIdDefined","featureIdToHighlight","Array","featureIdIndex","_findIndexBinary","geometries","geometry","index","maxObjects","deck","viewport","width","height","layerIds","maxFeatures","features","featureCache","renderedFeatures","f","featureId","propName","tileset","Object","get","content","binaryToGeoJson","feature","object","wgs84Geom","transform"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,OAAA,QAAA,SAAA;AACA,SAAA,SAAA,QAAA,iBAAA;AACA,SAAA,eAAA,QAAA,iBAAA;AACA,SAAA,IAAA,QAAA,kBAAA;AACA,SAAA,iBAAA,QAAA,eAAA;AACA,SAAA,gBAAA,EAAA,gBAAA,QAAA,iBAAA;AAEA,OAAA,SAAA,MAAA,0BAAA;AACA,SAAA,kBAAA,EAAA,aAAA,QAAA,qBAAA;AACA,OAAA,aAAA,MAAA,kBAAA;AACA,SAAA,SAAA,QAAA,wBAAA;AAEA,IAAMA,UAAU,GAAhB,GAAA;AAEA,IAAMC,YAAY,GAAG;AACnBC,EAAAA,gBAAgB,EAAE;AAACC,IAAAA,IAAI,EAAL,QAAA;AAAiBC,IAAAA,KAAK,EAAE;AAAxB,GADC;AAEnBC,EAAAA,oBAAoB,EAFD,IAAA;AAGnBC,EAAAA,OAAO,EAAE,CAHU,SAGV,CAHU;AAInBC,EAAAA,MAAM,EAAE;AAJW,CAArB;;SAOeC,a;;;;;8DAAf,SAAA,QAAA,CAAA,GAAA,EAAA;AAAA,WAAA,mBAAA,CAAA,IAAA,CAAA,SAAA,SAAA,CAAA,SAAA,EAAA;AAAA,aAAA,CAAA,EAAA;AAAA,gBAAA,SAAA,CAAA,IAAA,GAAA,SAAA,CAAA,IAAA;AAAA,eAAA,CAAA;AAAA,YAAA,SAAA,CAAA,IAAA,GAAA,CAAA;AAAA,YAAA,SAAA,CAAA,IAAA,GAAA,CAAA;AAAA,mBAEiBC,IAAI,CAFrB,GAEqB,CAFrB;;AAAA,eAAA,CAAA;AAAA,mBAAA,SAAA,CAAA,MAAA,CAAA,QAAA,EAAA,SAAA,CAAA,IAAA,CAAA;;AAAA,eAAA,CAAA;AAAA,YAAA,SAAA,CAAA,IAAA,GAAA,CAAA;AAAA,YAAA,SAAA,CAAA,EAAA,GAAA,SAAA,CAAA,OAAA,CAAA,CAAA,CAAA,CAAA;AAAA,kBAIU,IAAA,KAAA,CAAA,wCAAA,MAAA,CAAA,SAAA,CAJV,EAIU,CAAA,CAJV;;AAAA,eAAA,CAAA;AAAA,eAAA,KAAA;AAAA,mBAAA,SAAA,CAAA,IAAA,EAAA;AAAA;AAAA;AAAA,KAAA,EAAA,QAAA,EAAA,IAAA,EAAA,CAAA,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,CAAA;;;;;IAQqBC,Q;;;;;;;;;;;;;sCACD;AAChB,MAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,iBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA;;AACA,WAAA,QAAA,CAAc;AACZE,QAAAA,IAAI,EADQ,IAAA;AAEZC,QAAAA,QAAQ,EAAE;AAFE,OAAd;AAID;;;sCAMoD;AAAA,UAAxCC,KAAwC,GAAA,IAAA,CAAxCA,KAAwC;AAAA,UAAjCC,QAAiC,GAAA,IAAA,CAAjCA,QAAiC;AAAA,UAAvBC,OAAuB,GAAA,IAAA,CAAvBA,OAAuB;AAAA,UAAdC,WAAc,GAAA,IAAA,CAAdA,WAAc;;AACnD,UAAIA,WAAW,CAAf,WAAA,EAA6B;AAC3B,aAAA,eAAA,CAAqB;AAACH,UAAAA,KAAK,EAALA;AAAD,SAArB;AACD;;AAED,UAAI,KAAA,KAAA,CAAJ,IAAA,EAAqB;AACnB,QAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,aAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAkB;AAACA,UAAAA,KAAK,EAAN,KAAA;AAAQC,UAAAA,QAAQ,EAAhB,QAAA;AAAkBC,UAAAA,OAAO,EAAzB,OAAA;AAA2BC,UAAAA,WAAW,EAAXA;AAA3B,SAAlB;;AACA,aAAA,yBAAA;AACD;AACF;;;;;;;;;;AAEsBH,gBAAAA,K,SAAAA,KAAAA;AACdI,gBAAAA,U,GAAc,KAAKJ,KAAL,CAAdI,UAAAA;AACFN,gBAAAA,I,GAAQE,K,CAARF,IAAAA;AACDC,gBAAAA,Q,GAAW,IAAXA;AACCM,gBAAAA,O,GAAoBL,K,CAApBK,OAAAA,EAASC,O,GAAWN,K,CAAXM,OAATD;;sBAED,OAAA,IAAA,KAAA,QAAA,IAA4B,CAACE,aAAa,CAAA,IAAA,C;;;;;AAC5C,qBAAA,QAAA,CAAc;AAACT,kBAAAA,IAAI,EAAL,IAAA;AAAaC,kBAAAA,QAAQ,EAAE;AAAvB,iBAAd;;uBACiBL,aAAa,CAAA,IAAA,C;;;AAA9BK,gBAAAA,Q,gBAAAA;;AAEA,oBAAA,UAAA,EAAgB;AACdK,kBAAAA,UAAU,CAAVA,QAAU,CAAVA;AACD;;;;;;AACI,oBAAIN,IAAI,CAAR,QAAA,EAAmB;AACxBC,kBAAAA,QAAQ,GAARA,IAAAA;AACD;;;AAED,oBAAA,QAAA,EAAc;AACZD,kBAAAA,IAAI,GAAGC,QAAQ,CAAfD,KAAAA;;AAEA,sBAAIU,MAAM,CAANA,QAAAA,CAAgBT,QAAQ,CAAxBS,OAAAA,KAAqCT,QAAQ,CAARA,OAAAA,GAAzC,OAAA,EAAqE;AACnEM,oBAAAA,OAAO,GAAGN,QAAQ,CAAlBM,OAAAA;AACD;;AAED,sBACEG,MAAM,CAANA,QAAAA,CAAgBT,QAAQ,CAAxBS,OAAAA,MACC,CAACA,MAAM,CAANA,QAAAA,CAAD,OAACA,CAAD,IAA6BT,QAAQ,CAARA,OAAAA,GAFhC,OACES,CADF,EAGE;AACAF,oBAAAA,OAAO,GAAGP,QAAQ,CAAlBO,OAAAA;AACD;AACF;;AAED,qBAAA,QAAA,CAAc;AAACR,kBAAAA,IAAI,EAAL,IAAA;AAAOC,kBAAAA,QAAQ,EAAf,QAAA;AAAiBM,kBAAAA,OAAO,EAAxB,OAAA;AAA0BC,kBAAAA,OAAO,EAAPA;AAA1B,iBAAd;;;;;;;;;;;;;;;;;;mCAGa;AACb,UAAI,CAAC,KAAA,KAAA,CAAL,IAAA,EAAsB,OAAA,IAAA;AACtB,aAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,cAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AACD;;;gCAEWG,I,EAAM;AAChB,UAAMC,GAAG,GAAGC,kBAAkB,CAAC,KAAA,KAAA,CAAD,IAAA,EAA9B,IAA8B,CAA9B;;AACA,UAAI,CAAJ,GAAA,EAAU;AACR,eAAOC,OAAO,CAAPA,MAAAA,CAAP,aAAOA,CAAP;AACD;;AACD,UAAIC,OAAO,GAAG,KAAd,cAAc,EAAd;AACAA,MAAAA,OAAO,GAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,OAAA,CAAA,EAAA,EAAA,EAAA;AAELC,QAAAA,GAAG,EAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EACGD,OAAO,IAAIA,OAAO,CADrB,GAAA,CAAA,EAAA,EAAA,EAAA;AAEDE,UAAAA,WAAW,EAAE,KAAA,OAAA,CAAA,QAAA,CAAA,UAAA,GAAA,OAAA,GAFZ,OAAA;AAGDC,UAAAA,SAAS,EAAE;AAACC,YAAAA,CAAC,EAAER,IAAI,CAAR,CAAA;AAAYS,YAAAA,CAAC,EAAET,IAAI,CAAnB,CAAA;AAAuBU,YAAAA,CAAC,EAAEV,IAAI,CAACU;AAA/B;AAHV,SAAA,CAFE;AAWLC,QAAAA,GAAG,EAAE,KAAA,KAAA,CAAA,MAAA,GAAoB;AAACC,UAAAA,MAAM,EAAE;AAAT,SAApB,GAAyC;AAXzC,OAAA,CAAPR;AAaA,aAAOlB,IAAI,CAAA,GAAA,EAAM,KAAA,KAAA,CAAA,OAAA,CAAN,CAAM,CAAN,EAAX,OAAW,CAAX;AACD;;;oCAEeK,K,EAAO;AAAA,UACdS,IADc,GACNT,KADM,CAAA,IAAA;AAErB,UAAMsB,UAAU,GAAGC,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYd,IAAI,CAAnC,CAAmBc,CAAnB;AAEA,UAAMC,MAAM,GAAGtC,UAAU,GAAzB,UAAA;AACA,UAAMuC,MAAM,GAAG,CAAf,MAAA;AAEA,UAAMC,OAAO,GAAIxC,UAAU,GAAGuB,IAAI,CAAlB,CAACvB,GAAjB,UAAA;AACA,UAAMyC,OAAO,GAAGzC,UAAU,IAAI,IAAIuB,IAAI,CAAJA,CAAAA,GAAlC,UAA0B,CAA1B;AAEA,UAAMmB,WAAW,GAAG,IAAA,OAAA,GAAA,KAAA,CAAoB,CAAA,MAAA,EAAA,MAAA,EAAxC,CAAwC,CAApB,CAApB;AAEA5B,MAAAA,KAAK,CAALA,aAAAA,GAAAA,KAAAA;;AAEA,UAAI,CAAC,KAAA,OAAA,CAAA,QAAA,CAAL,UAAA,EAAuC;AACrCA,QAAAA,KAAK,CAALA,WAAAA,GAAAA,WAAAA;AACAA,QAAAA,KAAK,CAALA,gBAAAA,GAAyB,CAAA,OAAA,EAAA,OAAA,EAAzBA,CAAyB,CAAzBA;AACAA,QAAAA,KAAK,CAALA,gBAAAA,GAAyB6B,iBAAiB,CAA1C7B,SAAAA;AACAA,QAAAA,KAAK,CAALA,UAAAA,GAAAA,GAAAA,MAAAA,CAAAA,kBAAAA,CAAwBA,KAAK,CAALA,UAAAA,IAAxBA,EAAAA,CAAAA,EAAAA,CAAiD,IAAjDA,aAAiD,EAAjDA,CAAAA,CAAAA;AACD;;AAED,aAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,iBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,KAAA,CAAA;AACD;;;4BAEO8B,I,EAAMC,Y,EAAc;AAAA,UAAA,WAAA,GACgB,KADhB,KAAA;AAAA,UACnB3C,gBADmB,GAAA,WAAA,CAAA,gBAAA;AAAA,UACD4C,aADC,GAAA,WAAA,CAAA,aAAA;;AAG1B,UAAA,aAAA,EAAmB;AAAA,YACVC,gBADU,GACU,KADV,KACU,CADV,gBAAA;AAEjB,YAAMC,cAAc,GAAGJ,IAAI,CAA3B,MAAA;AACA,YAAA,mBAAA;;AAEA,YAAA,cAAA,EAAoB;AAClBK,UAAAA,mBAAmB,GAAGC,kBAAkB,CAAA,cAAA,EAAxCD,gBAAwC,CAAxCA;AACD;;AAED,YAAIF,gBAAgB,KAAhBA,mBAAAA,IAA4CE,mBAAmB,KAAK,CAAxE,CAAA,EAA4E;AAC1E,eAAA,QAAA,CAAc;AAACF,YAAAA,gBAAgB,EAAEE;AAAnB,WAAd;AACD;AACF;;AAED,aAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,SAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,IAAA,EAAA,YAAA,CAAA;AACD;;;mCAEcE,M,EAAQ;AACrB,UAAMP,IAAI,GAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,gBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAV,MAAU,CAAV;;AAEA,UAAMQ,OAAO,GAAG,KAAA,OAAA,CAAA,QAAA,CAAhB,UAAA;;AAEA,UAAIR,IAAI,CAAJA,MAAAA,IAAe,CAAnB,OAAA,EAA6B;AAC3BA,QAAAA,IAAI,CAAJA,MAAAA,GAAcS,0BAA0B,CAACT,IAAI,CAAL,MAAA,EAAcA,IAAI,CAAJA,IAAAA,CAAd,IAAA,EAA8B,KAAA,OAAA,CAAtEA,QAAwC,CAAxCA;AADF,OAAA,MAEO,IAAI,KAAA,KAAA,CAAA,MAAA,IAAqBA,IAAI,CAAJA,KAAAA,KAAe,CAAxC,CAAA,EAA4C;AAAA,YAE1ChC,IAF0C,GAElCuC,MAAM,CAANA,WAAAA,CAFkC,KAElCA,CAFkC,IAAA;AAGjDP,QAAAA,IAAI,CAAJA,MAAAA,GACEU,gBAAgB,CAAC1C,IAAI,CAAL,MAAA,EAAcgC,IAAI,CAAlCU,KAAgB,CAAhBA,IACAA,gBAAgB,CAAC1C,IAAI,CAAL,KAAA,EAAagC,IAAI,CADjCU,KACgB,CADhBA,IAEAA,gBAAgB,CAAC1C,IAAI,CAAL,QAAA,EAAgBgC,IAAI,CAHtCA,KAGkB,CAHlBA;AAID;;AAED,aAAA,IAAA;AACD;;;8CAEyBrB,I,EAAM;AAAA,UACvBwB,gBADuB,GACH,KADG,KACH,CADG,gBAAA;AAAA,UAAA,YAAA,GAE2B,KAF3B,KAAA;AAAA,UAEvB7C,gBAFuB,GAAA,YAAA,CAAA,gBAAA;AAAA,UAELG,oBAFK,GAAA,YAAA,CAAA,oBAAA;AAAA,UAEiBE,MAFjB,GAAA,YAAA,CAAA,MAAA;AAAA,UAGvBK,IAHuB,GAGfW,IAHe,CAAA,IAAA;AAK9B,UAAMgC,kBAAkB,GACtBC,kBAAkB,CAAlBA,gBAAkB,CAAlBA,IAAwCA,kBAAkB,CAD5D,oBAC4D,CAD5D;;AAGA,UAAI,CAAJ,kBAAA,EAAyB;AACvB,eAAO,CAAP,CAAA;AACD;;AAED,UAAMC,oBAAoB,GAAGD,kBAAkB,CAAlBA,oBAAkB,CAAlBA,GAAAA,oBAAAA,GAA7B,gBAAA;;AAKA,UAAIE,KAAK,CAALA,OAAAA,CAAJ,IAAIA,CAAJ,EAAyB;AACvB,eAAO,IAAI,CAAJ,SAAA,CACL,UAAA,OAAA,EAAO;AAAA,iBAAIR,kBAAkB,CAAA,OAAA,EAAlBA,gBAAkB,CAAlBA,KAAJ,oBAAA;AADT,SAAO,CAAP;AADF,OAAA,MAMO,IAAItC,IAAI,IAAR,MAAA,EAAoB;AAEzB,YAAM+C,cAAc,GAAGC,gBAAgB,CAAA,IAAA,EAAA,gBAAA,EAAvC,oBAAuC,CAAvC;;AAEA,YAAMC,UAAU,GAAG,CAAA,QAAA,EAAA,OAAA,EAAnB,UAAmB,CAAnB;;AACA,aAAA,IAAA,EAAA,GAAA,CAAA,EAAA,WAAA,GAAA,UAAA,EAAA,EAAA,GAAA,WAAA,CAAA,MAAA,EAAA,EAAA,EAAA,EAAmC;AAA9B,cAAMC,QAAQ,GAAA,WAAA,CAAd,EAAc,CAAd;AACH,cAAMC,KAAK,GAAGnD,IAAI,CAAJA,QAAI,CAAJA,IAAkBA,IAAI,CAAJA,QAAI,CAAJA,CAAAA,UAAAA,CAAAA,KAAAA,CAAhC,cAAgCA,CAAhC;AACA,cAAImD,KAAK,KAAT,SAAA,EAAyB,OAAA,KAAA;AAC1B;AACF;;AAED,aAAO,CAAP,CAAA;AACD;;;iCAEYC,U,EAAY;AAAA,UAAA,aAAA,GACE,KADF,OAAA;AAAA,UAChBC,IADgB,GAAA,aAAA,CAAA,IAAA;AAAA,UACVC,QADU,GAAA,aAAA,CAAA,QAAA;AAEvB,UAAMC,KAAK,GAAGD,QAAQ,CAAtB,KAAA;AACA,UAAME,MAAM,GAAGF,QAAQ,CAAvB,MAAA;AACA,UAAMnC,CAAC,GAAGmC,QAAQ,CAAlB,CAAA;AACA,UAAMlC,CAAC,GAAGkC,QAAQ,CAAlB,CAAA;AACA,UAAMG,QAAQ,GAAG,CAAC,KAAlB,EAAiB,CAAjB;AACA,aAAO,IAAI,CAAJ,WAAA,CAAiB;AAACtC,QAAAA,CAAC,EAAF,CAAA;AAAIC,QAAAA,CAAC,EAAL,CAAA;AAAOmC,QAAAA,KAAK,EAAZ,KAAA;AAAcC,QAAAA,MAAM,EAApB,MAAA;AAAsBC,QAAAA,QAAQ,EAA9B,QAAA;AAAgCL,QAAAA,UAAU,EAAVA;AAAhC,OAAjB,CAAP;AACD;;;0CAEuC;AAAA,UAApBM,WAAoB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAN,IAAM;;AACtC,UAAMC,QAAQ,GAAG,KAAA,YAAA,CAAjB,WAAiB,CAAjB;;AACA,UAAMC,YAAY,GAAG,IAArB,GAAqB,EAArB;AACA,UAAMC,gBAAgB,GAAtB,EAAA;;AAHsC,UAAA,SAAA,GAAA,0BAAA,CAAA,QAAA,CAAA;AAAA,UAAA,KAAA;;AAAA,UAAA;AAKtC,aAAA,SAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAA0B;AAAA,cAAfC,CAAe,GAAA,KAAA,CAAA,KAAA;AACxB,cAAMC,SAAS,GAAGzB,kBAAkB,CAACwB,CAAC,CAAF,MAAA,EAAW,KAAA,KAAA,CAA/C,gBAAoC,CAApC;;AAEA,cAAIC,SAAS,KAAK,CAAlB,CAAA,EAAsB;AAEpBF,YAAAA,gBAAgB,CAAhBA,IAAAA,CAAsBC,CAAC,CAAvBD,MAAAA;AAFF,WAAA,MAGO,IAAI,CAACD,YAAY,CAAZA,GAAAA,CAAL,SAAKA,CAAL,EAAkC;AAEvCA,YAAAA,YAAY,CAAZA,GAAAA,CAAAA,SAAAA;AACAC,YAAAA,gBAAgB,CAAhBA,IAAAA,CAAsBC,CAAC,CAAvBD,MAAAA;AACD;AACF;AAhBqC,OAAA,CAAA,OAAA,GAAA,EAAA;AAAA,QAAA,SAAA,CAAA,CAAA,CAAA,GAAA;AAAA,OAAA,SAAA;AAAA,QAAA,SAAA,CAAA,CAAA;AAAA;;AAkBtC,aAAA,gBAAA;AACD;;;gDAE2B;AAAA,UAAA,KAAA,GAAA,IAAA;;AAC1B,UAAMG,QAAQ,GAAd,aAAA;AAD0B,UAEnBC,OAFmB,GAER,KAFQ,KAER,CAFQ,OAAA;AAI1BA,MAAAA,OAAO,CAAPA,aAAAA,CAAAA,OAAAA,CAA8B,UAAA,IAAA,EAAQ;AACpC,YAAI,CAACtD,IAAI,CAAJA,cAAAA,CAAL,QAAKA,CAAL,EAAoC;AAElCuD,UAAAA,MAAM,CAANA,cAAAA,CAAAA,IAAAA,EAAAA,QAAAA,EAAsC;AACpCC,YAAAA,GAAG,EAAE,SAAA,GAAA,GAAM;AAET,kBAAI,CAACxD,IAAI,CAAT,OAAA,EAAmB;AACjB,uBAAA,IAAA;AACD;;AAED,kBAAI,KAAI,CAAJ,KAAA,CAAA,MAAA,IAAqBmC,KAAK,CAALA,OAAAA,CAAcnC,IAAI,CAAvC,OAAqBmC,CAArB,IAAoD,CAACnC,IAAI,CAAJA,OAAAA,CAAzD,MAAA,EAA8E;AAG5E,uBAAA,EAAA;AACD;;AAED,kBAAIA,IAAI,CAAJA,aAAAA,KAAJ,SAAA,EAAsC;AAEpC,oBAAMyD,OAAO,GAAG,KAAI,CAAJ,KAAA,CAAA,MAAA,GAAoBC,eAAe,CAAC1D,IAAI,CAAxC,OAAmC,CAAnC,GAAoDA,IAAI,CAAxE,OAAA;AACAA,gBAAAA,IAAI,CAAJA,aAAAA,GAAqB,OAAO,CAAP,GAAA,CAAY,UAAA,OAAA,EAAO;AAAA,yBACtC8B,0BAA0B,CAAA,OAAA,EAAU9B,IAAI,CAAd,IAAA,EAAqB,KAAI,CAAJ,OAAA,CADT,QACZ,CADY;AAAxCA,iBAAqB,CAArBA;AAGD;;AACD,qBAAOA,IAAI,CAAX,aAAA;AACD;AArBmC,WAAtCuD;AAuBD;AA1BHD,OAAAA;AA4BD;;;wBAhPc;AACb,aAAO,KAAA,KAAA,CAAA,IAAA,IAAmB,KAAA,KAAA,CAAnB,OAAA,IAAA,IAAA,CAAA,eAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAA,UAAA,EAAP,IAAO,CAAP;AACD;;;;EAXmClE,S;;SAAjBD,Q;;AA4PrB,SAAA,kBAAA,CAAA,OAAA,EAAA,gBAAA,EAAuD;AACrD,MAAA,gBAAA,EAAsB;AACpB,WAAOwE,OAAO,CAAPA,UAAAA,CAAP,gBAAOA,CAAP;AACD;;AAED,MAAI,QAAJ,OAAA,EAAqB;AACnB,WAAOA,OAAO,CAAd,EAAA;AACD;;AAED,SAAO,CAAP,CAAA;AACD;;AAED,SAAA,kBAAA,CAAA,KAAA,EAAmC;AACjC,SAAO9E,KAAK,KAALA,SAAAA,IAAuBA,KAAK,KAA5BA,IAAAA,IAAyCA,KAAK,KAArD,EAAA;AACD;;AAED,SAAA,0BAAA,CAAA,MAAA,EAAA,IAAA,EAAA,QAAA,EAA4D;AAC1D,MAAM8E,OAAO,GAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,MAAA,CAAA,EAAA,EAAA,EAAA;AAEXpB,IAAAA,QAAQ,EAAE;AACR3D,MAAAA,IAAI,EAAEgF,MAAM,CAANA,QAAAA,CAAgBhF;AADd;AAFC,GAAA,CAAb;;AAQA2E,EAAAA,MAAM,CAANA,cAAAA,CAAsBI,OAAO,CAA7BJ,QAAAA,EAAAA,aAAAA,EAAuD;AACrDC,IAAAA,GAAG,EAAE,SAAA,GAAA,GAAM;AACT,UAAMK,SAAS,GAAGC,SAAS,CAACF,MAAM,CAAP,QAAA,EAAA,IAAA,EAA3B,QAA2B,CAA3B;AACA,aAAOC,SAAS,CAAhB,WAAA;AACD;AAJoD,GAAvDN;AAOA,SAAA,OAAA;AACD;;AAEDpE,QAAQ,CAARA,SAAAA,GAAAA,UAAAA;AACAA,QAAQ,CAARA,YAAAA,GAAAA,YAAAA","sourcesContent":["import {Matrix4} from 'math.gl';\nimport {MVTLoader} from '@loaders.gl/mvt';\nimport {binaryToGeoJson} from '@loaders.gl/gis';\nimport {load} from '@loaders.gl/core';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {_binaryToFeature, _findIndexBinary} from '@deck.gl/layers';\n\nimport TileLayer from '../tile-layer/tile-layer';\nimport {getURLFromTemplate, isURLTemplate} from '../tile-layer/utils';\nimport ClipExtension from './clip-extension';\nimport {transform} from './coordinate-transform';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps = {\n  uniqueIdProperty: {type: 'string', value: ''},\n  highlightedFeatureId: null,\n  loaders: [MVTLoader],\n  binary: false\n};\n\nasync function fetchTileJSON(url) {\n  try {\n    return await load(url);\n  } catch (error) {\n    throw new Error(`An error occurred fetching TileJSON: ${error}`);\n  }\n}\n\nexport default class MVTLayer extends TileLayer {\n  initializeState() {\n    super.initializeState();\n    this.setState({\n      data: null,\n      tileJSON: null\n    });\n  }\n\n  get isLoaded() {\n    return this.state.data && this.state.tileset && super.isLoaded;\n  }\n\n  updateState({props, oldProps, context, changeFlags}) {\n    if (changeFlags.dataChanged) {\n      this._updateTileData({props});\n    }\n\n    if (this.state.data) {\n      super.updateState({props, oldProps, context, changeFlags});\n      this._setWGS84PropertyForTiles();\n    }\n  }\n\n  async _updateTileData({props}) {\n    const {onDataLoad} = this.props;\n    let {data} = props;\n    let tileJSON = null;\n    let {minZoom, maxZoom} = props;\n\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      this.setState({data: null, tileJSON: null});\n      tileJSON = await fetchTileJSON(data);\n\n      if (onDataLoad) {\n        onDataLoad(tileJSON);\n      }\n    } else if (data.tilejson) {\n      tileJSON = data;\n    }\n\n    if (tileJSON) {\n      data = tileJSON.tiles;\n\n      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {\n        minZoom = tileJSON.minzoom;\n      }\n\n      if (\n        Number.isFinite(tileJSON.maxzoom) &&\n        (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)\n      ) {\n        maxZoom = tileJSON.maxzoom;\n      }\n    }\n\n    this.setState({data, tileJSON, minZoom, maxZoom});\n  }\n\n  renderLayers() {\n    if (!this.state.data) return null;\n    return super.renderLayers();\n  }\n\n  getTileData(tile) {\n    const url = getURLFromTemplate(this.state.data, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let options = this.getLoadOptions();\n    options = {\n      ...options,\n      mvt: {\n        ...(options && options.mvt),\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: {x: tile.x, y: tile.y, z: tile.z}\n        // Local worker debug\n        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`\n        // Set worker to null to skip web workers\n        // workerUrl: null\n      },\n      gis: this.props.binary ? {format: 'binary'} : {}\n    };\n    return load(url, this.props.loaders[0], options);\n  }\n\n  renderSubLayers(props) {\n    const {tile} = props;\n    const worldScale = Math.pow(2, tile.z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    return super.renderSubLayers(props);\n  }\n\n  onHover(info, pickingEvent) {\n    const {uniqueIdProperty, autoHighlight} = this.props;\n\n    if (autoHighlight) {\n      const {hoveredFeatureId} = this.state;\n      const hoveredFeature = info.object;\n      let newHoveredFeatureId;\n\n      if (hoveredFeature) {\n        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      }\n\n      if (hoveredFeatureId !== newHoveredFeatureId && newHoveredFeatureId !== -1) {\n        this.setState({hoveredFeatureId: newHoveredFeatureId});\n      }\n    }\n\n    return super.onHover(info, pickingEvent);\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n\n    const isWGS84 = this.context.viewport.resolution;\n\n    if (info.object && !isWGS84) {\n      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);\n    } else if (this.props.binary && info.index !== -1) {\n      // get the feature from the binary at the given index.\n      const {data} = params.sourceLayer.props;\n      info.object =\n        _binaryToFeature(data.points, info.index) ||\n        _binaryToFeature(data.lines, info.index) ||\n        _binaryToFeature(data.polygons, info.index);\n    }\n\n    return info;\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {hoveredFeatureId} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId, binary} = this.props;\n    const {data} = tile;\n\n    const isFeatureIdPresent =\n      isFeatureIdDefined(hoveredFeatureId) || isFeatureIdDefined(highlightedFeatureId);\n\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isFeatureIdDefined(highlightedFeatureId)\n      ? highlightedFeatureId\n      : hoveredFeatureId;\n\n    // Iterable data\n    if (Array.isArray(data)) {\n      return data.findIndex(\n        feature => getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight\n      );\n\n      // Non-iterable data\n    } else if (data && binary) {\n      // Get the feature index of the selected item to highlight\n      const featureIdIndex = _findIndexBinary(data, uniqueIdProperty, featureIdToHighlight);\n\n      const geometries = ['points', 'lines', 'polygons'];\n      for (const geometry of geometries) {\n        const index = data[geometry] && data[geometry].featureIds.value[featureIdIndex];\n        if (index !== undefined) return index;\n      }\n    }\n\n    return -1;\n  }\n\n  _pickObjects(maxObjects) {\n    const {deck, viewport} = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck.pickObjects({x, y, width, height, layerIds, maxObjects});\n  }\n\n  getRenderedFeatures(maxFeatures = null) {\n    const features = this._pickObjects(maxFeatures);\n    const featureCache = new Set();\n    const renderedFeatures = [];\n\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n      if (featureId === -1) {\n        // we have no id for the feature, we just add to the list\n        renderedFeatures.push(f.object);\n      } else if (!featureCache.has(featureId)) {\n        // Add removing duplicates\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object);\n      }\n    }\n\n    return renderedFeatures;\n  }\n\n  _setWGS84PropertyForTiles() {\n    const propName = 'dataInWGS84';\n    const {tileset} = this.state;\n\n    tileset.selectedTiles.forEach(tile => {\n      if (!tile.hasOwnProperty(propName)) {\n        // eslint-disable-next-line accessor-pairs\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            // Still loading or encountered an error\n            if (!tile.content) {\n              return null;\n            }\n\n            if (this.props.binary && Array.isArray(tile.content) && !tile.content.length) {\n              // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.\n              // https://github.com/visgl/loaders.gl/pull/1137\n              return [];\n            }\n\n            if (tile._contentWGS84 === undefined) {\n              // Create a cache to transform only once\n              const content = this.props.binary ? binaryToGeoJson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature =>\n                transformTileCoordsToWGS84(feature, tile.bbox, this.context.viewport)\n              );\n            }\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return -1;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  const feature = {\n    ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n\n  return feature;\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}