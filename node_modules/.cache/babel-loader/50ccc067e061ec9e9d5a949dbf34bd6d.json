{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport { createIterable, getAccessorFromBuffer } from '../../utils/iterable-utils';\nimport { fillArray } from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\n\nvar Attribute = function (_DataColumn) {\n  _inherits(Attribute, _DataColumn);\n\n  var _super = _createSuper(Attribute);\n\n  function Attribute(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Attribute);\n\n    _this = _super.call(this, gl, opts);\n    var _opts$transition = opts.transition,\n        transition = _opts$transition === void 0 ? false : _opts$transition,\n        _opts$noAlloc = opts.noAlloc,\n        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,\n        _opts$update = opts.update,\n        update = _opts$update === void 0 ? null : _opts$update,\n        _opts$accessor = opts.accessor,\n        accessor = _opts$accessor === void 0 ? null : _opts$accessor,\n        _opts$transform = opts.transform,\n        transform = _opts$transform === void 0 ? null : _opts$transform,\n        _opts$startIndices = opts.startIndices,\n        startIndices = _opts$startIndices === void 0 ? null : _opts$startIndices;\n    Object.assign(_this.settings, {\n      transition: transition,\n      noAlloc: noAlloc,\n      update: update || accessor && _this._autoUpdater,\n      accessor: accessor,\n      transform: transform\n    });\n    Object.assign(_this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices: startIndices\n    });\n    Object.seal(_this.settings);\n    Object.seal(_this.state);\n\n    _this._validateAttributeUpdaters();\n\n    return _this;\n  }\n\n  _createClass(Attribute, [{\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this.state.needsUpdate;\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$clearChangedFlag = _ref.clearChangedFlags,\n          clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;\n\n      var needsRedraw = this.state.needsRedraw;\n      this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n      return needsRedraw;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers() {\n      var accessor = this.settings.accessor;\n      return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n    }\n  }, {\n    key: \"supportsTransition\",\n    value: function supportsTransition() {\n      return Boolean(this.settings.transition);\n    }\n  }, {\n    key: \"getTransitionSetting\",\n    value: function getTransitionSetting(opts) {\n      if (!opts || !this.supportsTransition()) {\n        return null;\n      }\n\n      var accessor = this.settings.accessor;\n      var layerSettings = this.settings.transition;\n      var userSettings = Array.isArray(accessor) ? opts[accessor.find(function (a) {\n        return opts[a];\n      })] : opts[accessor];\n      return normalizeTransitionSettings(userSettings, layerSettings);\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      var dataRange = arguments.length > 1 ? arguments[1] : undefined;\n      this.state.needsUpdate = this.state.needsUpdate || reason;\n      this.setNeedsRedraw(reason);\n\n      if (dataRange) {\n        var _dataRange$startRow = dataRange.startRow,\n            startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,\n            _dataRange$endRow = dataRange.endRow,\n            endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;\n        this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n      } else {\n        this.state.updateRanges = range.FULL;\n      }\n    }\n  }, {\n    key: \"clearNeedsUpdate\",\n    value: function clearNeedsUpdate() {\n      this.state.needsUpdate = false;\n      this.state.updateRanges = range.EMPTY;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      this.state.needsRedraw = this.state.needsRedraw || reason;\n    }\n  }, {\n    key: \"update\",\n    value: function update(opts) {\n      this.setData(opts);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(numInstances) {\n      var state = this.state,\n          settings = this.settings;\n\n      if (settings.noAlloc) {\n        return false;\n      }\n\n      if (settings.update) {\n        assert(Number.isFinite(numInstances));\n\n        _get(_getPrototypeOf(Attribute.prototype), \"allocate\", this).call(this, {\n          numInstances: numInstances,\n          copy: state.updateRanges !== range.FULL\n        });\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(_ref2) {\n      var numInstances = _ref2.numInstances,\n          data = _ref2.data,\n          props = _ref2.props,\n          context = _ref2.context;\n\n      if (!this.needsUpdate()) {\n        return false;\n      }\n\n      var updateRanges = this.state.updateRanges,\n          _this$settings = this.settings,\n          update = _this$settings.update,\n          noAlloc = _this$settings.noAlloc;\n      var updated = true;\n\n      if (update) {\n        var _iterator = _createForOfIteratorHelper(updateRanges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                _startRow = _step$value[0],\n                _endRow = _step$value[1];\n\n            update.call(context, this, {\n              data: data,\n              startRow: _startRow,\n              endRow: _endRow,\n              props: props,\n              numInstances: numInstances\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n          this.setData({\n            value: this.value,\n            constant: this.constant\n          });\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(updateRanges),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  startRow = _step2$value[0],\n                  endRow = _step2$value[1];\n\n              var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n              var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n\n              _get(_getPrototypeOf(Attribute.prototype), \"updateSubBuffer\", this).call(this, {\n                startOffset: startOffset,\n                endOffset: endOffset\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        this._checkAttributeArray();\n      } else {\n        updated = false;\n      }\n\n      this.clearNeedsUpdate();\n      this.setNeedsRedraw();\n      return updated;\n    }\n  }, {\n    key: \"setConstantValue\",\n    value: function setConstantValue(value) {\n      if (value === undefined || typeof value === 'function') {\n        return false;\n      }\n\n      var hasChanged = this.setData({\n        constant: true,\n        value: value\n      });\n\n      if (hasChanged) {\n        this.setNeedsRedraw();\n      }\n\n      this.clearNeedsUpdate();\n      return true;\n    }\n  }, {\n    key: \"setExternalBuffer\",\n    value: function setExternalBuffer(buffer) {\n      var state = this.state;\n\n      if (!buffer) {\n        state.lastExternalBuffer = null;\n        return false;\n      }\n\n      this.clearNeedsUpdate();\n\n      if (state.lastExternalBuffer === buffer) {\n        return true;\n      }\n\n      state.lastExternalBuffer = buffer;\n      this.setNeedsRedraw();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"setBinaryValue\",\n    value: function setBinaryValue(buffer) {\n      var startIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var state = this.state,\n          settings = this.settings;\n\n      if (!buffer) {\n        state.binaryValue = null;\n        state.binaryAccessor = null;\n        return false;\n      }\n\n      if (settings.noAlloc) {\n        return false;\n      }\n\n      if (state.binaryValue === buffer) {\n        this.clearNeedsUpdate();\n        return true;\n      }\n\n      state.binaryValue = buffer;\n      this.setNeedsRedraw();\n\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n\n      var needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n      if (needsUpdate) {\n        assert(ArrayBuffer.isView(buffer.value), \"invalid \".concat(settings.accessor));\n        var needsNormalize = buffer.size && buffer.size !== this.size;\n        state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n          size: buffer.size || this.size,\n          stride: buffer.stride,\n          offset: buffer.offset,\n          startIndices: startIndices,\n          nested: needsNormalize\n        });\n        return false;\n      }\n\n      this.clearNeedsUpdate();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"getVertexOffset\",\n    value: function getVertexOffset(row) {\n      var startIndices = this.startIndices;\n      var vertexIndex = startIndices ? startIndices[row] : row;\n      return vertexIndex * this.size;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes() {\n      var shaderAttributeDefs = this.settings.shaderAttributes || _defineProperty({}, this.id, null);\n\n      var shaderAttributes = {};\n\n      for (var shaderAttributeName in shaderAttributeDefs) {\n        Object.assign(shaderAttributes, _get(_getPrototypeOf(Attribute.prototype), \"getShaderAttributes\", this).call(this, shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n      }\n\n      return shaderAttributes;\n    }\n  }, {\n    key: \"_autoUpdater\",\n    value: function _autoUpdater(attribute, _ref4) {\n      var data = _ref4.data,\n          startRow = _ref4.startRow,\n          endRow = _ref4.endRow,\n          props = _ref4.props,\n          numInstances = _ref4.numInstances;\n\n      if (attribute.constant) {\n        return;\n      }\n\n      var settings = attribute.settings,\n          state = attribute.state,\n          value = attribute.value,\n          size = attribute.size,\n          startIndices = attribute.startIndices;\n      var accessor = settings.accessor,\n          transform = settings.transform;\n      var accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n      assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n      var i = attribute.getVertexOffset(startRow);\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iterator3 = _createForOfIteratorHelper(iterable),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var object = _step3.value;\n          objectInfo.index++;\n          var objectValue = accessorFunc(object, objectInfo);\n\n          if (transform) {\n            objectValue = transform.call(this, objectValue);\n          }\n\n          if (startIndices) {\n            var numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n\n            if (objectValue && Array.isArray(objectValue[0])) {\n              var startIndex = i;\n\n              var _iterator4 = _createForOfIteratorHelper(objectValue),\n                  _step4;\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var item = _step4.value;\n\n                  attribute._normalizeValue(item, value, startIndex);\n\n                  startIndex += size;\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            } else if (objectValue && objectValue.length > size) {\n              value.set(objectValue, i);\n            } else {\n              attribute._normalizeValue(objectValue, objectInfo.target, 0);\n\n              fillArray({\n                target: value,\n                source: objectInfo.target,\n                start: i,\n                count: numVertices\n              });\n            }\n\n            i += numVertices * size;\n          } else {\n            attribute._normalizeValue(objectValue, value, i);\n\n            i += size;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"_validateAttributeUpdaters\",\n    value: function _validateAttributeUpdaters() {\n      var settings = this.settings;\n      var hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n\n      if (!hasUpdater) {\n        throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n      }\n    }\n  }, {\n    key: \"_checkAttributeArray\",\n    value: function _checkAttributeArray() {\n      var value = this.value;\n      var limit = Math.min(4, this.size);\n\n      if (value && value.length >= limit) {\n        var valid = true;\n\n        switch (limit) {\n          case 4:\n            valid = valid && Number.isFinite(value[3]);\n\n          case 3:\n            valid = valid && Number.isFinite(value[2]);\n\n          case 2:\n            valid = valid && Number.isFinite(value[1]);\n\n          case 1:\n            valid = valid && Number.isFinite(value[0]);\n            break;\n\n          default:\n            valid = false;\n        }\n\n        if (!valid) {\n          throw new Error(\"Illegal attribute generated for \".concat(this.id));\n        }\n      }\n    }\n  }, {\n    key: \"startIndices\",\n    get: function get() {\n      return this.state.startIndices;\n    },\n    set: function set(layout) {\n      this.state.startIndices = layout;\n    }\n  }]);\n\n  return Attribute;\n}(DataColumn);\n\nexport { Attribute as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute.js"],"names":["Attribute","DataColumn","opts","transition","noAlloc","update","accessor","transform","startIndices","Object","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","range","layout","clearChangedFlags","Boolean","layerSettings","userSettings","normalizeTransitionSettings","reason","id","dataRange","startRow","endRow","numInstances","state","settings","assert","Number","copy","FULL","data","props","context","updated","value","constant","startOffset","endOffset","hasChanged","buffer","ArrayBuffer","needsNormalize","getAccessorFromBuffer","size","stride","offset","nested","row","vertexIndex","shaderAttributeDefs","shaderAttributes","attribute","accessorFunc","i","iterable","objectInfo","createIterable","object","objectValue","numVertices","Array","startIndex","item","fillArray","target","source","start","count","hasUpdater","limit","Math","valid"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings} from './attribute-transition-utils';\n\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    const {\n      // deck.gl fields\n      transition = false,\n      noAlloc = false,\n      update = null,\n      accessor = null,\n      transform = null,\n      startIndices = null\n    } = opts;\n\n    Object.assign(this.settings, {\n      transition,\n      noAlloc,\n      update: update || (accessor && this._autoUpdater),\n      accessor,\n      transform\n    });\n\n    Object.assign(this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices\n    });\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false} = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? opts[accessor.find(a => opts[a])]\n      : opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  update(opts) {\n    // backward compatibility\n    this.setData(opts);\n  }\n\n  allocate(numInstances) {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      assert(Number.isFinite(numInstances));\n      super.allocate({\n        numInstances,\n        copy: state.updateRanges !== range.FULL\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({numInstances, data, props, context}) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < this.value.byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n              ? this.value.length\n              : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    if (ArrayBuffer.isView(buffer)) {\n      buffer = {value: buffer};\n    }\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      assert(ArrayBuffer.isView(buffer.value), `invalid ${settings.accessor}`);\n      const needsNormalize = buffer.size && buffer.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n        size: buffer.size || this.size,\n        stride: buffer.stride,\n        offset: buffer.offset,\n        startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {data, startRow, endRow, props, numInstances}) {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc =\n      state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"]},"metadata":{},"sourceType":"module"}