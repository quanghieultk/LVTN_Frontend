{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { h3SetToMultiPolygon } from 'h3-js';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { PolygonLayer } from '@deck.gl/layers';\nvar defaultProps = Object.assign({\n  getHexagons: {\n    type: 'accessor',\n    value: function value(d) {\n      return d.hexagons;\n    }\n  }\n}, PolygonLayer.defaultProps);\n\nvar H3ClusterLayer = function (_CompositeLayer) {\n  _inherits(H3ClusterLayer, _CompositeLayer);\n\n  var _super = _createSuper(H3ClusterLayer);\n\n  function H3ClusterLayer() {\n    _classCallCheck(this, H3ClusterLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(H3ClusterLayer, [{\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.dataChanged || changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagons) {\n        var data = props.data,\n            getHexagons = props.getHexagons;\n        var polygons = [];\n\n        var _createIterable = createIterable(data),\n            iterable = _createIterable.iterable,\n            objectInfo = _createIterable.objectInfo;\n\n        var _iterator = _createForOfIteratorHelper(iterable),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var object = _step.value;\n            objectInfo.index++;\n            var hexagons = getHexagons(object, objectInfo);\n            var multiPolygon = h3SetToMultiPolygon(hexagons, true);\n\n            var _iterator2 = _createForOfIteratorHelper(multiPolygon),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var polygon = _step2.value;\n                polygons.push(this.getSubLayerRow({\n                  polygon: polygon\n                }, object, objectInfo.index));\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.setState({\n          polygons: polygons\n        });\n      }\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$props = this.props,\n          elevationScale = _this$props.elevationScale,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe,\n          filled = _this$props.filled,\n          stroked = _this$props.stroked,\n          lineWidthScale = _this$props.lineWidthScale,\n          lineWidthMinPixels = _this$props.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props.lineWidthMaxPixels,\n          lineJointRounded = _this$props.lineJointRounded,\n          lineMiterLimit = _this$props.lineMiterLimit,\n          lineDashJustified = _this$props.lineDashJustified,\n          material = _this$props.material,\n          getFillColor = _this$props.getFillColor,\n          getLineColor = _this$props.getLineColor,\n          getLineWidth = _this$props.getLineWidth,\n          getLineDashArray = _this$props.getLineDashArray,\n          getElevation = _this$props.getElevation,\n          transitions = _this$props.transitions,\n          updateTriggers = _this$props.updateTriggers;\n      var SubLayerClass = this.getSubLayerClass('cluster-region', PolygonLayer);\n      return new SubLayerClass({\n        filled: filled,\n        wireframe: wireframe,\n        extruded: extruded,\n        elevationScale: elevationScale,\n        stroked: stroked,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        lineJointRounded: lineJointRounded,\n        lineMiterLimit: lineMiterLimit,\n        lineDashJustified: lineDashJustified,\n        material: material,\n        transitions: transitions,\n        getFillColor: this.getSubLayerAccessor(getFillColor),\n        getLineColor: this.getSubLayerAccessor(getLineColor),\n        getLineWidth: this.getSubLayerAccessor(getLineWidth),\n        getLineDashArray: this.getSubLayerAccessor(getLineDashArray),\n        getElevation: this.getSubLayerAccessor(getElevation)\n      }, this.getSubLayerProps({\n        id: 'cluster-region',\n        updateTriggers: updateTriggers\n      }), {\n        data: this.state.polygons,\n        getPolygon: function getPolygon(d) {\n          return d.polygon;\n        }\n      });\n    }\n  }]);\n\n  return H3ClusterLayer;\n}(CompositeLayer);\n\nexport { H3ClusterLayer as default };\nH3ClusterLayer.defaultProps = defaultProps;\nH3ClusterLayer.layerName = 'H3ClusterLayer';","map":{"version":3,"sources":["../../../src/h3-layers/h3-cluster-layer.js"],"names":["defaultProps","getHexagons","type","value","d","PolygonLayer","H3ClusterLayer","CompositeLayer","props","oldProps","changeFlags","data","polygons","iterable","objectInfo","createIterable","object","hexagons","multiPolygon","h3SetToMultiPolygon","polygon","elevationScale","extruded","wireframe","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","lineJointRounded","lineMiterLimit","lineDashJustified","material","getFillColor","getLineColor","getLineWidth","getLineDashArray","getElevation","transitions","updateTriggers","SubLayerClass","id","getPolygon"],"mappings":"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","sourcesContent":["import {h3SetToMultiPolygon} from 'h3-js';\n\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport {PolygonLayer} from '@deck.gl/layers';\n\nconst defaultProps = Object.assign(\n  {\n    getHexagons: {type: 'accessor', value: d => d.hexagons}\n  },\n  PolygonLayer.defaultProps\n);\n\nexport default class H3ClusterLayer extends CompositeLayer {\n  updateState({props, oldProps, changeFlags}) {\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagons)\n    ) {\n      const {data, getHexagons} = props;\n      const polygons = [];\n\n      const {iterable, objectInfo} = createIterable(data);\n      for (const object of iterable) {\n        objectInfo.index++;\n        const hexagons = getHexagons(object, objectInfo);\n        const multiPolygon = h3SetToMultiPolygon(hexagons, true);\n\n        for (const polygon of multiPolygon) {\n          polygons.push(this.getSubLayerRow({polygon}, object, objectInfo.index));\n        }\n      }\n\n      this.setState({polygons});\n    }\n  }\n\n  renderLayers() {\n    const {\n      elevationScale,\n      extruded,\n      wireframe,\n      filled,\n      stroked,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified,\n      material,\n\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('cluster-region', PolygonLayer);\n\n    return new SubLayerClass(\n      {\n        filled,\n        wireframe,\n\n        extruded,\n        elevationScale,\n\n        stroked,\n        lineWidthScale,\n        lineWidthMinPixels,\n        lineWidthMaxPixels,\n        lineJointRounded,\n        lineMiterLimit,\n        lineDashJustified,\n\n        material,\n        transitions,\n\n        getFillColor: this.getSubLayerAccessor(getFillColor),\n        getLineColor: this.getSubLayerAccessor(getLineColor),\n        getLineWidth: this.getSubLayerAccessor(getLineWidth),\n        getLineDashArray: this.getSubLayerAccessor(getLineDashArray),\n        getElevation: this.getSubLayerAccessor(getElevation)\n      },\n      this.getSubLayerProps({\n        id: 'cluster-region',\n        updateTriggers\n      }),\n      {\n        data: this.state.polygons,\n        getPolygon: d => d.polygon\n      }\n    );\n  }\n}\n\nH3ClusterLayer.defaultProps = defaultProps;\nH3ClusterLayer.layerName = 'H3ClusterLayer';\n"]},"metadata":{},"sourceType":"module"}