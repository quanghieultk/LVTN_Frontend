{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { CompositeLayer, AttributeManager, _compareProps as compareProps } from '@deck.gl/core';\nimport { cssToDeviceRatio } from '@luma.gl/core';\nimport { filterProps } from './utils/prop-utils';\n\nvar AggregationLayer = function (_CompositeLayer) {\n  _inherits(AggregationLayer, _CompositeLayer);\n\n  var _super = _createSuper(AggregationLayer);\n\n  function AggregationLayer() {\n    _classCallCheck(this, AggregationLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AggregationLayer, [{\n    key: \"initializeState\",\n    value: function initializeState(dimensions) {\n      _get(_getPrototypeOf(AggregationLayer.prototype), \"initializeState\", this).call(this);\n\n      this.setState({\n        ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),\n        dimensions: dimensions\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(opts) {\n      _get(_getPrototypeOf(AggregationLayer.prototype), \"updateState\", this).call(this, opts);\n\n      var changeFlags = opts.changeFlags;\n\n      if (changeFlags.extensionsChanged) {\n        var shaders = this.getShaders({});\n\n        if (shaders && shaders.defines) {\n          shaders.defines.NON_INSTANCED_MODEL = 1;\n        }\n\n        this.updateShaders(shaders);\n      }\n\n      this._updateAttributes(opts.props);\n    }\n  }, {\n    key: \"updateAttributes\",\n    value: function updateAttributes(changedAttributes) {\n      this.setState({\n        changedAttributes: changedAttributes\n      });\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.getAttributeManager().getShaderAttributes();\n    }\n  }, {\n    key: \"getModuleSettings\",\n    value: function getModuleSettings() {\n      var _this$context = this.context,\n          viewport = _this$context.viewport,\n          mousePosition = _this$context.mousePosition,\n          gl = _this$context.gl;\n      var moduleSettings = Object.assign(Object.create(this.props), {\n        viewport: viewport,\n        mousePosition: mousePosition,\n        pickingActive: 0,\n        devicePixelRatio: cssToDeviceRatio(gl)\n      });\n      return moduleSettings;\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders(shaders) {}\n  }, {\n    key: \"isAggregationDirty\",\n    value: function isAggregationDirty(updateOpts) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var props = updateOpts.props,\n          oldProps = updateOpts.oldProps,\n          changeFlags = updateOpts.changeFlags;\n      var _params$compareAll = params.compareAll,\n          compareAll = _params$compareAll === void 0 ? false : _params$compareAll,\n          dimension = params.dimension;\n      var ignoreProps = this.state.ignoreProps;\n      var dataProps = dimension.props,\n          _dimension$accessors = dimension.accessors,\n          accessors = _dimension$accessors === void 0 ? [] : _dimension$accessors;\n      var updateTriggersChanged = changeFlags.updateTriggersChanged;\n\n      if (changeFlags.dataChanged) {\n        return true;\n      }\n\n      if (updateTriggersChanged) {\n        if (updateTriggersChanged.all) {\n          return true;\n        }\n\n        var _iterator = _createForOfIteratorHelper(accessors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var accessor = _step.value;\n\n            if (updateTriggersChanged[accessor]) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (compareAll) {\n        if (changeFlags.extensionsChanged) {\n          return true;\n        }\n\n        return compareProps({\n          oldProps: oldProps,\n          newProps: props,\n          ignoreProps: ignoreProps,\n          propTypes: this.constructor._propTypes\n        });\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(dataProps),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var name = _step2.value;\n\n          if (props[name] !== oldProps[name]) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isAttributeChanged\",\n    value: function isAttributeChanged(name) {\n      var changedAttributes = this.state.changedAttributes;\n\n      if (!name) {\n        return !isObjectEmpty(changedAttributes);\n      }\n\n      return changedAttributes && changedAttributes[name] !== undefined;\n    }\n  }, {\n    key: \"_getAttributeManager\",\n    value: function _getAttributeManager() {\n      return new AttributeManager(this.context.gl, {\n        id: this.props.id,\n        stats: this.context.stats\n      });\n    }\n  }]);\n\n  return AggregationLayer;\n}(CompositeLayer);\n\nexport { AggregationLayer as default };\n\nfunction isObjectEmpty(obj) {\n  var isEmpty = true;\n\n  for (var key in obj) {\n    isEmpty = false;\n    break;\n  }\n\n  return isEmpty;\n}\n\nAggregationLayer.layerName = 'AggregationLayer';","map":{"version":3,"sources":["../../src/aggregation-layer.js"],"names":["_compareProps","AggregationLayer","CompositeLayer","dimensions","ignoreProps","filterProps","opts","changeFlags","shaders","changedAttributes","viewport","mousePosition","gl","moduleSettings","Object","pickingActive","devicePixelRatio","cssToDeviceRatio","updateOpts","params","props","oldProps","compareAll","dimension","dataProps","accessors","updateTriggersChanged","accessor","compareProps","newProps","propTypes","_propTypes","name","isObjectEmpty","id","stats","isEmpty"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, AttributeManager, _compareProps as compareProps} from '@deck.gl/core';\nimport {cssToDeviceRatio} from '@luma.gl/core';\nimport {filterProps} from './utils/prop-utils';\n\nexport default class AggregationLayer extends CompositeLayer {\n  initializeState(dimensions) {\n    super.initializeState();\n\n    this.setState({\n      // Layer props , when changed doesn't require updating aggregation\n      ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),\n      dimensions\n    });\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n    const {changeFlags} = opts;\n    if (changeFlags.extensionsChanged) {\n      const shaders = this.getShaders({});\n      if (shaders && shaders.defines) {\n        shaders.defines.NON_INSTANCED_MODEL = 1;\n      }\n      this.updateShaders(shaders);\n    }\n\n    // Explictly call to update attributes as 'CompositeLayer' doesn't call this\n    this._updateAttributes(opts.props);\n  }\n\n  updateAttributes(changedAttributes) {\n    // Super classes, can refer to state.changedAttributes to determine what\n    // attributes changed\n    this.setState({changedAttributes});\n  }\n\n  getAttributes() {\n    return this.getAttributeManager().getShaderAttributes();\n  }\n\n  getModuleSettings() {\n    // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle\n    // For aggregation layers this is called during updateState to update aggregation data\n    // NOTE: it is similar to LayerPass._getModuleParameters() but doesn't inlcude `effects` it is not needed for aggregation\n    const {viewport, mousePosition, gl} = this.context;\n    const moduleSettings = Object.assign(Object.create(this.props), {\n      viewport,\n      mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(gl)\n    });\n    return moduleSettings;\n  }\n\n  updateShaders(shaders) {\n    // Default implemention is empty, subclasses can update their Model objects if needed\n  }\n\n  /**\n   * Checks if aggregation is dirty\n   * @param {Object} updateOpts - object {props, oldProps, changeFlags}\n   * @param {Object} params - object {dimension, compareAll}\n   * @param {Object} params.dimension - {props, accessors} array of props and/or accessors\n   * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision\n   * @returns {Boolean} - returns true if dimensions' prop or accessor is changed\n   **/\n  isAggregationDirty(updateOpts, params = {}) {\n    const {props, oldProps, changeFlags} = updateOpts;\n    const {compareAll = false, dimension} = params;\n    const {ignoreProps} = this.state;\n    const {props: dataProps, accessors = []} = dimension;\n    const {updateTriggersChanged} = changeFlags;\n    if (changeFlags.dataChanged) {\n      return true;\n    }\n    if (updateTriggersChanged) {\n      if (updateTriggersChanged.all) {\n        return true;\n      }\n      for (const accessor of accessors) {\n        if (updateTriggersChanged[accessor]) {\n          return true;\n        }\n      }\n    }\n    if (compareAll) {\n      if (changeFlags.extensionsChanged) {\n        return true;\n      }\n      // Compare non layer props too (like extension props)\n      // ignoreprops refers to all Layer props other than aggregation props that need to be comapred\n      return compareProps({\n        oldProps,\n        newProps: props,\n        ignoreProps,\n        propTypes: this.constructor._propTypes\n      });\n    }\n    // Compare props of the dimension\n    for (const name of dataProps) {\n      if (props[name] !== oldProps[name]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if an attribute is changed\n   * @param {String} name - name of the attribute\n   * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,\n   *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise\n   **/\n  isAttributeChanged(name) {\n    const {changedAttributes} = this.state;\n    if (!name) {\n      // if name not specified return true if any attribute is changed\n      return !isObjectEmpty(changedAttributes);\n    }\n    return changedAttributes && changedAttributes[name] !== undefined;\n  }\n\n  // Private\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n}\n\n// Helper methods\n\n// Returns true if given object is empty, false otherwise.\nfunction isObjectEmpty(obj) {\n  let isEmpty = true;\n  /* eslint-disable no-unused-vars  */\n  for (const key in obj) {\n    isEmpty = false;\n    break;\n  }\n  /* eslint-enable no-unused-vars  */\n  return isEmpty;\n}\n\nAggregationLayer.layerName = 'AggregationLayer';\n"]},"metadata":{},"sourceType":"module"}