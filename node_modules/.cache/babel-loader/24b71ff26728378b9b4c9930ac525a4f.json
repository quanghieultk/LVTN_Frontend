{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _awaitAsyncGenerator from \"@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nvar DEFAULT_CHUNK_SIZE = 1024 * 1024;\nexport function makeBlobIterator(_x) {\n  return _makeBlobIterator.apply(this, arguments);\n}\n\nfunction _makeBlobIterator() {\n  _makeBlobIterator = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee(file) {\n    var options,\n        chunkSize,\n        offset,\n        end,\n        chunk,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;\n            offset = 0;\n\n          case 3:\n            if (!(offset < file.size)) {\n              _context.next = 13;\n              break;\n            }\n\n            end = offset + chunkSize;\n            _context.next = 7;\n            return _awaitAsyncGenerator(readFileSlice(file, offset, end));\n\n          case 7:\n            chunk = _context.sent;\n            offset = end;\n            _context.next = 11;\n            return chunk;\n\n          case 11:\n            _context.next = 3;\n            break;\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _makeBlobIterator.apply(this, arguments);\n}\n\nexport function readFileSlice(_x2, _x3, _x4) {\n  return _readFileSlice.apply(this, arguments);\n}\n\nfunction _readFileSlice() {\n  _readFileSlice = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(file, offset, end) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return new Promise(function (resolve, reject) {\n              var slice = file.slice(offset, end);\n              var fileReader = new FileReader();\n\n              fileReader.onload = function (event) {\n                return resolve(event.target && event.target.result);\n              };\n\n              fileReader.onerror = function (error) {\n                return reject(error);\n              };\n\n              fileReader.readAsArrayBuffer(slice);\n            });\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _readFileSlice.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/blob-iterator.js"],"names":["DEFAULT_CHUNK_SIZE","options","chunkSize","offset","file","end","chunk","readFileSlice","slice","fileReader","resolve","event","reject"],"mappings":"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","sourcesContent":["/* global FileReader */\n\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB â€” biggest value that keeps UI responsive\n\nexport async function* makeBlobIterator(file, options = {}) {\n  const chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  while (offset < file.size) {\n    const end = offset + chunkSize;\n\n    const chunk = await readFileSlice(file, offset, end);\n\n    offset = end;\n    yield chunk;\n  }\n}\n\nexport async function readFileSlice(file, offset, end) {\n  return await new Promise((resolve, reject) => {\n    // The trick when reading File objects is to read successive \"slices\" of the File\n    // Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n    // Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\n    const slice = file.slice(offset, end);\n\n    const fileReader = new FileReader();\n    fileReader.onload = event => resolve(event.target && event.target.result);\n    fileReader.onerror = error => reject(error);\n    fileReader.readAsArrayBuffer(slice);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}