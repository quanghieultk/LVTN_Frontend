{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { equals } from 'math.gl';\nimport assert from '../utils/assert';\n\nvar TransitionInterpolator = function () {\n  function TransitionInterpolator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TransitionInterpolator);\n\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n\n    var _opts = opts,\n        compare = _opts.compare,\n        extract = _opts.extract,\n        required = _opts.required;\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n\n  _createClass(TransitionInterpolator, [{\n    key: \"arePropsEqual\",\n    value: function arePropsEqual(currentProps, nextProps) {\n      var _iterator = _createForOfIteratorHelper(this._propsToCompare || Object.keys(nextProps)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n\n          if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var result;\n\n      if (this._propsToExtract) {\n        var startViewStateProps = {};\n        var endViewStateProps = {};\n\n        var _iterator2 = _createForOfIteratorHelper(this._propsToExtract),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n            startViewStateProps[key] = startProps[key];\n            endViewStateProps[key] = endProps[key];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        result = {\n          start: startViewStateProps,\n          end: endViewStateProps\n        };\n      } else {\n        result = {\n          start: startProps,\n          end: endProps\n        };\n      }\n\n      this._checkRequiredProps(result.start);\n\n      this._checkRequiredProps(result.end);\n\n      return result;\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      return endProps;\n    }\n  }, {\n    key: \"getDuration\",\n    value: function getDuration(startProps, endProps) {\n      return endProps.transitionDuration;\n    }\n  }, {\n    key: \"_checkRequiredProps\",\n    value: function _checkRequiredProps(props) {\n      if (!this._requiredProps) {\n        return;\n      }\n\n      this._requiredProps.forEach(function (propName) {\n        var value = props[propName];\n        assert(Number.isFinite(value) || Array.isArray(value), \"\".concat(propName, \" is required for transition\"));\n      });\n    }\n  }]);\n\n  return TransitionInterpolator;\n}();\n\nexport { TransitionInterpolator as default };","map":{"version":3,"sources":["../../../src/transitions/transition-interpolator.js"],"names":["TransitionInterpolator","opts","Array","compare","extract","required","currentProps","nextProps","key","Object","equals","startProps","endProps","startViewStateProps","endViewStateProps","result","start","end","t","props","value","assert","Number"],"mappings":"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","sourcesContent":["import {equals} from 'math.gl';\nimport assert from '../utils/assert';\n\nexport default class TransitionInterpolator {\n  /**\n   * @param opts {array|object}\n   * @param opts.compare {array} - prop names used in equality check\n   * @param opts.extract {array} - prop names needed for interpolation\n   * @param opts.required {array} - prop names that must be supplied\n   * alternatively, supply one list of prop names as `opts` if all of the above are the same.\n   */\n  constructor(opts = {}) {\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n    const {compare, extract, required} = opts;\n\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n\n  /**\n   * Checks if two sets of props need transition in between\n   * @param currentProps {object} - a list of viewport props\n   * @param nextProps {object} - a list of viewport props\n   * @returns {bool} - true if two props are equivalent\n   */\n  arePropsEqual(currentProps, nextProps) {\n    for (const key of this._propsToCompare || Object.keys(nextProps)) {\n      if (\n        !(key in currentProps) ||\n        !(key in nextProps) ||\n        !equals(currentProps[key], nextProps[key])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Called before transition starts to validate/pre-process start and end props\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Object} {start, end} - start and end props to be passed\n   *   to `interpolateProps`\n   */\n  initializeProps(startProps, endProps) {\n    let result;\n\n    if (this._propsToExtract) {\n      const startViewStateProps = {};\n      const endViewStateProps = {};\n\n      for (const key of this._propsToExtract) {\n        startViewStateProps[key] = startProps[key];\n        endViewStateProps[key] = endProps[key];\n      }\n      result = {start: startViewStateProps, end: endViewStateProps};\n    } else {\n      result = {start: startProps, end: endProps};\n    }\n\n    this._checkRequiredProps(result.start);\n    this._checkRequiredProps(result.end);\n\n    return result;\n  }\n\n  /**\n   * Returns viewport props in transition\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @param t {number} - a time factor between [0, 1]\n   * @returns {object} - a list of interpolated viewport props\n   */\n  interpolateProps(startProps, endProps, t) {\n    return endProps;\n  }\n\n  /**\n   * Returns transition duration\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Number} - transition duration in milliseconds\n   */\n  getDuration(startProps, endProps) {\n    return endProps.transitionDuration;\n  }\n\n  _checkRequiredProps(props) {\n    if (!this._requiredProps) {\n      return;\n    }\n\n    this._requiredProps.forEach(propName => {\n      const value = props[propName];\n      assert(\n        Number.isFinite(value) || Array.isArray(value),\n        `${propName} is required for transition`\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}