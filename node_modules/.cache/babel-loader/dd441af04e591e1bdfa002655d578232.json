{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport WorkerPool from './worker-pool';\nvar DEFAULT_MAX_CONCURRENCY = 5;\n\nvar WorkerFarm = function () {\n  _createClass(WorkerFarm, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      return typeof Worker !== 'undefined';\n    }\n  }]);\n\n  function WorkerFarm(_ref) {\n    var _ref$maxConcurrency = _ref.maxConcurrency,\n        maxConcurrency = _ref$maxConcurrency === void 0 ? DEFAULT_MAX_CONCURRENCY : _ref$maxConcurrency,\n        _ref$onMessage = _ref.onMessage,\n        onMessage = _ref$onMessage === void 0 ? null : _ref$onMessage,\n        _ref$onDebug = _ref.onDebug,\n        onDebug = _ref$onDebug === void 0 ? function () {} : _ref$onDebug,\n        _ref$reuseWorkers = _ref.reuseWorkers,\n        reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;\n\n    _classCallCheck(this, WorkerFarm);\n\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.workerPools = new Map();\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  _createClass(WorkerFarm, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('maxConcurrency' in props) {\n        this.maxConcurrency = props.maxConcurrency;\n      }\n\n      if ('onDebug' in props) {\n        this.onDebug = props.onDebug;\n      }\n\n      if ('reuseWorkers' in props) {\n        this.reuseWorkers = props.reuseWorkers;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.workerPools.forEach(function (workerPool) {\n        return workerPool.destroy();\n      });\n    }\n  }, {\n    key: \"process\",\n    value: function () {\n      var _process = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(workerSource, workerName, data) {\n        var workerPool;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                workerPool = this._getWorkerPool(workerSource, workerName);\n                return _context.abrupt(\"return\", workerPool.process(data));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function process(_x, _x2, _x3) {\n        return _process.apply(this, arguments);\n      }\n\n      return process;\n    }()\n  }, {\n    key: \"_getWorkerPool\",\n    value: function _getWorkerPool(workerSource, workerName) {\n      var workerPool = this.workerPools.get(workerName);\n\n      if (!workerPool) {\n        workerPool = new WorkerPool({\n          source: workerSource,\n          name: workerName,\n          onMessage: onWorkerMessage.bind(null, this.onMessage),\n          maxConcurrency: this.maxConcurrency,\n          onDebug: this.onDebug,\n          reuseWorkers: this.reuseWorkers\n        });\n        this.workerPools.set(workerName, workerPool);\n      }\n\n      return workerPool;\n    }\n  }]);\n\n  return WorkerFarm;\n}();\n\nexport { WorkerFarm as default };\n\nfunction onWorkerMessage(onMessage, _ref2) {\n  var worker = _ref2.worker,\n      data = _ref2.data,\n      resolve = _ref2.resolve,\n      reject = _ref2.reject;\n\n  if (onMessage) {\n    onMessage({\n      worker: worker,\n      data: data,\n      resolve: resolve,\n      reject: reject\n    });\n    return;\n  }\n\n  switch (data.type) {\n    case 'done':\n      resolve(data.result);\n      break;\n\n    case 'error':\n      reject(data.message);\n      break;\n\n    default:\n  }\n}","map":{"version":3,"sources":["../../../../src/lib/worker-utils/worker-farm.js"],"names":["DEFAULT_MAX_CONCURRENCY","WorkerFarm","maxConcurrency","onMessage","onDebug","reuseWorkers","props","workerPool","workerSource","workerName","data","source","name","onWorkerMessage","worker","resolve","reject"],"mappings":"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","sourcesContent":["import WorkerPool from './worker-pool';\n\nconst DEFAULT_MAX_CONCURRENCY = 5;\n\n/**\n * Process multiple data messages with a \"farm\" of different workers (in worker pools)\n */\nexport default class WorkerFarm {\n  static isSupported() {\n    return typeof Worker !== 'undefined';\n  }\n\n  constructor({\n    maxConcurrency = DEFAULT_MAX_CONCURRENCY,\n    onMessage = null,\n    onDebug = () => {},\n    reuseWorkers = true\n  }) {\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.workerPools = new Map();\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  setProps(props) {\n    if ('maxConcurrency' in props) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n\n    if ('onDebug' in props) {\n      this.onDebug = props.onDebug;\n    }\n\n    if ('reuseWorkers' in props) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n  }\n\n  destroy() {\n    this.workerPools.forEach(workerPool => workerPool.destroy());\n  }\n\n  /**\n   * Process binary data in a worker\n   * @param {any} data - data (containing binary typed arrays) to be transferred to worker\n   * @returns a Promise with data containing typed arrays transferred back from work\n   */\n  async process(workerSource, workerName, data) {\n    const workerPool = this._getWorkerPool(workerSource, workerName);\n    return workerPool.process(data);\n  }\n\n  // PRIVATE\n\n  _getWorkerPool(workerSource, workerName) {\n    let workerPool = this.workerPools.get(workerName);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        source: workerSource,\n        name: workerName,\n        onMessage: onWorkerMessage.bind(null, this.onMessage),\n        maxConcurrency: this.maxConcurrency,\n        onDebug: this.onDebug,\n        reuseWorkers: this.reuseWorkers\n      });\n      this.workerPools.set(workerName, workerPool);\n    }\n    return workerPool;\n  }\n}\n\nfunction onWorkerMessage(onMessage, {worker, data, resolve, reject}) {\n  if (onMessage) {\n    onMessage({worker, data, resolve, reject});\n    return;\n  }\n\n  switch (data.type) {\n    case 'done':\n      resolve(data.result);\n      break;\n\n    case 'error':\n      reject(data.message);\n      break;\n\n    default:\n  }\n}\n"]},"metadata":{},"sourceType":"module"}