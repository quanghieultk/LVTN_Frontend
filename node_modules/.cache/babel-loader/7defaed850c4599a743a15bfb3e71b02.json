{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport TransitionInterpolator from './transition-interpolator';\nimport { lerp } from 'math.gl';\nvar DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nvar DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];\n\nvar LinearInterpolator = function (_TransitionInterpolat) {\n  _inherits(LinearInterpolator, _TransitionInterpolat);\n\n  var _super = _createSuper(LinearInterpolator);\n\n  function LinearInterpolator() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LinearInterpolator);\n\n    var transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;\n    _this = _super.call(this, transitionProps || {\n      compare: DEFAULT_PROPS,\n      extract: DEFAULT_PROPS,\n      required: DEFAULT_REQUIRED_PROPS\n    });\n    _this.opts = opts;\n    return _this;\n  }\n\n  _createClass(LinearInterpolator, [{\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var result = _get(_getPrototypeOf(LinearInterpolator.prototype), \"initializeProps\", this).call(this, startProps, endProps);\n\n      var _this$opts = this.opts,\n          makeViewport = _this$opts.makeViewport,\n          around = _this$opts.around;\n\n      if (makeViewport && around) {\n        var startViewport = makeViewport(startProps);\n        var endViewport = makeViewport(endProps);\n        var aroundLngLat = startViewport.unproject(around);\n        result.start.around = around;\n        Object.assign(result.end, {\n          around: endViewport.project(aroundLngLat),\n          aroundLngLat: aroundLngLat,\n          width: endProps.width,\n          height: endProps.height\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      var propsInTransition = {};\n\n      var _iterator = _createForOfIteratorHelper(this._propsToExtract),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (endProps.aroundLngLat) {\n        var viewport = this.opts.makeViewport(_objectSpread(_objectSpread({}, endProps), propsInTransition));\n\n        var _viewport$getMapCente = viewport.getMapCenterByLngLatPosition({\n          lngLat: endProps.aroundLngLat,\n          pos: lerp(startProps.around, endProps.around, t)\n        }),\n            _viewport$getMapCente2 = _slicedToArray(_viewport$getMapCente, 2),\n            longitude = _viewport$getMapCente2[0],\n            latitude = _viewport$getMapCente2[1];\n\n        propsInTransition.longitude = longitude;\n        propsInTransition.latitude = latitude;\n      }\n\n      return propsInTransition;\n    }\n  }]);\n\n  return LinearInterpolator;\n}(TransitionInterpolator);\n\nexport { LinearInterpolator as default };","map":{"version":3,"sources":["../../../src/transitions/linear-interpolator.js"],"names":["DEFAULT_PROPS","DEFAULT_REQUIRED_PROPS","LinearInterpolator","TransitionInterpolator","opts","transitionProps","Array","compare","extract","required","startProps","endProps","result","makeViewport","around","startViewport","endViewport","aroundLngLat","Object","width","height","t","propsInTransition","key","lerp","viewport","longitude","latitude","lngLat","pos"],"mappings":"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","sourcesContent":["import TransitionInterpolator from './transition-interpolator';\nimport {lerp} from 'math.gl';\n\nconst DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];\nconst DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];\n\n/**\n * Performs linear interpolation of two view states.\n */\nexport default class LinearInterpolator extends TransitionInterpolator {\n  /**\n   * @param {Object} opts\n   * @param {Array} opts.transitionProps - list of props to apply linear transition to.\n   * @param {Array} opts.around - a screen point to zoom/rotate around.\n   * @param {Function} opts.makeViewport - construct a viewport instance with given props.\n   */\n  constructor(opts = {}) {\n    // Backward compatibility\n    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;\n    super(\n      transitionProps || {\n        compare: DEFAULT_PROPS,\n        extract: DEFAULT_PROPS,\n        required: DEFAULT_REQUIRED_PROPS\n      }\n    );\n    this.opts = opts;\n  }\n\n  initializeProps(startProps, endProps) {\n    const result = super.initializeProps(startProps, endProps);\n\n    const {makeViewport, around} = this.opts;\n    if (makeViewport && around) {\n      const startViewport = makeViewport(startProps);\n      const endViewport = makeViewport(endProps);\n      const aroundLngLat = startViewport.unproject(around);\n      result.start.around = around;\n      Object.assign(result.end, {\n        around: endViewport.project(aroundLngLat),\n        aroundLngLat,\n        width: endProps.width,\n        height: endProps.height\n      });\n    }\n\n    return result;\n  }\n\n  interpolateProps(startProps, endProps, t) {\n    const propsInTransition = {};\n    for (const key of this._propsToExtract) {\n      propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);\n    }\n\n    if (endProps.aroundLngLat) {\n      // Linear transition should be performed in common space\n      const viewport = this.opts.makeViewport({...endProps, ...propsInTransition});\n      const [longitude, latitude] = viewport.getMapCenterByLngLatPosition({\n        lngLat: endProps.aroundLngLat,\n        // anchor point in current screen coordinates\n        pos: lerp(startProps.around, endProps.around, t)\n      });\n      propsInTransition.longitude = longitude;\n      propsInTransition.latitude = latitude;\n    }\n    return propsInTransition;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}