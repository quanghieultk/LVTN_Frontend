{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { Framebuffer, Texture2D, isWebGL2, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels } from '@luma.gl/core';\nimport assert from '../utils/assert';\nimport log from '../utils/log';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport { getClosestObject, getUniqueObjects } from './picking/query-object';\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from './picking/pick-info';\n\nvar DeckPicker = function () {\n  function DeckPicker(gl) {\n    _classCallCheck(this, DeckPicker);\n\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n    this._onError = null;\n  }\n\n  _createClass(DeckPicker, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('layerFilter' in props) {\n        this.layerFilter = props.layerFilter;\n      }\n\n      if ('onError' in props) {\n        this._onError = props.onError;\n      }\n\n      if ('_pickable' in props) {\n        this._pickable = props._pickable;\n      }\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.pickingFBO) {\n        this.pickingFBO[\"delete\"]();\n      }\n\n      if (this.depthFBO) {\n        this.depthFBO.color[\"delete\"]();\n        this.depthFBO[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"pickObject\",\n    value: function pickObject(opts) {\n      return this._pickClosestObject(opts);\n    }\n  }, {\n    key: \"pickObjects\",\n    value: function pickObjects(opts) {\n      return this._pickVisibleObjects(opts);\n    }\n  }, {\n    key: \"getLastPickedObject\",\n    value: function getLastPickedObject(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          layers = _ref.layers,\n          viewports = _ref.viewports;\n      var lastPickedInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lastPickedInfo.info;\n      var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n      var lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n      var layer = lastPickedLayerId ? layers.find(function (l) {\n        return l.id === lastPickedLayerId;\n      }) : null;\n      var viewport = lastPickedViewportId && viewports.find(function (v) {\n        return v.id === lastPickedViewportId;\n      }) || viewports[0];\n      var coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n      var info = {\n        x: x,\n        y: y,\n        viewport: viewport,\n        coordinate: coordinate,\n        layer: layer\n      };\n\n      if (layer) {\n        return Object.assign({}, lastPickedInfo, info);\n      }\n\n      return Object.assign(info, {\n        color: null,\n        object: null,\n        index: -1\n      });\n    }\n  }, {\n    key: \"_resizeBuffer\",\n    value: function _resizeBuffer() {\n      var gl = this.gl;\n\n      if (!this.pickingFBO) {\n        this.pickingFBO = new Framebuffer(gl);\n\n        if (Framebuffer.isSupported(gl, {\n          colorBufferFloat: true\n        })) {\n          this.depthFBO = new Framebuffer(gl);\n          this.depthFBO.attach(_defineProperty({}, 36064, new Texture2D(gl, {\n            format: isWebGL2(gl) ? 34836 : 6408,\n            type: 5126\n          })));\n        }\n      }\n\n      this.pickingFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n\n      if (this.depthFBO) {\n        this.depthFBO.resize({\n          width: gl.canvas.width,\n          height: gl.canvas.height\n        });\n      }\n\n      return this.pickingFBO;\n    }\n  }, {\n    key: \"_getPickable\",\n    value: function _getPickable(layers) {\n      if (this._pickable === false) {\n        return null;\n      }\n\n      var pickableLayers = layers.filter(function (layer) {\n        return layer.isPickable() && !layer.isComposite;\n      });\n\n      if (pickableLayers.length > 255) {\n        log.warn('Too many pickable layers, only picking the first 255')();\n        return pickableLayers.slice(0, 255);\n      }\n\n      return pickableLayers.length ? pickableLayers : null;\n    }\n  }, {\n    key: \"_pickClosestObject\",\n    value: function _pickClosestObject(_ref2) {\n      var layers = _ref2.layers,\n          views = _ref2.views,\n          viewports = _ref2.viewports,\n          x = _ref2.x,\n          y = _ref2.y,\n          _ref2$radius = _ref2.radius,\n          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,\n          _ref2$depth = _ref2.depth,\n          depth = _ref2$depth === void 0 ? 1 : _ref2$depth,\n          _ref2$mode = _ref2.mode,\n          mode = _ref2$mode === void 0 ? 'query' : _ref2$mode,\n          unproject3D = _ref2.unproject3D,\n          onViewportActive = _ref2.onViewportActive;\n      layers = this._getPickable(layers);\n\n      if (!layers) {\n        return {\n          result: [],\n          emptyInfo: getEmptyPickingInfo({\n            viewports: viewports,\n            x: x,\n            y: y\n          })\n        };\n      }\n\n      this._resizeBuffer();\n\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      var devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n      var devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n      var deviceRadius = Math.round(radius * pixelRatio);\n      var _this$pickingFBO = this.pickingFBO,\n          width = _this$pickingFBO.width,\n          height = _this$pickingFBO.height;\n\n      var deviceRect = this._getPickingRect({\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius: deviceRadius,\n        deviceWidth: width,\n        deviceHeight: height\n      });\n\n      var infos;\n      var result = [];\n      var affectedLayers = {};\n\n      for (var i = 0; i < depth; i++) {\n        var pickedColors = deviceRect && this._drawAndSample({\n          layers: layers,\n          views: views,\n          viewports: viewports,\n          onViewportActive: onViewportActive,\n          deviceRect: deviceRect,\n          pass: \"picking:\".concat(mode),\n          redrawReason: mode\n        });\n\n        var pickInfo = getClosestObject({\n          pickedColors: pickedColors,\n          layers: layers,\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius: deviceRadius,\n          deviceRect: deviceRect\n        });\n        var z = void 0;\n\n        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n          var zValues = this._drawAndSample({\n            layers: [pickInfo.pickedLayer],\n            views: views,\n            viewports: viewports,\n            onViewportActive: onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX,\n              y: pickInfo.pickedY,\n              width: 1,\n              height: 1\n            },\n            pass: \"picking:\".concat(mode),\n            redrawReason: 'pick-z',\n            pickZ: true\n          });\n\n          z = zValues[0] * viewports[0].distanceScales.metersPerUnit[2] + viewports[0].position[2];\n        }\n\n        if (pickInfo.pickedColor && i + 1 < depth) {\n          var layerId = pickInfo.pickedColor[3] - 1;\n          affectedLayers[layerId] = true;\n          layers[layerId].disablePickingIndex(pickInfo.pickedObjectIndex);\n        }\n\n        infos = processPickInfo({\n          pickInfo: pickInfo,\n          lastPickedInfo: this.lastPickedInfo,\n          mode: mode,\n          layers: layers,\n          layerFilter: this.layerFilter,\n          viewports: viewports,\n          x: x,\n          y: y,\n          z: z,\n          pixelRatio: pixelRatio\n        });\n\n        var _iterator = _createForOfIteratorHelper(infos.values()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var info = _step.value;\n\n            if (info.layer) {\n              result.push(info);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!pickInfo.pickedColor) {\n          break;\n        }\n      }\n\n      for (var _layerId in affectedLayers) {\n        layers[_layerId].restorePickingColors();\n      }\n\n      return {\n        result: result,\n        emptyInfo: infos && infos.get(null)\n      };\n    }\n  }, {\n    key: \"_pickVisibleObjects\",\n    value: function _pickVisibleObjects(_ref3) {\n      var layers = _ref3.layers,\n          views = _ref3.views,\n          viewports = _ref3.viewports,\n          x = _ref3.x,\n          y = _ref3.y,\n          _ref3$width = _ref3.width,\n          width = _ref3$width === void 0 ? 1 : _ref3$width,\n          _ref3$height = _ref3.height,\n          height = _ref3$height === void 0 ? 1 : _ref3$height,\n          _ref3$mode = _ref3.mode,\n          mode = _ref3$mode === void 0 ? 'query' : _ref3$mode,\n          _ref3$maxObjects = _ref3.maxObjects,\n          maxObjects = _ref3$maxObjects === void 0 ? null : _ref3$maxObjects,\n          onViewportActive = _ref3.onViewportActive;\n      layers = this._getPickable(layers);\n\n      if (!layers) {\n        return [];\n      }\n\n      this._resizeBuffer();\n\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      var leftTop = cssToDevicePixels(this.gl, [x, y], true);\n      var deviceLeft = leftTop.x;\n      var deviceTop = leftTop.y + leftTop.height;\n      var rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n      var deviceRight = rightBottom.x + rightBottom.width;\n      var deviceBottom = rightBottom.y;\n      var deviceRect = {\n        x: deviceLeft,\n        y: deviceBottom,\n        width: deviceRight - deviceLeft,\n        height: deviceTop - deviceBottom\n      };\n\n      var pickedColors = this._drawAndSample({\n        layers: layers,\n        views: views,\n        viewports: viewports,\n        onViewportActive: onViewportActive,\n        deviceRect: deviceRect,\n        pass: \"picking:\".concat(mode),\n        redrawReason: mode\n      });\n\n      var pickInfos = getUniqueObjects({\n        pickedColors: pickedColors,\n        layers: layers\n      });\n      var uniqueInfos = new Map();\n      var isMaxObjects = Number.isFinite(maxObjects);\n\n      for (var i = 0; i < pickInfos.length; i++) {\n        if (isMaxObjects && uniqueInfos.size >= maxObjects) {\n          break;\n        }\n\n        var pickInfo = pickInfos[i];\n        var info = {\n          color: pickInfo.pickedColor,\n          layer: null,\n          index: pickInfo.pickedObjectIndex,\n          picked: true,\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n          pixelRatio: pixelRatio\n        };\n        info = getLayerPickingInfo({\n          layer: pickInfo.pickedLayer,\n          info: info,\n          mode: mode\n        });\n\n        if (!uniqueInfos.has(info.object)) {\n          uniqueInfos.set(info.object, info);\n        }\n      }\n\n      return Array.from(uniqueInfos.values());\n    }\n  }, {\n    key: \"_drawAndSample\",\n    value: function _drawAndSample(_ref4) {\n      var layers = _ref4.layers,\n          views = _ref4.views,\n          viewports = _ref4.viewports,\n          onViewportActive = _ref4.onViewportActive,\n          deviceRect = _ref4.deviceRect,\n          pass = _ref4.pass,\n          redrawReason = _ref4.redrawReason,\n          pickZ = _ref4.pickZ;\n      assert(deviceRect.width > 0 && deviceRect.height > 0);\n\n      if (layers.length < 1) {\n        return null;\n      }\n\n      var pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n      this.pickLayersPass.render({\n        layers: layers,\n        layerFilter: this.layerFilter,\n        onError: this._onError,\n        views: views,\n        viewports: viewports,\n        onViewportActive: onViewportActive,\n        pickingFBO: pickingFBO,\n        deviceRect: deviceRect,\n        pass: pass,\n        redrawReason: redrawReason,\n        pickZ: pickZ\n      });\n      var x = deviceRect.x,\n          y = deviceRect.y,\n          width = deviceRect.width,\n          height = deviceRect.height;\n      var pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n      readPixelsToArray(pickingFBO, {\n        sourceX: x,\n        sourceY: y,\n        sourceWidth: width,\n        sourceHeight: height,\n        target: pickedColors\n      });\n      return pickedColors;\n    }\n  }, {\n    key: \"_getPickingRect\",\n    value: function _getPickingRect(_ref5) {\n      var deviceX = _ref5.deviceX,\n          deviceY = _ref5.deviceY,\n          deviceRadius = _ref5.deviceRadius,\n          deviceWidth = _ref5.deviceWidth,\n          deviceHeight = _ref5.deviceHeight;\n      var x = Math.max(0, deviceX - deviceRadius);\n      var y = Math.max(0, deviceY - deviceRadius);\n      var width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n      var height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n      if (width <= 0 || height <= 0) {\n        return null;\n      }\n\n      return {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n    }\n  }]);\n\n  return DeckPicker;\n}();\n\nexport { DeckPicker as default };","map":{"version":3,"sources":["../../../src/lib/deck-picker.js"],"names":["DeckPicker","index","layerId","info","props","opts","x","y","layers","viewports","lastPickedInfo","lastPickedLayerId","lastPickedViewportId","layer","l","viewport","v","coordinate","Object","color","object","gl","colorBufferFloat","format","isWebGL2","type","width","height","pickableLayers","log","views","radius","depth","mode","unproject3D","onViewportActive","result","emptyInfo","getEmptyPickingInfo","pixelRatio","cssToDeviceRatio","devicePixelRange","cssToDevicePixels","devicePixel","Math","deviceRadius","deviceRect","deviceX","deviceY","deviceWidth","deviceHeight","affectedLayers","i","pickedColors","pass","redrawReason","pickInfo","getClosestObject","z","zValues","pickZ","infos","processPickInfo","layerFilter","maxObjects","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","getUniqueObjects","uniqueInfos","isMaxObjects","Number","picked","getLayerPickingInfo","Array","assert","pickingFBO","onError","readPixelsToArray","sourceX","sourceY","sourceWidth","sourceHeight","target"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport assert from '../utils/assert';\nimport log from '../utils/log';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects} from './picking/query-object';\nimport {processPickInfo, getLayerPickingInfo, getEmptyPickingInfo} from './picking/pick-info';\n\nexport default class DeckPicker {\n  constructor(gl) {\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.lastPickedInfo = {\n      // For callback tracking and auto highlight\n      index: -1,\n      layerId: null,\n      info: null\n    };\n    this._onError = null;\n  }\n\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('onError' in props) {\n      this._onError = props.onError;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  // Pick the closest info at given coordinate\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n\n  // Get all unique infos within a bounding box\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId =\n      lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport =\n      (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n\n    if (layer) {\n      return Object.assign({}, lastPickedInfo, info);\n    }\n    return Object.assign(info, {color: null, object: null, index: -1});\n  }\n\n  // Private\n  _resizeBuffer() {\n    const {gl} = this;\n\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        this.depthFBO = new Framebuffer(gl);\n        this.depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    if (this.depthFBO) {\n      this.depthFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    }\n    return this.pickingFBO;\n  }\n\n  // picking can only handle up to 255 layers. Drop non-pickable/invisible layers from the list.\n  _getPickable(layers) {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);\n    if (pickableLayers.length > 255) {\n      log.warn('Too many pickable layers, only picking the first 255')();\n      return pickableLayers.slice(0, 255);\n    }\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  // Pick the closest object at the given (x,y) coordinate\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive\n  }) {\n    layers = this._getPickable(layers);\n\n    if (!layers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({viewports, x, y})\n      };\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    let infos;\n    const result = [];\n    const affectedLayers = {};\n\n    for (let i = 0; i < depth; i++) {\n      const pickedColors =\n        deviceRect &&\n        this._drawAndSample({\n          layers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          pass: `picking:${mode}`,\n          redrawReason: mode\n        });\n\n      const pickInfo = getClosestObject({\n        pickedColors,\n        layers,\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius,\n        deviceRect\n      });\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const zValues = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect: {x: pickInfo.pickedX, y: pickInfo.pickedY, width: 1, height: 1},\n          pass: `picking:${mode}`,\n          redrawReason: 'pick-z',\n          pickZ: true\n        });\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        z = zValues[0] * viewports[0].distanceScales.metersPerUnit[2] + viewports[0].position[2];\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedColor && i + 1 < depth) {\n        const layerId = pickInfo.pickedColor[3] - 1;\n        affectedLayers[layerId] = true;\n        layers[layerId].disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers,\n        layerFilter: this.layerFilter,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layerId in affectedLayers) {\n      layers[layerId].restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos && infos.get(null)};\n  }\n\n  // Pick all objects within the given bounding box\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive\n  }) {\n    layers = this._getPickable(layers);\n\n    if (!layers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedColors = this._drawAndSample({\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      pass: `picking:${mode}`,\n      redrawReason: mode\n    });\n\n    const pickInfos = getUniqueObjects({pickedColors, layers});\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        width,\n        height,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  // returns pickedColor or null if no pickable layers found.\n  _drawAndSample({\n    layers,\n    views,\n    viewports,\n    onViewportActive,\n    deviceRect,\n    pass,\n    redrawReason,\n    pickZ\n  }) {\n    assert(deviceRect.width > 0 && deviceRect.height > 0);\n\n    if (layers.length < 1) {\n      return null;\n    }\n\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n    this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      onError: this._onError,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      pass,\n      redrawReason,\n      pickZ\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return pickedColors;\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}