{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar GEOM_TYPES = ['points', 'lines', 'polygons'];\nexport function binaryToFeature(data, featureIdIndex) {\n  if (!data) {\n    return null;\n  }\n\n  var index = data.featureIds.value.indexOf(featureIdIndex);\n\n  if (index !== -1) {\n    return getPropertiesForIndex(data, featureIdIndex, index);\n  }\n\n  return null;\n}\nexport function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  var featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  var geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  var feature = {\n    properties: _objectSpread({}, data.properties[propertiesIndex])\n  };\n\n  for (var prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\nexport function findIndexBinary(data, uniqueIdProperty, featureId) {\n  if (!data) {\n    return -1;\n  }\n\n  var _iterator = _createForOfIteratorHelper(GEOM_TYPES),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var gt = _step.value;\n      var index = findIndexByType(data, uniqueIdProperty, featureId, gt);\n\n      if (index !== -1) {\n        return index;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(data, uniqueIdProperty, featureId, geomType) {\n  if (!data) {\n    return -1;\n  }\n\n  if (!(geomType in data) || !data[geomType].positions.value.length) return -1;\n  var index = -1;\n\n  if (data[geomType].numericProps[uniqueIdProperty]) {\n    index = data[geomType].numericProps[uniqueIdProperty].value.indexOf(featureId);\n  } else {\n    var propertyIndex = data[geomType].properties.findIndex(function (elem) {\n      return elem[uniqueIdProperty] === featureId;\n    });\n    index = data[geomType].featureIds.value.indexOf(propertyIndex);\n  }\n\n  return index;\n}\n\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  var pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n\n  for (var key in pickingColors) {\n    var featureIds = geojsonBinary[key].featureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    var pickingColor = [];\n\n    for (var i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}","map":{"version":3,"sources":["../../../src/geojson-layer/geojson-binary.js"],"names":["GEOM_TYPES","index","data","getPropertiesForIndex","featureIndex","geometryIndex","feature","properties","gt","findIndexByType","geomType","propertyIndex","elem","pickingColors","points","lines","polygons","featureIds","geojsonBinary","pickingColor","i","encodePickingColor"],"mappings":"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","sourcesContent":["// This module implement some utility functions to work with\n// the geojson-binary format defined at loaders.gl:\n// https://github.com/visgl/loaders.gl/blob/master/modules/gis/docs/api-reference/geojson-to-binary.md\n\nconst GEOM_TYPES = ['points', 'lines', 'polygons'];\n\n/**\n * Return the feature for a given featureId index value\n *\n * @param {Object} data - The data in binary format\n * @param {Number} featureIdIndex - The requested picking index\n */\nexport function binaryToFeature(data, featureIdIndex) {\n  if (!data) {\n    return null;\n  }\n\n  const index = data.featureIds.value.indexOf(featureIdIndex);\n\n  if (index !== -1) {\n    return getPropertiesForIndex(data, featureIdIndex, index);\n  }\n\n  return null;\n}\n\n/**\n * Return the feature for an accesor\n *\n * @param {Object} data - The data in binary format\n * @param {Number} index - The requested index\n */\nexport function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: {...data.properties[propertiesIndex]}\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n * @param {Object} data - The data in binary format\n * @param {String} uniqueIdProperty - Name of the unique id property\n * @param {Number} featureId - feature id to find\n */\nexport function findIndexBinary(data, uniqueIdProperty, featureId) {\n  if (!data) {\n    return -1;\n  }\n\n  for (const gt of GEOM_TYPES) {\n    const index = findIndexByType(data, uniqueIdProperty, featureId, gt);\n    if (index !== -1) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(data, uniqueIdProperty, featureId, geomType) {\n  if (!data) {\n    return -1;\n  }\n\n  if (!(geomType in data) || !data[geomType].positions.value.length) return -1;\n\n  // Look for the uniqueIdProperty\n  let index = -1;\n  if (data[geomType].numericProps[uniqueIdProperty]) {\n    index = data[geomType].numericProps[uniqueIdProperty].value.indexOf(featureId);\n  } else {\n    const propertyIndex = data[geomType].properties.findIndex(\n      elem => elem[uniqueIdProperty] === featureId\n    );\n    index = data[geomType].featureIds.value.indexOf(propertyIndex);\n  }\n\n  return index;\n}\n\n// Custom picking color to keep binary indexes\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].featureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n"]},"metadata":{},"sourceType":"module"}