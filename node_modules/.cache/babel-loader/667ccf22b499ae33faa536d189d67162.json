{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, { DEFAULT_CHAR_SET, DEFAULT_FONT_FAMILY, DEFAULT_FONT_WEIGHT, DEFAULT_FONT_SIZE, DEFAULT_BUFFER, DEFAULT_RADIUS, DEFAULT_CUTOFF } from './font-atlas-manager';\nimport { transformParagraph, getTextFromBuffer } from './utils';\nvar DEFAULT_FONT_SETTINGS = {\n  fontSize: DEFAULT_FONT_SIZE,\n  buffer: DEFAULT_BUFFER,\n  sdf: false,\n  radius: DEFAULT_RADIUS,\n  cutoff: DEFAULT_CUTOFF\n};\nvar TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\nvar ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar DEFAULT_LINE_HEIGHT = 1.0;\nvar FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];\nvar defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  backgroundColor: {\n    type: 'color',\n    value: null,\n    optional: true\n  },\n  characterSet: DEFAULT_CHAR_SET,\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontWeight: DEFAULT_FONT_WEIGHT,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  fontSettings: {},\n  wordBreak: 'break-word',\n  maxWidth: {\n    type: 'number',\n    value: -1\n  },\n  getText: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.text;\n    }\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 32\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getTextAnchor: {\n    type: 'accessor',\n    value: 'middle'\n  },\n  getAlignmentBaseline: {\n    type: 'accessor',\n    value: 'center'\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\n\nvar TextLayer = function (_CompositeLayer) {\n  _inherits(TextLayer, _CompositeLayer);\n\n  var _super = _createSuper(TextLayer);\n\n  function TextLayer() {\n    _classCallCheck(this, TextLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TextLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        styleVersion: 0,\n        fontAtlasManager: new FontAtlasManager()\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      var fontChanged = this._fontChanged(oldProps, props);\n\n      if (fontChanged) {\n        this._updateFontAtlas(oldProps, props);\n      }\n\n      var styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;\n      var textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);\n\n      if (textChanged) {\n        this._updateText();\n      }\n\n      if (styleChanged) {\n        this.setState({\n          styleVersion: this.state.styleVersion + 1\n        });\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info;\n      return Object.assign(info, {\n        object: info.index >= 0 ? this.props.data[info.index] : null\n      });\n    }\n  }, {\n    key: \"_updateFontAtlas\",\n    value: function _updateFontAtlas(oldProps, props) {\n      var characterSet = props.characterSet,\n          fontSettings = props.fontSettings,\n          fontFamily = props.fontFamily,\n          fontWeight = props.fontWeight;\n      var fontAtlasManager = this.state.fontAtlasManager;\n      fontAtlasManager.setProps(Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {\n        characterSet: characterSet,\n        fontFamily: fontFamily,\n        fontWeight: fontWeight\n      }));\n      this.setNeedsRedraw(true);\n    }\n  }, {\n    key: \"_fontChanged\",\n    value: function _fontChanged(oldProps, props) {\n      if (oldProps.fontFamily !== props.fontFamily || oldProps.characterSet !== props.characterSet || oldProps.fontWeight !== props.fontWeight) {\n        return true;\n      }\n\n      if (oldProps.fontSettings === props.fontSettings) {\n        return false;\n      }\n\n      var oldFontSettings = oldProps.fontSettings || {};\n      var fontSettings = props.fontSettings || {};\n      return FONT_SETTINGS_PROPS.some(function (prop) {\n        return oldFontSettings[prop] !== fontSettings[prop];\n      });\n    }\n  }, {\n    key: \"_updateText\",\n    value: function _updateText() {\n      var data = this.props.data;\n      var textBuffer = data.attributes && data.attributes.getText;\n      var getText = this.props.getText;\n      var startIndices = data.startIndices;\n      var numInstances;\n\n      if (textBuffer && startIndices) {\n        var _getTextFromBuffer = getTextFromBuffer(_objectSpread(_objectSpread({}, ArrayBuffer.isView(textBuffer) ? {\n          value: textBuffer\n        } : textBuffer), {}, {\n          length: data.length,\n          startIndices: startIndices\n        })),\n            texts = _getTextFromBuffer.texts,\n            characterCount = _getTextFromBuffer.characterCount;\n\n        numInstances = characterCount;\n\n        getText = function getText(_, _ref3) {\n          var index = _ref3.index;\n          return texts[index];\n        };\n      } else {\n        var _createIterable = createIterable(data),\n            iterable = _createIterable.iterable,\n            objectInfo = _createIterable.objectInfo;\n\n        startIndices = [0];\n        numInstances = 0;\n\n        var _iterator = _createForOfIteratorHelper(iterable),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var object = _step.value;\n            objectInfo.index++;\n            var text = getText(object, objectInfo) || '';\n            numInstances += Array.from(text).length;\n            startIndices.push(numInstances);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      this.setState({\n        getText: getText,\n        startIndices: startIndices,\n        numInstances: numInstances\n      });\n    }\n  }, {\n    key: \"getIconOffsets\",\n    value: function getIconOffsets(object, objectInfo) {\n      var iconMapping = this.state.fontAtlasManager.mapping;\n      var getText = this.state.getText;\n      var _this$props = this.props,\n          wordBreak = _this$props.wordBreak,\n          maxWidth = _this$props.maxWidth,\n          lineHeight = _this$props.lineHeight,\n          getTextAnchor = _this$props.getTextAnchor,\n          getAlignmentBaseline = _this$props.getAlignmentBaseline;\n      var paragraph = getText(object, objectInfo) || '';\n\n      var _transformParagraph = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping),\n          x = _transformParagraph.x,\n          y = _transformParagraph.y,\n          rowWidth = _transformParagraph.rowWidth,\n          _transformParagraph$s = _slicedToArray(_transformParagraph.size, 2),\n          width = _transformParagraph$s[0],\n          height = _transformParagraph$s[1];\n\n      var anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];\n      var anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];\n      var numCharacters = x.length;\n      var offsets = new Array(numCharacters * 2);\n      var index = 0;\n\n      for (var i = 0; i < numCharacters; i++) {\n        var rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;\n        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];\n        offsets[index++] = (anchorY - 1) * height / 2 + y[i];\n      }\n\n      return offsets;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$state = this.state,\n          startIndices = _this$state.startIndices,\n          numInstances = _this$state.numInstances,\n          getText = _this$state.getText,\n          _this$state$fontAtlas = _this$state.fontAtlasManager,\n          scale = _this$state$fontAtlas.scale,\n          texture = _this$state$fontAtlas.texture,\n          mapping = _this$state$fontAtlas.mapping,\n          styleVersion = _this$state.styleVersion;\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          _dataDiff = _this$props2._dataDiff,\n          backgroundColor = _this$props2.backgroundColor,\n          getPosition = _this$props2.getPosition,\n          getColor = _this$props2.getColor,\n          getSize = _this$props2.getSize,\n          getAngle = _this$props2.getAngle,\n          getPixelOffset = _this$props2.getPixelOffset,\n          billboard = _this$props2.billboard,\n          fontSettings = _this$props2.fontSettings,\n          sizeScale = _this$props2.sizeScale,\n          sizeUnits = _this$props2.sizeUnits,\n          sizeMinPixels = _this$props2.sizeMinPixels,\n          sizeMaxPixels = _this$props2.sizeMaxPixels,\n          transitions = _this$props2.transitions,\n          updateTriggers = _this$props2.updateTriggers;\n      var getIconOffsets = this.getIconOffsets.bind(this);\n      var SubLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n      return new SubLayerClass({\n        sdf: fontSettings.sdf,\n        iconAtlas: texture,\n        iconMapping: mapping,\n        backgroundColor: backgroundColor,\n        getPosition: getPosition,\n        getColor: getColor,\n        getSize: getSize,\n        getAngle: getAngle,\n        getPixelOffset: getPixelOffset,\n        billboard: billboard,\n        sizeScale: sizeScale * scale,\n        sizeUnits: sizeUnits,\n        sizeMinPixels: sizeMinPixels * scale,\n        sizeMaxPixels: sizeMaxPixels * scale,\n        transitions: transitions && {\n          getPosition: transitions.getPosition,\n          getAngle: transitions.getAngle,\n          getColor: transitions.getColor,\n          getSize: transitions.getSize,\n          getPixelOffset: transitions.getPixelOffset\n        }\n      }, this.getSubLayerProps({\n        id: 'characters',\n        updateTriggers: {\n          getIcon: updateTriggers.getText,\n          getPosition: updateTriggers.getPosition,\n          getAngle: updateTriggers.getAngle,\n          getColor: updateTriggers.getColor,\n          getSize: updateTriggers.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset,\n          getIconOffsets: {\n            getText: updateTriggers.getText,\n            getTextAnchor: updateTriggers.getTextAnchor,\n            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n            styleVersion: styleVersion\n          }\n        }\n      }), {\n        data: data,\n        _dataDiff: _dataDiff,\n        startIndices: startIndices,\n        numInstances: numInstances,\n        getIconOffsets: getIconOffsets,\n        getIcon: getText\n      });\n    }\n  }]);\n\n  return TextLayer;\n}(CompositeLayer);\n\nexport { TextLayer as default };\nTextLayer.layerName = 'TextLayer';\nTextLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/text-layer/text-layer.js"],"names":["DEFAULT_FONT_SETTINGS","fontSize","buffer","sdf","radius","cutoff","DEFAULT_CUTOFF","TEXT_ANCHOR","start","middle","end","ALIGNMENT_BASELINE","top","center","bottom","DEFAULT_COLOR","DEFAULT_LINE_HEIGHT","FONT_SETTINGS_PROPS","defaultProps","billboard","sizeScale","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","backgroundColor","type","value","optional","characterSet","fontFamily","fontWeight","lineHeight","fontSettings","wordBreak","maxWidth","getText","x","getPosition","getColor","getSize","getAngle","getTextAnchor","getAlignmentBaseline","getPixelOffset","TextLayer","CompositeLayer","styleVersion","fontAtlasManager","props","oldProps","changeFlags","fontChanged","styleChanged","textChanged","info","object","oldFontSettings","data","textBuffer","startIndices","texts","characterCount","getTextFromBuffer","length","numInstances","index","iterable","objectInfo","createIterable","text","Array","iconMapping","paragraph","y","rowWidth","width","height","transformParagraph","anchorX","anchorY","numCharacters","offsets","i","rowOffset","scale","texture","mapping","_dataDiff","transitions","updateTriggers","getIconOffsets","SubLayerClass","iconAtlas","id","getIcon"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, {\n  DEFAULT_CHAR_SET,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_WEIGHT,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_BUFFER,\n  DEFAULT_RADIUS,\n  DEFAULT_CUTOFF\n} from './font-atlas-manager';\nimport {transformParagraph, getTextFromBuffer} from './utils';\n\nconst DEFAULT_FONT_SETTINGS = {\n  fontSize: DEFAULT_FONT_SIZE,\n  buffer: DEFAULT_BUFFER,\n  sdf: false,\n  radius: DEFAULT_RADIUS,\n  cutoff: DEFAULT_CUTOFF\n};\n\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\n\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst DEFAULT_LINE_HEIGHT = 1.0;\n\nconst FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];\n\nconst defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  backgroundColor: {type: 'color', value: null, optional: true},\n\n  characterSet: DEFAULT_CHAR_SET,\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontWeight: DEFAULT_FONT_WEIGHT,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  fontSettings: {},\n\n  // auto wrapping options\n  wordBreak: 'break-word',\n  maxWidth: {type: 'number', value: -1},\n\n  getText: {type: 'accessor', value: x => x.text},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 32},\n  getAngle: {type: 'accessor', value: 0},\n  getTextAnchor: {type: 'accessor', value: 'middle'},\n  getAlignmentBaseline: {type: 'accessor', value: 'center'},\n  getPixelOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class TextLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager()\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  updateState({props, oldProps, changeFlags}) {\n    const fontChanged = this._fontChanged(oldProps, props);\n\n    if (fontChanged) {\n      this._updateFontAtlas(oldProps, props);\n    }\n\n    const styleChanged =\n      fontChanged ||\n      props.lineHeight !== oldProps.lineHeight ||\n      props.wordBreak !== oldProps.wordBreak ||\n      props.maxWidth !== oldProps.maxWidth;\n\n    const textChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText));\n\n    if (textChanged) {\n      this._updateText();\n    }\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  getPickingInfo({info}) {\n    // because `TextLayer` assign the same pickingInfoIndex for one text label,\n    // here info.index refers the index of text label in props.data\n    return Object.assign(info, {\n      // override object with original data\n      object: info.index >= 0 ? this.props.data[info.index] : null\n    });\n  }\n\n  _updateFontAtlas(oldProps, props) {\n    const {characterSet, fontSettings, fontFamily, fontWeight} = props;\n\n    // generate test characterSet\n    const {fontAtlasManager} = this.state;\n    fontAtlasManager.setProps(\n      Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {\n        characterSet,\n        fontFamily,\n        fontWeight\n      })\n    );\n\n    this.setNeedsRedraw(true);\n  }\n\n  _fontChanged(oldProps, props) {\n    if (\n      oldProps.fontFamily !== props.fontFamily ||\n      oldProps.characterSet !== props.characterSet ||\n      oldProps.fontWeight !== props.fontWeight\n    ) {\n      return true;\n    }\n\n    if (oldProps.fontSettings === props.fontSettings) {\n      return false;\n    }\n\n    const oldFontSettings = oldProps.fontSettings || {};\n    const fontSettings = props.fontSettings || {};\n\n    return FONT_SETTINGS_PROPS.some(prop => oldFontSettings[prop] !== fontSettings[prop]);\n  }\n\n  // Text strings are variable width objects\n  // Returns the index at the start of each string (every character is rendered by one instance)\n  _updateText() {\n    const {data} = this.props;\n    const textBuffer = data.attributes && data.attributes.getText;\n    let {getText} = this.props;\n    let {startIndices} = data;\n    let numInstances;\n\n    if (textBuffer && startIndices) {\n      const {texts, characterCount} = getTextFromBuffer({\n        ...(ArrayBuffer.isView(textBuffer) ? {value: textBuffer} : textBuffer),\n        length: data.length,\n        startIndices\n      });\n      numInstances = characterCount;\n      getText = (_, {index}) => texts[index];\n    } else {\n      const {iterable, objectInfo} = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        const text = getText(object, objectInfo) || '';\n        // When dealing with double-length unicode characters, `str.length` is incorrect\n        numInstances += Array.from(text).length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({getText, startIndices, numInstances});\n  }\n\n  // Returns the x, y offsets of each character in a text string\n  getIconOffsets(object, objectInfo) {\n    const iconMapping = this.state.fontAtlasManager.mapping;\n    const {getText} = this.state;\n    const {wordBreak, maxWidth, lineHeight, getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    const {\n      x,\n      y,\n      rowWidth,\n      size: [width, height]\n    } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    const numCharacters = x.length;\n    const offsets = new Array(numCharacters * 2);\n    let index = 0;\n\n    for (let i = 0; i < numCharacters; i++) {\n      // For a multi-line object, offset in x-direction needs consider\n      // the row offset in the paragraph and the object offset in the row\n      const rowOffset = ((1 - anchorX) * (width - rowWidth[i])) / 2;\n      offsets[index++] = ((anchorX - 1) * width) / 2 + rowOffset + x[i];\n      offsets[index++] = ((anchorY - 1) * height) / 2 + y[i];\n    }\n    return offsets;\n  }\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {scale, texture, mapping},\n      styleVersion\n    } = this.state;\n\n    const {\n      data,\n      _dataDiff,\n      backgroundColor,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      fontSettings,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    const getIconOffsets = this.getIconOffsets.bind(this);\n\n    const SubLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n\n    return new SubLayerClass(\n      {\n        sdf: fontSettings.sdf,\n        iconAtlas: texture,\n        iconMapping: mapping,\n        backgroundColor,\n\n        getPosition,\n        getColor,\n        getSize,\n        getAngle,\n        getPixelOffset,\n\n        billboard,\n        sizeScale: sizeScale * scale,\n        sizeUnits,\n        sizeMinPixels: sizeMinPixels * scale,\n        sizeMaxPixels: sizeMaxPixels * scale,\n\n        transitions: transitions && {\n          getPosition: transitions.getPosition,\n          getAngle: transitions.getAngle,\n          getColor: transitions.getColor,\n          getSize: transitions.getSize,\n          getPixelOffset: transitions.getPixelOffset\n        }\n      },\n      this.getSubLayerProps({\n        id: 'characters',\n        updateTriggers: {\n          getIcon: updateTriggers.getText,\n          getPosition: updateTriggers.getPosition,\n          getAngle: updateTriggers.getAngle,\n          getColor: updateTriggers.getColor,\n          getSize: updateTriggers.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset,\n          getIconOffsets: {\n            getText: updateTriggers.getText,\n            getTextAnchor: updateTriggers.getTextAnchor,\n            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n            styleVersion\n          }\n        }\n      }),\n      {\n        data,\n        _dataDiff,\n        startIndices,\n        numInstances,\n        getIconOffsets,\n        getIcon: getText\n      }\n    );\n  }\n}\n\nTextLayer.layerName = 'TextLayer';\nTextLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}