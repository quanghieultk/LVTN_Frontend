{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport Tile2DHeader from './tile-2d-header';\nimport { getTileIndices as _getTileIndices, tileToBoundingBox } from './utils';\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4 } from 'math.gl';\nvar TILE_STATE_UNKNOWN = 0;\nvar TILE_STATE_VISIBLE = 1;\nvar TILE_STATE_PLACEHOLDER = 3;\nvar TILE_STATE_HIDDEN = 4;\nvar TILE_STATE_SELECTED = 5;\nexport var STRATEGY_NEVER = 'never';\nexport var STRATEGY_REPLACE = 'no-overlap';\nexport var STRATEGY_DEFAULT = 'best-available';\nvar DEFAULT_CACHE_SCALE = 5;\n\nvar Tileset2D = function () {\n  function Tileset2D(opts) {\n    var _this = this;\n\n    _classCallCheck(this, Tileset2D);\n\n    this.opts = opts;\n    this._getTileData = opts.getTileData;\n    this.onTileError = opts.onTileError;\n\n    this.onTileLoad = function (tile) {\n      opts.onTileLoad(tile);\n\n      if (_this.opts.maxCacheByteSize) {\n        _this._cacheByteSize += tile.byteLength;\n\n        _this._resizeCache();\n      }\n    };\n\n    this.onTileUnload = opts.onTileUnload;\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this.setOptions(opts);\n  }\n\n  _createClass(Tileset2D, [{\n    key: \"setOptions\",\n    value: function setOptions(opts) {\n      Object.assign(this.opts, opts);\n\n      if (Number.isFinite(opts.maxZoom)) {\n        this._maxZoom = Math.floor(opts.maxZoom);\n      }\n\n      if (Number.isFinite(opts.minZoom)) {\n        this._minZoom = Math.ceil(opts.minZoom);\n      }\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      var _iterator = _createForOfIteratorHelper(this._cache.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var tile = _step.value;\n\n          if (tile.isLoading) {\n            tile.abort();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(viewport) {\n      var _this2 = this;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          zRange = _ref.zRange,\n          modelMatrix = _ref.modelMatrix;\n\n      var modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n      var isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n\n      if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n        if (isModelMatrixNew) {\n          this._modelMatrixInverse = modelMatrix && modelMatrixAsMatrix4.clone().invert();\n          this._modelMatrix = modelMatrix && modelMatrixAsMatrix4;\n        }\n\n        this._viewport = viewport;\n        var tileIndices = this.getTileIndices({\n          viewport: viewport,\n          maxZoom: this._maxZoom,\n          minZoom: this._minZoom,\n          zRange: zRange,\n          modelMatrix: this._modelMatrix,\n          modelMatrixInverse: this._modelMatrixInverse\n        });\n        this._selectedTiles = tileIndices.map(function (index) {\n          return _this2._getTile(index, true);\n        });\n\n        if (this._dirty) {\n          this._rebuildTree();\n        }\n      }\n\n      var changed = this.updateTileStates();\n\n      if (this._dirty) {\n        this._resizeCache();\n      }\n\n      if (changed) {\n        this._frameNumber++;\n      }\n\n      return this._frameNumber;\n    }\n  }, {\n    key: \"getTileIndices\",\n    value: function getTileIndices(_ref2) {\n      var viewport = _ref2.viewport,\n          maxZoom = _ref2.maxZoom,\n          minZoom = _ref2.minZoom,\n          zRange = _ref2.zRange,\n          modelMatrix = _ref2.modelMatrix,\n          modelMatrixInverse = _ref2.modelMatrixInverse;\n      var _this$opts = this.opts,\n          tileSize = _this$opts.tileSize,\n          extent = _this$opts.extent;\n      return _getTileIndices({\n        viewport: viewport,\n        maxZoom: maxZoom,\n        minZoom: minZoom,\n        zRange: zRange,\n        tileSize: tileSize,\n        extent: extent,\n        modelMatrix: modelMatrix,\n        modelMatrixInverse: modelMatrixInverse\n      });\n    }\n  }, {\n    key: \"getTileMetadata\",\n    value: function getTileMetadata(_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          z = _ref3.z;\n      return {\n        bbox: tileToBoundingBox(this._viewport, x, y, z)\n      };\n    }\n  }, {\n    key: \"getParentIndex\",\n    value: function getParentIndex(tileIndex) {\n      tileIndex.x = Math.floor(tileIndex.x / 2);\n      tileIndex.y = Math.floor(tileIndex.y / 2);\n      tileIndex.z -= 1;\n      return tileIndex;\n    }\n  }, {\n    key: \"updateTileStates\",\n    value: function updateTileStates() {\n      this._updateTileStates(this.selectedTiles);\n\n      var maxRequests = this.opts.maxRequests;\n      var abortCandidates = [];\n      var ongoingRequestCount = 0;\n      var changed = false;\n\n      var _iterator2 = _createForOfIteratorHelper(this._cache.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _tile = _step2.value;\n          var isVisible = Boolean(_tile.state & TILE_STATE_VISIBLE);\n\n          if (_tile.isVisible !== isVisible) {\n            changed = true;\n            _tile.isVisible = isVisible;\n          }\n\n          _tile.isSelected = _tile.state === TILE_STATE_SELECTED;\n\n          if (_tile.isLoading) {\n            ongoingRequestCount++;\n\n            if (!_tile.isSelected) {\n              abortCandidates.push(_tile);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (maxRequests > 0) {\n        while (ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n          var tile = abortCandidates.shift();\n          tile.abort();\n          ongoingRequestCount--;\n        }\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"_rebuildTree\",\n    value: function _rebuildTree() {\n      var _cache = this._cache;\n\n      var _iterator3 = _createForOfIteratorHelper(_cache.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var tile = _step3.value;\n          tile.parent = null;\n          tile.children.length = 0;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(_cache.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _tile2 = _step4.value;\n\n          var parent = this._getNearestAncestor(_tile2.x, _tile2.y, _tile2.z);\n\n          _tile2.parent = parent;\n\n          if (parent) {\n            parent.children.push(_tile2);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_updateTileStates\",\n    value: function _updateTileStates(selectedTiles) {\n      var _cache = this._cache;\n      var refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n      var _iterator5 = _createForOfIteratorHelper(_cache.values()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var tile = _step5.value;\n          tile.state = TILE_STATE_UNKNOWN;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(selectedTiles),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _tile3 = _step6.value;\n          _tile3.state = TILE_STATE_SELECTED;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (refinementStrategy === STRATEGY_NEVER) {\n        return;\n      }\n\n      var _iterator7 = _createForOfIteratorHelper(selectedTiles),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _tile4 = _step7.value;\n          getPlaceholderInAncestors(_tile4, refinementStrategy);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(selectedTiles),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _tile5 = _step8.value;\n\n          if (needsPlaceholder(_tile5)) {\n            getPlaceholderInChildren(_tile5);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"_resizeCache\",\n    value: function _resizeCache() {\n      var _cache = this._cache,\n          opts = this.opts;\n      var maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n      var maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n      var overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n      if (overflown) {\n        var _iterator9 = _createForOfIteratorHelper(_cache),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var _step9$value = _slicedToArray(_step9.value, 2),\n                tileId = _step9$value[0],\n                tile = _step9$value[1];\n\n            if (!tile.isVisible) {\n              this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n\n              _cache[\"delete\"](tileId);\n\n              this.onTileUnload(tile);\n            }\n\n            if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        this._rebuildTree();\n\n        this._dirty = true;\n      }\n\n      if (this._dirty) {\n        this._tiles = Array.from(this._cache.values()).sort(function (t1, t2) {\n          return t1.z - t2.z;\n        });\n        this._dirty = false;\n      }\n    }\n  }, {\n    key: \"_getTile\",\n    value: function _getTile(_ref4, create) {\n      var x = _ref4.x,\n          y = _ref4.y,\n          z = _ref4.z;\n      var tileId = \"\".concat(x, \",\").concat(y, \",\").concat(z);\n\n      var tile = this._cache.get(tileId);\n\n      if (!tile && create) {\n        tile = new Tile2DHeader({\n          x: x,\n          y: y,\n          z: z,\n          onTileLoad: this.onTileLoad,\n          onTileError: this.onTileError\n        });\n        Object.assign(tile, this.getTileMetadata(tile));\n        tile.loadData(this._getTileData, this._requestScheduler);\n\n        this._cache.set(tileId, tile);\n\n        this._dirty = true;\n      } else if (tile && tile.isCancelled && !tile.isLoading) {\n        tile.loadData(this._getTileData, this._requestScheduler);\n      }\n\n      return tile;\n    }\n  }, {\n    key: \"_getNearestAncestor\",\n    value: function _getNearestAncestor(x, y, z) {\n      var _this$_minZoom = this._minZoom,\n          _minZoom = _this$_minZoom === void 0 ? 0 : _this$_minZoom;\n\n      var index = {\n        x: x,\n        y: y,\n        z: z\n      };\n\n      while (index.z > _minZoom) {\n        index = this.getParentIndex(index);\n\n        var parent = this._getTile(index);\n\n        if (parent) {\n          return parent;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"tiles\",\n    get: function get() {\n      return this._tiles;\n    }\n  }, {\n    key: \"selectedTiles\",\n    get: function get() {\n      return this._selectedTiles;\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this._selectedTiles.every(function (tile) {\n        return tile.isLoaded;\n      });\n    }\n  }]);\n\n  return Tileset2D;\n}();\n\nexport { Tileset2D as default };\n\nfunction needsPlaceholder(tile) {\n  var t = tile;\n\n  while (t) {\n    if (t.state & TILE_STATE_VISIBLE === 0) {\n      return true;\n    }\n\n    if (t.isLoaded) {\n      return false;\n    }\n\n    t = t.parent;\n  }\n\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  var parent;\n  var state = TILE_STATE_PLACEHOLDER;\n\n  while (parent = tile.parent) {\n    if (tile.isLoaded) {\n      state = TILE_STATE_HIDDEN;\n\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\nfunction getPlaceholderInChildren(tile) {\n  var _iterator10 = _createForOfIteratorHelper(tile.children),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var child = _step10.value;\n      child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n\n      if (!child.isLoaded) {\n        getPlaceholderInChildren(child);\n      }\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n}","map":{"version":3,"sources":["../../../src/tile-layer/tileset-2d.js"],"names":["getTileIndices","TILE_STATE_UNKNOWN","TILE_STATE_VISIBLE","TILE_STATE_PLACEHOLDER","TILE_STATE_HIDDEN","TILE_STATE_SELECTED","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","Tileset2D","opts","tile","maxRequests","throttleRequests","Object","Number","Math","viewport","zRange","modelMatrix","modelMatrixAsMatrix4","isModelMatrixNew","tileIndices","maxZoom","minZoom","modelMatrixInverse","_modelMatrixInverse","changed","tileSize","extent","x","y","z","bbox","tileToBoundingBox","tileIndex","abortCandidates","ongoingRequestCount","isVisible","Boolean","_cache","parent","selectedTiles","refinementStrategy","getPlaceholderInAncestors","needsPlaceholder","getPlaceholderInChildren","maxCacheSize","maxCacheByteSize","overflown","tileId","t1","t2","create","onTileLoad","onTileError","_minZoom","index","t","state","child"],"mappings":"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","sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4} from 'math.gl';\n\nconst TILE_STATE_UNKNOWN = 0;\nconst TILE_STATE_VISIBLE = 1;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nconst TILE_STATE_PLACEHOLDER = 3;\nconst TILE_STATE_HIDDEN = 4;\n// tiles that should be displayed in the current viewport\nconst TILE_STATE_SELECTED = 5;\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n    this._getTileData = opts.getTileData;\n\n    this.onTileError = opts.onTileError;\n    this.onTileLoad = tile => {\n      opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n    this.onTileUnload = opts.onTileUnload;\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   * @param {*} modelMatrix\n   */\n  update(viewport, {zRange, modelMatrix} = {}) {\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrix && modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrix && modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse}) {\n    const {tileSize, extent} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent,\n      modelMatrix,\n      modelMatrixInverse\n    });\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    return {bbox: tileToBoundingBox(this._viewport, x, y, z)};\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    this._updateTileStates(this.selectedTiles);\n\n    const {maxRequests} = this.opts;\n\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    let changed = false;\n    for (const tile of this._cache.values()) {\n      const isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n      if (tile.isVisible !== isVisible) {\n        changed = true;\n        tile.isVisible = isVisible;\n      }\n\n      // isSelected used in request scheduler\n      tile.isSelected = tile.state === TILE_STATE_SELECTED;\n\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    if (maxRequests > 0) {\n      while (ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n        // There are too many ongoing requests, so abort some that are unselected\n        const tile = abortCandidates.shift();\n        tile.abort();\n        ongoingRequestCount--;\n      }\n    }\n\n    return changed;\n  }\n\n  /* Private methods */\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  // A selected tile is always visible.\n  // Never show two overlapping tiles.\n  // If a selected tile is loading, try showing a cached ancester with the closest z\n  // If a selected tile is loading, and no ancester is shown - try showing cached\n  // descendants with the closest z\n  _updateTileStates(selectedTiles) {\n    const {_cache} = this;\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.state = TILE_STATE_UNKNOWN;\n    }\n\n    // For all the selected && pending tiles:\n    // - pick the closest ancestor as placeholder\n    // - if no ancestor is visible, pick the closest children as placeholder\n    for (const tile of selectedTiles) {\n      tile.state = TILE_STATE_SELECTED;\n    }\n\n    if (refinementStrategy === STRATEGY_NEVER) {\n      return;\n    }\n    for (const tile of selectedTiles) {\n      getPlaceholderInAncestors(tile, refinementStrategy);\n    }\n    for (const tile of selectedTiles) {\n      if (needsPlaceholder(tile)) {\n        getPlaceholderInChildren(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n          this.onTileUnload(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({\n        x,\n        y,\n        z,\n        onTileLoad: this.onTileLoad,\n        onTileError: this.onTileError\n      });\n      Object.assign(tile, this.getTileMetadata(tile));\n      tile.loadData(this._getTileData, this._requestScheduler);\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    } else if (tile && tile.isCancelled && !tile.isLoading) {\n      tile.loadData(this._getTileData, this._requestScheduler);\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n// A selected tile needs placeholder from its children if\n// - it is not loaded\n// - none of its ancestors is visible and loaded\nfunction needsPlaceholder(tile) {\n  let t = tile;\n  while (t) {\n    if (t.state & (TILE_STATE_VISIBLE === 0)) {\n      return true;\n    }\n    if (t.isLoaded) {\n      return false;\n    }\n    t = t.parent;\n  }\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  let parent;\n  let state = TILE_STATE_PLACEHOLDER;\n  while ((parent = tile.parent)) {\n    if (tile.isLoaded) {\n      // If a tile is loaded, mark all its ancestors as hidden\n      state = TILE_STATE_HIDDEN;\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n    if (!child.isLoaded) {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}