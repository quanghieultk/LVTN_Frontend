{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { Layer, project32, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport createMesh from './create-mesh';\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\nvar defaultProps = {\n  image: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  }\n};\n\nvar BitmapLayer = function (_Layer) {\n  _inherits(BitmapLayer, _Layer);\n\n  var _super = _createSuper(BitmapLayer);\n\n  function BitmapLayer() {\n    _classCallCheck(this, BitmapLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(BitmapLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(BitmapLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: [project32, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var attributeManager = this.getAttributeManager();\n      attributeManager.remove(['instancePickingColors']);\n      var noAlloc = true;\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.indices;\n          },\n          noAlloc: noAlloc\n        },\n        positions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.positions;\n          },\n          noAlloc: noAlloc\n        },\n        texCoords: {\n          size: 2,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.texCoords;\n          },\n          noAlloc: noAlloc\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.extensionsChanged) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model[\"delete\"]();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n\n      var attributeManager = this.getAttributeManager();\n\n      if (props.bounds !== oldProps.bounds) {\n        var oldMesh = this.state.mesh;\n\n        var mesh = this._createMesh();\n\n        this.state.model.setVertexCount(mesh.vertexCount);\n\n        for (var key in mesh) {\n          if (oldMesh && oldMesh[key] !== mesh[key]) {\n            attributeManager.invalidate(key);\n          }\n        }\n\n        this.setState(_objectSpread({\n          mesh: mesh\n        }, this._getCoordinateUniforms()));\n      } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n        this.setState(this._getCoordinateUniforms());\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info;\n      var image = this.props.image;\n\n      if (!info.color || !image) {\n        info.bitmap = null;\n        return info;\n      }\n\n      var width = image.width,\n          height = image.height;\n      info.index = 0;\n      var uv = unpackUVsFromRGB(info.color);\n      var pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];\n      info.bitmap = {\n        size: {\n          width: width,\n          height: height\n        },\n        uv: uv,\n        pixel: pixel\n      };\n      return info;\n    }\n  }, {\n    key: \"disablePickingIndex\",\n    value: function disablePickingIndex() {\n      this.setState({\n        disablePicking: true\n      });\n    }\n  }, {\n    key: \"restorePickingColors\",\n    value: function restorePickingColors() {\n      this.setState({\n        disablePicking: false\n      });\n    }\n  }, {\n    key: \"_createMesh\",\n    value: function _createMesh() {\n      var bounds = this.props.bounds;\n      var normalizedBounds = bounds;\n\n      if (Number.isFinite(bounds[0])) {\n        normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n      }\n\n      return createMesh(normalizedBounds, this.context.viewport.resolution);\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      if (!gl) {\n        return null;\n      }\n\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 4,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      }));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(opts) {\n      var uniforms = opts.uniforms,\n          moduleParameters = opts.moduleParameters;\n      var _this$state = this.state,\n          model = _this$state.model,\n          coordinateConversion = _this$state.coordinateConversion,\n          bounds = _this$state.bounds,\n          disablePicking = _this$state.disablePicking;\n      var _this$props = this.props,\n          image = _this$props.image,\n          desaturate = _this$props.desaturate,\n          transparentColor = _this$props.transparentColor,\n          tintColor = _this$props.tintColor;\n\n      if (moduleParameters.pickingActive && disablePicking) {\n        return;\n      }\n\n      if (image && model) {\n        model.setUniforms(uniforms).setUniforms({\n          bitmapTexture: image,\n          desaturate: desaturate,\n          transparentColor: transparentColor.map(function (x) {\n            return x / 255;\n          }),\n          tintColor: tintColor.slice(0, 3).map(function (x) {\n            return x / 255;\n          }),\n          coordinateConversion: coordinateConversion,\n          bounds: bounds\n        }).draw();\n      }\n    }\n  }, {\n    key: \"_getCoordinateUniforms\",\n    value: function _getCoordinateUniforms() {\n      var LNGLAT = COORDINATE_SYSTEM.LNGLAT,\n          CARTESIAN = COORDINATE_SYSTEM.CARTESIAN,\n          DEFAULT = COORDINATE_SYSTEM.DEFAULT;\n      var imageCoordinateSystem = this.props._imageCoordinateSystem;\n\n      if (imageCoordinateSystem !== DEFAULT) {\n        var bounds = this.props.bounds;\n\n        if (!Number.isFinite(bounds[0])) {\n          throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n        }\n\n        var defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n        imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n        if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n          return {\n            coordinateConversion: -1,\n            bounds: bounds\n          };\n        }\n\n        if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n          var bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n          var topRight = lngLatToWorld([bounds[2], bounds[3]]);\n          return {\n            coordinateConversion: 1,\n            bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n          };\n        }\n      }\n\n      return {\n        coordinateConversion: 0,\n        bounds: [0, 0, 0, 0]\n      };\n    }\n  }]);\n\n  return BitmapLayer;\n}(Layer);\n\nexport { BitmapLayer as default };\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\n\nfunction unpackUVsFromRGB(color) {\n  var _color = _slicedToArray(color, 3),\n      u = _color[0],\n      v = _color[1],\n      fracUV = _color[2];\n\n  var vFrac = (fracUV & 0xf0) / 256;\n  var uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}","map":{"version":3,"sources":["../../../src/bitmap-layer/bitmap-layer.js"],"names":["defaultProps","image","type","value","async","bounds","compare","_imageCoordinateSystem","COORDINATE_SYSTEM","desaturate","min","max","transparentColor","tintColor","BitmapLayer","Layer","vs","fs","modules","attributeManager","noAlloc","indices","size","isIndexed","update","attribute","positions","fp64","texCoords","props","oldProps","changeFlags","gl","model","oldMesh","mesh","info","width","height","uv","unpackUVsFromRGB","pixel","Math","disablePicking","normalizedBounds","Number","createMesh","id","geometry","drawMode","vertexCount","isInstanced","opts","uniforms","moduleParameters","coordinateConversion","bitmapTexture","x","LNGLAT","CARTESIAN","DEFAULT","imageCoordinateSystem","defaultImageCoordinateSystem","bottomLeft","lngLatToWorld","topRight","u","v","fracUV","vFrac","uFrac"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Layer, project32, picking, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {Model, Geometry} from '@luma.gl/core';\nimport {lngLatToWorld} from '@math.gl/web-mercator';\n\nimport createMesh from './create-mesh';\n\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\n\nconst defaultProps = {\n  image: {type: 'image', value: null, async: true},\n  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n\n  desaturate: {type: 'number', min: 0, max: 1, value: 0},\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {type: 'color', value: [0, 0, 0, 0]},\n  tintColor: {type: 'color', value: [255, 255, 255]}\n};\n\n/*\n * @class\n * @param {object} props\n * @param {number} props.transparentColor - color to interpret transparency to\n * @param {number} props.tintColor - color bias\n */\nexport default class BitmapLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => (attribute.value = this.state.mesh.indices),\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        update: attribute => (attribute.value = this.state.mesh.positions),\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => (attribute.value = this.state.mesh.texCoords),\n        noAlloc\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    // setup model first\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({mesh, ...this._getCoordinateUniforms()});\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n\n  getPickingInfo({info}) {\n    const {image} = this.props;\n\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n\n    const {width, height} = image;\n\n    // Picking color doesn't represent object index in this layer\n    info.index = 0;\n\n    // Calculate uv and pixel in bitmap\n    const uv = unpackUVsFromRGB(info.color);\n\n    const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];\n\n    info.bitmap = {\n      size: {width, height}, // Size of bitmap\n      uv, // Floating point precision in 0-1 range\n      pixel // Truncated to integer and scaled to pixel size\n    };\n\n    return info;\n  }\n\n  // Override base Layer multi-depth picking logic\n  disablePickingIndex() {\n    this.setState({disablePicking: true});\n  }\n\n  restorePickingColors() {\n    this.setState({disablePicking: false});\n  }\n\n  _createMesh() {\n    const {bounds} = this.props;\n\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (Number.isFinite(bounds[0])) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n     */\n      normalizedBounds = [\n        [bounds[0], bounds[1]],\n        [bounds[0], bounds[3]],\n        [bounds[2], bounds[3]],\n        [bounds[2], bounds[1]]\n      ];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  _getModel(gl) {\n    if (!gl) {\n      return null;\n    }\n\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLES,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      })\n    );\n  }\n\n  draw(opts) {\n    const {uniforms, moduleParameters} = opts;\n    const {model, coordinateConversion, bounds, disablePicking} = this.state;\n    const {image, desaturate, transparentColor, tintColor} = this.props;\n\n    if (moduleParameters.pickingActive && disablePicking) {\n      return;\n    }\n\n    // // TODO fix zFighting\n    // Render the image\n    if (image && model) {\n      model\n        .setUniforms(uniforms)\n        .setUniforms({\n          bitmapTexture: image,\n          desaturate,\n          transparentColor: transparentColor.map(x => x / 255),\n          tintColor: tintColor.slice(0, 3).map(x => x / 255),\n          coordinateConversion,\n          bounds\n        })\n        .draw();\n    }\n  }\n\n  _getCoordinateUniforms() {\n    const {LNGLAT, CARTESIAN, DEFAULT} = COORDINATE_SYSTEM;\n    let {_imageCoordinateSystem: imageCoordinateSystem} = this.props;\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {bounds} = this.props;\n      if (!Number.isFinite(bounds[0])) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n\n      // The default behavior (linearly interpolated tex coords)\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        // LNGLAT in Mercator, e.g. display LNGLAT-encoded image in WebMercator projection\n        return {coordinateConversion: -1, bounds};\n      }\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        // Mercator in LNGLAT, e.g. display WebMercator encoded image in Globe projection\n        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n        const topRight = lngLatToWorld([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n}\n\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\n\n/**\n * Decode uv floats from rgb bytes where b contains 4-bit fractions of uv\n * @param {number[]} color\n * @returns {number[]} uvs\n * https://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab\n */\nfunction unpackUVsFromRGB(color) {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\n"]},"metadata":{},"sourceType":"module"}