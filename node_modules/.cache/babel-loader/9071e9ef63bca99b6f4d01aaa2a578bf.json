{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport ChildProcess from 'child_process';\nimport assert from '../env-utils/assert';\nimport { getAvailablePort } from './process-utils';\nvar DEFAULT_PROCESS_OPTIONS = {\n  command: null,\n  arguments: [],\n  portArg: null,\n  port: 'auto',\n  basePort: 5000,\n  wait: 2000,\n  nodeSpawnOptions: {\n    maxBuffer: 5000 * 1024\n  },\n  onSuccess: function onSuccess(processProxy) {\n    console.log(\"Started \".concat(processProxy.options.command));\n  }\n};\n\nvar ChildProcessProxy = function () {\n  function ChildProcessProxy() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$id = _ref.id,\n        id = _ref$id === void 0 ? 'browser-driver' : _ref$id;\n\n    _classCallCheck(this, ChildProcessProxy);\n\n    this.id = id;\n    this.childProcess = null;\n    this.port = null;\n  }\n\n  _createClass(ChildProcessProxy, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var options,\n            args,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                options = _objectSpread(_objectSpread({}, DEFAULT_PROCESS_OPTIONS), options);\n                assert(options.command && typeof options.command === 'string');\n                this.options = options;\n                args = _toConsumableArray(options.arguments);\n                this.port = options.port;\n\n                if (!options.portArg) {\n                  _context.next = 12;\n                  break;\n                }\n\n                if (!(this.port === 'auto')) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 10;\n                return getAvailablePort(options.basePort);\n\n              case 10:\n                this.port = _context.sent;\n\n              case 11:\n                args.push(options.portArg, this.port);\n\n              case 12:\n                _context.next = 14;\n                return new Promise(function (resolve, reject) {\n                  try {\n                    var successTimer = setTimeout(function () {\n                      if (options.onSuccess) {\n                        options.onSuccess(_this);\n                      }\n\n                      resolve({});\n                    }, options.wait);\n                    console.log(\"Spawning \".concat(options.command, \" \").concat(options.arguments.join(' ')));\n                    _this.childProcess = ChildProcess.spawn(options.command, args, options.spawn);\n\n                    _this.childProcess.stderr.on('data', function (data) {\n                      console.log(\"Child process wrote to stderr: \\\"\".concat(data, \"\\\".\"));\n                      clearTimeout(successTimer);\n                      reject(new Error(data));\n                    });\n\n                    _this.childProcess.on('error', function (error) {\n                      console.log(\"Child process errored with \".concat(error));\n                      clearTimeout(successTimer);\n                      reject(error);\n                    });\n\n                    _this.childProcess.on('close', function (code) {\n                      console.log(\"Child process exited with \".concat(code));\n                      _this.childProcess = null;\n                    });\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n\n              case 14:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.childProcess) {\n                  this.childProcess.kill();\n                  this.childProcess = null;\n                }\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"exit\",\n    value: function () {\n      var _exit = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {\n        var statusCode,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                statusCode = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 0;\n                _context3.prev = 1;\n                _context3.next = 4;\n                return this.stop();\n\n              case 4:\n                process.exit(statusCode);\n                _context3.next = 11;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](1);\n                console.error(_context3.t0.message || _context3.t0);\n                process.exit(1);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 7]]);\n      }));\n\n      function exit() {\n        return _exit.apply(this, arguments);\n      }\n\n      return exit;\n    }()\n  }]);\n\n  return ChildProcessProxy;\n}();\n\nexport { ChildProcessProxy as default };","map":{"version":3,"sources":["../../../../src/lib/process-utils/child-process-proxy.js"],"names":["DEFAULT_PROCESS_OPTIONS","command","arguments","portArg","port","basePort","wait","nodeSpawnOptions","maxBuffer","onSuccess","console","processProxy","ChildProcessProxy","id","options","assert","args","getAvailablePort","successTimer","setTimeout","resolve","ChildProcess","clearTimeout","reject","statusCode","process"],"mappings":"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","sourcesContent":["// Forked from probe.gl under MIT license, Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n\n/* eslint-disable no-console */\n/* global process, setTimeout, clearTimeout, console */\nimport ChildProcess from 'child_process';\nimport assert from '../env-utils/assert';\nimport {getAvailablePort} from './process-utils';\n\nconst DEFAULT_PROCESS_OPTIONS = {\n  command: null,\n  arguments: [],\n  portArg: null,\n  port: 'auto',\n  basePort: 5000,\n  wait: 2000,\n  nodeSpawnOptions: {maxBuffer: 5000 * 1024},\n  onSuccess: processProxy => {\n    console.log(`Started ${processProxy.options.command}`);\n  }\n};\n\nexport default class ChildProcessProxy {\n  constructor({id = 'browser-driver'} = {}) {\n    this.id = id;\n    this.childProcess = null;\n    this.port = null;\n  }\n\n  async start(options = {}) {\n    options = {...DEFAULT_PROCESS_OPTIONS, ...options};\n    assert(options.command && typeof options.command === 'string');\n    this.options = options;\n\n    const args = [...options.arguments];\n\n    // If portArg is set, we can look up an available port\n    this.port = options.port;\n    if (options.portArg) {\n      if (this.port === 'auto') {\n        this.port = await getAvailablePort(options.basePort);\n      }\n      args.push(options.portArg, this.port);\n    }\n\n    return await new Promise((resolve, reject) => {\n      try {\n        const successTimer = setTimeout(() => {\n          if (options.onSuccess) {\n            options.onSuccess(this);\n          }\n          resolve({});\n        }, options.wait);\n\n        console.log(`Spawning ${options.command} ${options.arguments.join(' ')}`);\n        this.childProcess = ChildProcess.spawn(options.command, args, options.spawn);\n\n        // TODO - add option regarding whether stderr should be treated as data\n        this.childProcess.stderr.on('data', data => {\n          console.log(`Child process wrote to stderr: \"${data}\".`);\n          clearTimeout(successTimer);\n          reject(new Error(data));\n        });\n        this.childProcess.on('error', error => {\n          console.log(`Child process errored with ${error}`);\n          clearTimeout(successTimer);\n          reject(error);\n        });\n        this.childProcess.on('close', code => {\n          console.log(`Child process exited with ${code}`);\n          this.childProcess = null;\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  async stop() {\n    if (this.childProcess) {\n      this.childProcess.kill();\n      this.childProcess = null;\n    }\n  }\n\n  async exit(statusCode = 0) {\n    try {\n      await this.stop();\n      // eslint-disable-next-line no-process-exit\n      process.exit(statusCode);\n    } catch (error) {\n      console.error(error.message || error);\n      // eslint-disable-next-line no-process-exit\n      process.exit(1);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}