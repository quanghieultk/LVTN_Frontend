{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Matrix3, Quaternion } from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport { INTERSECTION } from '../constants';\nvar scratchVector = new Vector3();\nvar scratchOffset = new Vector3();\nvar scratchVectorU = new Vector3();\nvar scratchVectorV = new Vector3();\nvar scratchVectorW = new Vector3();\nvar scratchCorner = new Vector3();\nvar scratchToCenter = new Vector3();\nvar fromOrientedBoundingBoxScratchU = new Vector3();\nvar fromOrientedBoundingBoxScratchV = new Vector3();\nvar fromOrientedBoundingBoxScratchW = new Vector3();\nvar MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nvar OrientedBoundingBox = function () {\n  function OrientedBoundingBox() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    _classCallCheck(this, OrientedBoundingBox);\n\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  _createClass(OrientedBoundingBox, [{\n    key: \"fromCenterHalfSizeQuaternion\",\n    value: function fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n      var quaternionObject = new Quaternion(quaternion);\n      var directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n      this.center = new Vector3().from(center);\n      this.halfAxes = directionsMatrix;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new OrientedBoundingBox(this.center, this.halfAxes);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n    }\n  }, {\n    key: \"getBoundingSphere\",\n    value: function getBoundingSphere() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BoundingSphere();\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);\n      var v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);\n      var w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);\n      var cornerVector = scratchVector.copy(u).add(v).add(w);\n      result.center.copy(this.center);\n      result.radius = cornerVector.magnitude();\n      return result;\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var center = this.center;\n      var normal = plane.normal;\n      var halfAxes = this.halfAxes;\n      var normalX = normal.x;\n      var normalY = normal.y;\n      var normalZ = normal.z;\n      var radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n      var distanceToPlane = normal.dot(center) + plane.distance;\n\n      if (distanceToPlane <= -radEffective) {\n        return INTERSECTION.OUTSIDE;\n      } else if (distanceToPlane >= radEffective) {\n        return INTERSECTION.INSIDE;\n      }\n\n      return INTERSECTION.INTERSECTING;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var offset = scratchOffset.from(point).subtract(this.center);\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var uHalf = u.magnitude();\n      var vHalf = v.magnitude();\n      var wHalf = w.magnitude();\n      u.normalize();\n      v.normalize();\n      w.normalize();\n      var distanceSquared = 0.0;\n      var d;\n      d = Math.abs(offset.dot(u)) - uHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.dot(v)) - vHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.dot(w)) - wHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      return distanceSquared;\n    }\n  }, {\n    key: \"computePlaneDistances\",\n    value: function computePlaneDistances(position, direction) {\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-0, -0];\n      var minDist = Number.POSITIVE_INFINITY;\n      var maxDist = Number.NEGATIVE_INFINITY;\n      var center = this.center;\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var corner = scratchCorner.copy(u).add(v).add(w).add(center);\n      var toCenter = scratchToCenter.copy(corner).subtract(position);\n      var mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      result[0] = minDist;\n      result[1] = maxDist;\n      return result;\n    }\n  }, {\n    key: \"getTransform\",\n    value: function getTransform() {}\n  }, {\n    key: \"halfSize\",\n    get: function get() {\n      var xAxis = this.halfAxes.getColumn(0);\n      var yAxis = this.halfAxes.getColumn(1);\n      var zAxis = this.halfAxes.getColumn(2);\n      return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n    }\n  }, {\n    key: \"quaternion\",\n    get: function get() {\n      var xAxis = this.halfAxes.getColumn(0);\n      var yAxis = this.halfAxes.getColumn(1);\n      var zAxis = this.halfAxes.getColumn(2);\n      var normXAxis = new Vector3(xAxis).normalize();\n      var normYAxis = new Vector3(yAxis).normalize();\n      var normZAxis = new Vector3(zAxis).normalize();\n      return new Quaternion().fromMatrix3(new Matrix3([].concat(_toConsumableArray(normXAxis), _toConsumableArray(normYAxis), _toConsumableArray(normZAxis))));\n    }\n  }]);\n\n  return OrientedBoundingBox;\n}();\n\nexport { OrientedBoundingBox as default };","map":{"version":3,"sources":["../../../src/lib/oriented-bounding-box.js"],"names":["scratchVector","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchCorner","scratchToCenter","fromOrientedBoundingBoxScratchU","fromOrientedBoundingBoxScratchV","fromOrientedBoundingBoxScratchW","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","OrientedBoundingBox","center","halfAxes","xAxis","yAxis","zAxis","normXAxis","normYAxis","normZAxis","halfSize","quaternion","quaternionObject","directionsMatrix","right","Boolean","result","u","v","w","cornerVector","plane","normal","normalX","normalY","normalZ","radEffective","Math","distanceToPlane","INTERSECTION","point","offset","uHalf","vHalf","wHalf","distanceSquared","d","position","direction","minDist","Number","maxDist","corner","toCenter","mag"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Quaternion} from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport {INTERSECTION} from '../constants';\n\nconst scratchVector = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst fromOrientedBoundingBoxScratchU = new Vector3();\nconst fromOrientedBoundingBoxScratchV = new Vector3();\nconst fromOrientedBoundingBoxScratchW = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nexport default class OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  // Generate OrientedBoundingBox from OBB based on quaternion\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  // Duplicates a OrientedBoundingBox instance.\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  // Compares the provided OrientedBoundingBox componentwise and returns\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  // Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);\n    const v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);\n    const w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector\n      .copy(u)\n      .add(v)\n      .add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  /**\n   * Determines which side of a plane the oriented bounding box is located.\n   *\n   * @param plane The plane to test against.\n   * @returns\n   *  - `INTERSECTION.INSIDE` if the entire box is on the side of the plane the normal is pointing.\n   *  - `INTERSECTION.OUTSIDE` if the entire box is on the opposite side.\n   *  - `INTERSECTION.INTERSECTING` if the box intersects the plane.\n   */\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  // Computes the estimated distance from the closest point on a bounding box to a point.\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding box to a point.\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  // eslint-disable-next-line max-statements\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  // The distances calculated by the vector from the center of the bounding box\n  // to position projected onto direction.\n\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner\n      .copy(u)\n      .add(v)\n      .add(w)\n      .add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner\n      .copy(center)\n      .add(u)\n      .add(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner\n      .copy(center)\n      .add(u)\n      .subtract(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner\n      .copy(center)\n      .add(u)\n      .subtract(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .add(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .add(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .subtract(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .subtract(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  getTransform() {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}