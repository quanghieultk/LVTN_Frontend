{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nexport function binaryToGeoJson(data, type, format) {\n  if (format === 'geometry') {\n    return parseGeometry(data);\n  }\n\n  var dataArray = normalizeInput(data, type);\n\n  switch (deduceReturnType(dataArray)) {\n    case 'Geometry':\n      return parseGeometry(dataArray[0]);\n\n    case 'FeatureCollection':\n      return parseFeatureCollection(dataArray);\n\n    default:\n      break;\n  }\n\n  return null;\n}\n\nfunction normalizeInput(data, type) {\n  var isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n\n  var features = [];\n\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\nfunction deduceReturnType(dataArray) {\n  if (dataArray.length > 1) {\n    return 'FeatureCollection';\n  }\n\n  var data = dataArray[0];\n\n  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {\n    return 'Geometry';\n  }\n\n  return 'FeatureCollection';\n}\n\nfunction parseFeatureCollection(dataArray) {\n  var features = [];\n\n  var _iterator = _createForOfIteratorHelper(dataArray),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var data = _step.value;\n\n      if (data.featureIds.value.length === 0) {\n        continue;\n      }\n\n      var lastIndex = 0;\n      var lastValue = data.featureIds.value[0];\n\n      for (var i = 0; i < data.featureIds.value.length; i++) {\n        var currValue = data.featureIds.value[i];\n\n        if (currValue === lastValue) {\n          continue;\n        }\n\n        features.push(parseFeature(data, lastIndex, i));\n        lastIndex = i;\n        lastValue = currValue;\n      }\n\n      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return features;\n}\n\nfunction parseFeature(data, startIndex, endIndex) {\n  var geometry = parseGeometry(data, startIndex, endIndex);\n  var properties = parseProperties(data, startIndex, endIndex);\n  return {\n    type: 'Feature',\n    geometry: geometry,\n    properties: properties\n  };\n}\n\nfunction parseProperties(data, startIndex, endIndex) {\n  var properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);\n\n  for (var key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n\n  return properties;\n}\n\nfunction parseGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n\n    default:\n      throw new Error(\"Unsupported geometry type: \".concat(data.type));\n  }\n}\n\nfunction polygonToGeoJson(data) {\n  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  var endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var positions = data.positions;\n  var polygonIndices = data.polygonIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var primitivePolygonIndices = data.primitivePolygonIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var multi = polygonIndices.length > 2;\n  var coordinates = [];\n\n  if (!multi) {\n    for (var i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      var startRingIndex = primitivePolygonIndices[i];\n      var endRingIndex = primitivePolygonIndices[i + 1];\n      var ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {\n      type: 'Polygon',\n      coordinates: coordinates\n    };\n  }\n\n  for (var _i = 0; _i < polygonIndices.length - 1; _i++) {\n    var startPolygonIndex = polygonIndices[_i];\n    var endPolygonIndex = polygonIndices[_i + 1];\n    var polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n\n  return {\n    type: 'MultiPolygon',\n    coordinates: coordinates\n  };\n}\n\nfunction lineStringToGeoJson(data) {\n  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  var endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  var positions = data.positions;\n  var pathIndices = data.pathIndices.value.filter(function (x) {\n    return x >= startIndex && x <= endIndex;\n  });\n  var multi = pathIndices.length > 2;\n\n  if (!multi) {\n    var _coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n\n    return {\n      type: 'LineString',\n      coordinates: _coordinates\n    };\n  }\n\n  var coordinates = [];\n\n  for (var i = 0; i < pathIndices.length - 1; i++) {\n    var ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {\n    type: 'MultiLineString',\n    coordinates: coordinates\n  };\n}\n\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  var positions = data.positions;\n  var coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  var multi = coordinates.length > 1;\n\n  if (multi) {\n    return {\n      type: 'MultiPoint',\n      coordinates: coordinates\n    };\n  }\n\n  return {\n    type: 'Point',\n    coordinates: coordinates[0]\n  };\n}\n\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n  var ringCoordinates = [];\n\n  for (var j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size)));\n  }\n\n  return ringCoordinates;\n}\n\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}","map":{"version":3,"sources":["../../../src/lib/binary-to-geojson.js"],"names":["format","parseGeometry","dataArray","normalizeInput","deduceReturnType","parseFeatureCollection","isHeterogeneousType","Boolean","data","type","parseType","features","lastIndex","lastValue","i","currValue","parseFeature","geometry","properties","parseProperties","Object","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","startIndex","Infinity","endIndex","positions","polygonIndices","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","j","Array"],"mappings":"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","sourcesContent":["export function binaryToGeoJson(data, type, format) {\n  if (format === 'geometry') {\n    return parseGeometry(data);\n  }\n\n  const dataArray = normalizeInput(data, type);\n\n  switch (deduceReturnType(dataArray)) {\n    case 'Geometry':\n      return parseGeometry(dataArray[0]);\n    case 'FeatureCollection':\n      return parseFeatureCollection(dataArray);\n    default:\n      break;\n  }\n\n  return null;\n}\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data, type) {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n\n  const features = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n  return features;\n}\n\n// Determine whether a geometry or feature collection should be returned\n// If the input data doesn't have property identifiers, returns a single geometry\nfunction deduceReturnType(dataArray) {\n  // If more than one item in dataArray, multiple geometry types, must be a featurecollection\n  if (dataArray.length > 1) {\n    return 'FeatureCollection';\n  }\n\n  const data = dataArray[0];\n  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {\n    return 'Geometry';\n  }\n\n  return 'FeatureCollection';\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray) {\n  const features = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex, endIndex) {\n  const geometry = parseGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties};\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex, endIndex) {\n  const properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nfunction parseGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      throw new Error(`Unsupported geometry type: ${data.type}`);\n  }\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    x => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  const coordinates = [];\n  // Polygon\n  if (!multi) {\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex)\n      .coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param  {number?} startIndex Start index to include in ring\n * @param  {number?} endIndex End index to include in ring\n * @return {number[][]} GeoJSON ring\n */\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(\n      Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size))\n    );\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"]},"metadata":{},"sourceType":"module"}