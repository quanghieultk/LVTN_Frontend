{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { Matrix4 } from '@math.gl/core';\nimport { log } from '@luma.gl/webgl';\nimport ScenegraphNode from './scenegraph-node';\n\nvar GroupNode = function (_ScenegraphNode) {\n  _inherits(GroupNode, _ScenegraphNode);\n\n  var _super = _createSuper(GroupNode);\n\n  function GroupNode() {\n    var _this;\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GroupNode);\n\n    props = Array.isArray(props) ? {\n      children: props\n    } : props;\n    var _props = props,\n        _props$children = _props.children,\n        children = _props$children === void 0 ? [] : _props$children;\n    log.assert(children.every(function (child) {\n      return child instanceof ScenegraphNode;\n    }), 'every child must an instance of ScenegraphNode');\n    _this = _super.call(this, props);\n    _this.children = children;\n    return _this;\n  }\n\n  _createClass(GroupNode, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n        children[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _children = children; _i < _children.length; _i++) {\n        var child = _children[_i];\n\n        if (Array.isArray(child)) {\n          this.add.apply(this, _toConsumableArray(child));\n        } else {\n          this.children.push(child);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(child) {\n      var children = this.children;\n      var indexOf = children.indexOf(child);\n\n      if (indexOf > -1) {\n        children.splice(indexOf, 1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeAll\",\n    value: function removeAll() {\n      this.children = [];\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      this.children.forEach(function (child) {\n        return child[\"delete\"]();\n      });\n      this.removeAll();\n\n      _get(_getPrototypeOf(GroupNode.prototype), \"delete\", this).call(this);\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(visitor) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$worldMatrix = _ref.worldMatrix,\n          worldMatrix = _ref$worldMatrix === void 0 ? new Matrix4() : _ref$worldMatrix;\n\n      var modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n      var _iterator = _createForOfIteratorHelper(this.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n\n          if (child instanceof GroupNode) {\n            child.traverse(visitor, {\n              worldMatrix: modelMatrix\n            });\n          } else {\n            visitor(child, {\n              worldMatrix: modelMatrix\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return GroupNode;\n}(ScenegraphNode);\n\nexport { GroupNode as default };","map":{"version":3,"sources":["../../../src/scenegraph/group-node.js"],"names":["GroupNode","ScenegraphNode","props","children","log","child","Array","indexOf","visitor","worldMatrix","modelMatrix"],"mappings":"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","sourcesContent":["import {Matrix4} from '@math.gl/core';\nimport {log} from '@luma.gl/webgl';\nimport ScenegraphNode from './scenegraph-node';\n\nexport default class GroupNode extends ScenegraphNode {\n  constructor(props = {}) {\n    props = Array.isArray(props) ? {children: props} : props;\n    const {children = []} = props;\n    log.assert(\n      children.every(child => child instanceof ScenegraphNode),\n      'every child must an instance of ScenegraphNode'\n    );\n    super(props);\n    this.children = children;\n  }\n\n  // Unpacks arrays and nested arrays of children\n  add(...children) {\n    for (const child of children) {\n      if (Array.isArray(child)) {\n        this.add(...child);\n      } else {\n        this.children.push(child);\n      }\n    }\n    return this;\n  }\n\n  remove(child) {\n    const children = this.children;\n    const indexOf = children.indexOf(child);\n    if (indexOf > -1) {\n      children.splice(indexOf, 1);\n    }\n    return this;\n  }\n\n  removeAll() {\n    this.children = [];\n    return this;\n  }\n\n  delete() {\n    this.children.forEach(child => child.delete());\n    this.removeAll();\n    super.delete();\n  }\n\n  traverse(visitor, {worldMatrix = new Matrix4()} = {}) {\n    const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n\n    for (const child of this.children) {\n      if (child instanceof GroupNode) {\n        child.traverse(visitor, {worldMatrix: modelMatrix});\n      } else {\n        visitor(child, {worldMatrix: modelMatrix});\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}