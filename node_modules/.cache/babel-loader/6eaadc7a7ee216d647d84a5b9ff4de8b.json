{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { CullingVolume, Plane, AxisAlignedBoundingBox, BoundingSphere } from '@math.gl/culling';\nimport { Vector3 } from 'math.gl';\nimport { osmTile2lngLat } from './utils';\nvar TILE_SIZE = 512;\nvar MAX_MAPS = 3;\n\nvar OSMNode = function () {\n  function OSMNode(x, y, z) {\n    _classCallCheck(this, OSMNode);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  _createClass(OSMNode, [{\n    key: \"update\",\n    value: function update(params) {\n      var viewport = params.viewport,\n          cullingVolume = params.cullingVolume,\n          elevationBounds = params.elevationBounds,\n          minZ = params.minZ,\n          maxZ = params.maxZ,\n          offset = params.offset,\n          project = params.project;\n      var boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n      var isInside = cullingVolume.computeVisibility(boundingVolume);\n\n      if (isInside < 0) {\n        return false;\n      }\n\n      if (!this.childVisible) {\n        var z = this.z;\n\n        if (z < maxZ && z >= minZ) {\n          var distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;\n          z += Math.floor(Math.log2(distance));\n        }\n\n        if (z >= maxZ) {\n          this.selected = true;\n          return true;\n        }\n      }\n\n      this.selected = false;\n      this.childVisible = true;\n\n      var _iterator = _createForOfIteratorHelper(this.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          child.update(params);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getSelected\",\n    value: function getSelected() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (this.selected) {\n        result.push(this);\n      }\n\n      if (this._children) {\n        var _iterator2 = _createForOfIteratorHelper(this._children),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var node = _step2.value;\n            node.getSelected(result);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getBoundingVolume\",\n    value: function getBoundingVolume(zRange, worldOffset, project) {\n      if (project) {\n        var corner0 = osmTile2lngLat(this.x, this.y, this.z);\n        var corner1 = osmTile2lngLat(this.x + 1, this.y + 1, this.z);\n        var center = osmTile2lngLat(this.x + 0.5, this.y + 0.5, this.z);\n        corner0.z = zRange[1];\n        corner1.z = zRange[1];\n        center.z = zRange[0];\n        var cornerPos0 = project(corner0);\n        var cornerPos1 = project(corner1);\n        var centerPos = new Vector3(project(center));\n        var R = Math.max(centerPos.distance(cornerPos0), centerPos.distance(cornerPos1));\n        return new BoundingSphere(centerPos, R);\n      }\n\n      var scale = Math.pow(2, this.z);\n      var extent = TILE_SIZE / scale;\n      var originX = this.x * extent + worldOffset * TILE_SIZE;\n      var originY = TILE_SIZE - (this.y + 1) * extent;\n      return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      if (!this._children) {\n        var x = this.x * 2;\n        var y = this.y * 2;\n        var z = this.z + 1;\n        this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];\n      }\n\n      return this._children;\n    }\n  }]);\n\n  return OSMNode;\n}();\n\nexport function getOSMTileIndices(viewport, maxZ, zRange) {\n  var project = viewport.resolution ? viewport.projectPosition : null;\n  var planes = Object.values(viewport.getFrustumPlanes()).map(function (_ref) {\n    var normal = _ref.normal,\n        distance = _ref.distance;\n    return new Plane(normal.clone().negate(), distance);\n  });\n  var cullingVolume = new CullingVolume(planes);\n  var unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  var elevationMin = zRange && zRange[0] * unitsPerMeter || 0;\n  var elevationMax = zRange && zRange[1] * unitsPerMeter || 0;\n  var minZ = viewport.pitch <= 60 ? maxZ : 0;\n  var root = new OSMNode(0, 0, 0);\n  var traversalParams = {\n    viewport: viewport,\n    project: project,\n    cullingVolume: cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ: minZ,\n    maxZ: maxZ,\n    offset: 0\n  };\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    traversalParams.offset = -1;\n\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n\n    traversalParams.offset = 1;\n\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}","map":{"version":3,"sources":["../../../src/tile-layer/tile-2d-traversal.js"],"names":["TILE_SIZE","MAX_MAPS","OSMNode","x","y","z","params","viewport","cullingVolume","elevationBounds","minZ","maxZ","offset","project","boundingVolume","isInside","distance","Math","child","result","node","zRange","worldOffset","corner0","osmTile2lngLat","corner1","center","cornerPos0","cornerPos1","centerPos","R","scale","extent","originX","originY","planes","normal","unitsPerMeter","elevationMin","elevationMax","root","traversalParams"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport {CullingVolume, Plane, AxisAlignedBoundingBox, BoundingSphere} from '@math.gl/culling';\nimport {Vector3} from 'math.gl';\nimport {osmTile2lngLat} from './utils';\n\nconst TILE_SIZE = 512;\n// number of world copies to check\nconst MAX_MAPS = 3;\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [\n        new OSMNode(x, y, z),\n        new OSMNode(x, y + 1, z),\n        new OSMNode(x + 1, y, z),\n        new OSMNode(x + 1, y + 1, z)\n      ];\n    }\n    return this._children;\n  }\n\n  update(params) {\n    const {viewport, cullingVolume, elevationBounds, minZ, maxZ, offset, project} = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n    // First, check if this tile is visible\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n    if (isInside < 0) {\n      return false;\n    }\n\n    // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester\n    if (!this.childVisible) {\n      let {z} = this;\n      if (z < maxZ && z >= minZ) {\n        // Adjust LOD\n        // If the tile is far enough from the camera, accept a lower zoom level\n        const distance =\n          (boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale) / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n      if (z >= maxZ) {\n        // LOD is acceptable\n        this.selected = true;\n        return true;\n      }\n    }\n\n    // LOD is not enough, recursively test child tiles\n    this.selected = false;\n    this.childVisible = true;\n    for (const child of this.children) {\n      child.update(params);\n    }\n    return true;\n  }\n\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n    return result;\n  }\n\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      // Custom projection\n      const corner0 = osmTile2lngLat(this.x, this.y, this.z);\n      const corner1 = osmTile2lngLat(this.x + 1, this.y + 1, this.z);\n      const center = osmTile2lngLat(this.x + 0.5, this.y + 0.5, this.z);\n      corner0.z = zRange[1];\n      corner1.z = zRange[1];\n      center.z = zRange[0];\n\n      const cornerPos0 = project(corner0);\n      const cornerPos1 = project(corner1);\n      const centerPos = new Vector3(project(center));\n      const R = Math.max(centerPos.distance(cornerPos0), centerPos.distance(cornerPos1));\n\n      return new BoundingSphere(centerPos, R);\n    }\n\n    // Use WebMercator projection\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    // deck's common space is y-flipped\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n\n    return new AxisAlignedBoundingBox(\n      [originX, originY, zRange[0]],\n      [originX + extent, originY + extent, zRange[1]]\n    );\n  }\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange) {\n  const project = viewport.resolution ? viewport.projectPosition : null;\n\n  // Get the culling volume of the current camera\n  const planes = Object.values(viewport.getFrustumPlanes()).map(\n    ({normal, distance}) => new Plane(normal.clone().negate(), distance)\n  );\n  const cullingVolume = new CullingVolume(planes);\n\n  // Project zRange from meters to common space\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = (zRange && zRange[0] * unitsPerMeter) || 0;\n  const elevationMax = (zRange && zRange[1] * unitsPerMeter) || 0;\n\n  // Always load at the current zoom level if pitch is small\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    // num. of worlds from the center. For repeated maps\n    offset: 0\n  };\n\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    // Check worlds in repeated maps\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}\n"]},"metadata":{},"sourceType":"module"}