{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { Geometry } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer, SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport { log } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nvar SINGLE_DATA = [0];\nvar defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  data: null,\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: function value(tileset3d) {},\n    compare: false\n  },\n  onTileLoad: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileUnload: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileError: {\n    type: 'function',\n    value: function value(tile, message, url) {},\n    compare: false\n  }\n};\n\nvar Tile3DLayer = function (_CompositeLayer) {\n  _inherits(Tile3DLayer, _CompositeLayer);\n\n  var _super = _createSuper(Tile3DLayer);\n\n  function Tile3DLayer() {\n    _classCallCheck(this, Tile3DLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Tile3DLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      if ('onTileLoadFail' in this.props) {\n        log.removed('onTileLoadFail', 'onTileError')();\n      }\n\n      this.state = {\n        layerMap: {},\n        tileset3d: null\n      };\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.data && props.data !== oldProps.data) {\n        this._loadTileset(props.data);\n      }\n\n      if (changeFlags.viewportChanged) {\n        var tileset3d = this.state.tileset3d;\n\n        this._updateTileset(tileset3d);\n      }\n\n      if (changeFlags.propsChanged) {\n        var layerMap = this.state.layerMap;\n\n        for (var key in layerMap) {\n          layerMap[key].needsUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n          sourceLayer = _ref3.sourceLayer;\n      var layerMap = this.state.layerMap;\n      var layerId = sourceLayer && sourceLayer.id;\n\n      if (layerId) {\n        var substr = layerId.substring(this.id.length + 1);\n        var tileId = substr.substring(substr.indexOf('-') + 1);\n        info.object = layerMap[tileId] && layerMap[tileId].tile;\n      }\n\n      return info;\n    }\n  }, {\n    key: \"_loadTileset\",\n    value: function () {\n      var _loadTileset2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tilesetUrl) {\n        var loadOptions, loader, options, preloadOptions, tilesetJson, tileset3d;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                loadOptions = this.props.loadOptions;\n                loader = this.props.loader || this.props.loaders;\n\n                if (Array.isArray(loader)) {\n                  loader = loader[0];\n                }\n\n                options = _objectSpread({}, loadOptions);\n\n                if (!loader.preload) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 7;\n                return loader.preload(tilesetUrl, loadOptions);\n\n              case 7:\n                preloadOptions = _context.sent;\n                Object.assign(options, preloadOptions);\n\n              case 9:\n                _context.next = 11;\n                return load(tilesetUrl, loader, options);\n\n              case 11:\n                tilesetJson = _context.sent;\n                tileset3d = new Tileset3D(tilesetJson, _objectSpread({\n                  onTileLoad: this._onTileLoad.bind(this),\n                  onTileUnload: this._onTileUnload.bind(this),\n                  onTileLoadFail: this.props.onTileError\n                }, options));\n                this.setState({\n                  tileset3d: tileset3d,\n                  layerMap: {}\n                });\n\n                this._updateTileset(tileset3d);\n\n                this.props.onTilesetLoad(tileset3d);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _loadTileset(_x) {\n        return _loadTileset2.apply(this, arguments);\n      }\n\n      return _loadTileset;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tileHeader) {\n      this.props.onTileLoad(tileHeader);\n\n      this._updateTileset(this.state.tileset3d);\n\n      this.setNeedsUpdate();\n    }\n  }, {\n    key: \"_onTileUnload\",\n    value: function _onTileUnload(tileHeader) {\n      delete this.state.layerMap[tileHeader.id];\n      this.props.onTileUnload(tileHeader);\n    }\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset(tileset3d) {\n      var _this$context = this.context,\n          timeline = _this$context.timeline,\n          viewport = _this$context.viewport;\n\n      if (!timeline || !viewport || !tileset3d) {\n        return;\n      }\n\n      var frameNumber = tileset3d.update(viewport);\n      var tilesetChanged = this.state.frameNumber !== frameNumber;\n\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber: frameNumber\n        });\n      }\n    }\n  }, {\n    key: \"_getSubLayer\",\n    value: function _getSubLayer(tileHeader, oldLayer) {\n      if (!tileHeader.content) {\n        return null;\n      }\n\n      switch (tileHeader.type) {\n        case TILE_TYPE.POINTCLOUD:\n          return this._makePointCloudLayer(tileHeader, oldLayer);\n\n        case TILE_TYPE.SCENEGRAPH:\n          return this._make3DModelLayer(tileHeader, oldLayer);\n\n        case TILE_TYPE.MESH:\n          return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n\n        default:\n          throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n      }\n    }\n  }, {\n    key: \"_makePointCloudLayer\",\n    value: function _makePointCloudLayer(tileHeader, oldLayer) {\n      var _tileHeader$content = tileHeader.content,\n          attributes = _tileHeader$content.attributes,\n          pointCount = _tileHeader$content.pointCount,\n          constantRGBA = _tileHeader$content.constantRGBA,\n          cartographicOrigin = _tileHeader$content.cartographicOrigin,\n          modelMatrix = _tileHeader$content.modelMatrix;\n      var positions = attributes.positions,\n          normals = attributes.normals,\n          colors = attributes.colors;\n\n      if (!positions) {\n        return null;\n      }\n\n      var data = oldLayer && oldLayer.props.data || {\n        header: {\n          vertexCount: pointCount\n        },\n        attributes: {\n          POSITION: positions,\n          NORMAL: normals,\n          COLOR_0: colors\n        }\n      };\n      var _this$props = this.props,\n          pointSize = _this$props.pointSize,\n          getPointColor = _this$props.getPointColor;\n      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n      return new SubLayerClass({\n        pointSize: pointSize\n      }, this.getSubLayerProps({\n        id: 'pointcloud'\n      }), {\n        id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n        data: data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getColor: constantRGBA || getPointColor\n      });\n    }\n  }, {\n    key: \"_make3DModelLayer\",\n    value: function _make3DModelLayer(tileHeader) {\n      var _tileHeader$content2 = tileHeader.content,\n          gltf = _tileHeader$content2.gltf,\n          instances = _tileHeader$content2.instances,\n          cartographicOrigin = _tileHeader$content2.cartographicOrigin,\n          modelMatrix = _tileHeader$content2.modelMatrix;\n      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n      return new SubLayerClass({\n        _lighting: 'pbr'\n      }, this.getSubLayerProps({\n        id: 'scenegraph'\n      }), {\n        id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getTransformMatrix: function getTransformMatrix(instance) {\n          return instance.modelMatrix;\n        },\n        getPosition: [0, 0, 0]\n      });\n    }\n  }, {\n    key: \"_makeSimpleMeshLayer\",\n    value: function _makeSimpleMeshLayer(tileHeader, oldLayer) {\n      var content = tileHeader.content;\n      var attributes = content.attributes,\n          modelMatrix = content.modelMatrix,\n          cartographicOrigin = content.cartographicOrigin,\n          texture = content.texture;\n      var geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n        drawMode: 4,\n        attributes: getMeshGeometry(attributes)\n      });\n      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getPosition: [0, 0, 0],\n        getColor: [255, 255, 255],\n        texture: texture,\n        modelMatrix: modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n\n      var _this$state = this.state,\n          tileset3d = _this$state.tileset3d,\n          layerMap = _this$state.layerMap;\n\n      if (!tileset3d) {\n        return null;\n      }\n\n      return tileset3d.tiles.map(function (tile) {\n        var layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n          tile: tile\n        };\n        var layer = layerCache.layer;\n\n        if (tile.selected) {\n          if (!layer) {\n            layer = _this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            layer = _this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          } else if (!layer.props.visible) {\n            layer = layer.clone({\n              visible: true\n            });\n          }\n        } else if (layer && layer.props.visible) {\n          layer = layer.clone({\n            visible: false\n          });\n        }\n\n        layerCache.layer = layer;\n        return layer;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      var tileset3d = this.state.tileset3d;\n      return tileset3d && tileset3d.isLoaded();\n    }\n  }]);\n\n  return Tile3DLayer;\n}(CompositeLayer);\n\nexport { Tile3DLayer as default };\n\nfunction getMeshGeometry(contentAttributes) {\n  var attributes = {};\n  attributes.positions = _objectSpread(_objectSpread({}, contentAttributes.positions), {}, {\n    value: new Float32Array(contentAttributes.positions.value)\n  });\n\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/tile-3d-layer/tile-3d-layer.js"],"names":["SINGLE_DATA","defaultProps","getPointColor","type","value","pointSize","data","loader","onTilesetLoad","compare","onTileLoad","onTileUnload","onTileError","Tile3DLayer","CompositeLayer","log","layerMap","tileset3d","changeFlags","props","oldProps","info","sourceLayer","layerId","substr","tileId","tilesetUrl","loadOptions","loaders","Array","options","preload","preloadOptions","Object","tilesetJson","load","onTileLoadFail","tileHeader","timeline","viewport","frameNumber","tilesetChanged","oldLayer","TILE_TYPE","attributes","pointCount","constantRGBA","cartographicOrigin","modelMatrix","positions","normals","colors","header","vertexCount","POSITION","NORMAL","COLOR_0","SubLayerClass","id","coordinateSystem","COORDINATE_SYSTEM","coordinateOrigin","getColor","gltf","instances","_lighting","scenegraph","getTransformMatrix","instance","getPosition","content","texture","geometry","drawMode","getMeshGeometry","mesh","METER_OFFSETS","layerCache","tile","layer","visible","contentAttributes"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\nimport {COORDINATE_SYSTEM, CompositeLayer} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer, SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {log} from '@deck.gl/core';\n\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst SINGLE_DATA = [0];\n\nconst defaultProps = {\n  getPointColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  pointSize: 1.0,\n\n  data: null,\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: {type: 'function', value: tileset3d => {}, compare: false},\n  onTileLoad: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileUnload: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileError: {type: 'function', value: (tile, message, url) => {}, compare: false}\n};\n\nexport default class Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null\n    };\n  }\n\n  get isLoaded() {\n    const {tileset3d} = this.state;\n    return tileset3d && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {tileset3d} = this.state;\n      this._updateTileset(tileset3d);\n    }\n    if (changeFlags.propsChanged) {\n      const {layerMap} = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    const {layerMap} = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n    if (layerId) {\n      // layerId: this.id-[scenegraph|pointcloud]-tileId\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {loadOptions} = this.props;\n\n    // TODO: deprecate `loader` in v9.0\n    let loader = this.props.loader || this.props.loaders;\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {...loadOptions};\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(tilesetUrl, loader, options);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileLoadFail: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(tileset3d);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(this.state.tileset3d);\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(tileset3d) {\n    const {timeline, viewport} = this.context;\n    if (!timeline || !viewport || !tileset3d) {\n      return;\n    }\n    const frameNumber = tileset3d.update(viewport);\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (tilesetChanged) {\n      this.setState({frameNumber});\n    }\n  }\n\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader, oldLayer);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n    const data = (oldLayer && oldLayer.props.data) || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n\n        getColor: constantRGBA || getPointColor\n      }\n    );\n  }\n\n  _make3DModelLayer(tileHeader) {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: [0, 0, 0]\n      }\n    );\n  }\n\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {attributes, modelMatrix, cartographicOrigin, texture} = content;\n\n    const geometry =\n      (oldLayer && oldLayer.props.mesh) ||\n      new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: getMeshGeometry(attributes)\n      });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getPosition: [0, 0, 0],\n        getColor: [255, 255, 255],\n        texture,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS\n      }\n    );\n  }\n\n  renderLayers() {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles\n      .map(tile => {\n        const layerCache = (layerMap[tile.id] = layerMap[tile.id] || {tile});\n        let {layer} = layerCache;\n        if (tile.selected) {\n          // render selected tiles\n          if (!layer) {\n            // create layer\n            layer = this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            // props have changed, rerender layer\n            layer = this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          } else if (!layer.props.visible) {\n            // update layer visibility\n            // Still has GPU resource but visibility is turned off so turn it back on so we can render it.\n            layer = layer.clone({visible: true});\n          }\n        } else if (layer && layer.props.visible) {\n          // hide non-selected tiles\n          // Still in tileset cache but doesn't need to render this frame. Keep the GPU resource bound but don't render it.\n          layer = layer.clone({visible: false});\n        }\n        layerCache.layer = layer;\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}