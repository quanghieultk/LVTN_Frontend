{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { CompositeLayer, log } from '@deck.gl/core';\nimport ScatterplotLayer from '../scatterplot-layer/scatterplot-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport { replaceInRange } from '../utils';\nimport { binaryToFeatureForAccesor } from './geojson-binary';\nimport { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from './geojson-layer-props';\nvar defaultLineColor = [0, 0, 0, 255];\nvar defaultFillColor = [0, 0, 0, 255];\nvar defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  elevationScale: 1,\n  pointRadiusUnits: 'meters',\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 0,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  getLineColor: {\n    type: 'accessor',\n    value: defaultLineColor\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: defaultFillColor\n  },\n  getRadius: {\n    type: 'accessor',\n    value: 1\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: true\n};\n\nvar GeoJsonLayer = function (_CompositeLayer) {\n  _inherits(GeoJsonLayer, _CompositeLayer);\n\n  var _super = _createSuper(GeoJsonLayer);\n\n  function GeoJsonLayer() {\n    _classCallCheck(this, GeoJsonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GeoJsonLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        layerProps: {},\n        features: {}\n      };\n\n      if (this.props.getLineDashArray) {\n        log.removed('getLineDashArray', 'PathStyleExtension')();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      if (!changeFlags.dataChanged) {\n        return;\n      }\n\n      var data = this.props.data;\n      var binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n      this.setState({\n        binary: binary\n      });\n\n      if (binary) {\n        this._updateStateBinary({\n          props: props,\n          changeFlags: changeFlags\n        });\n      } else {\n        this._updateStateJSON({\n          props: props,\n          changeFlags: changeFlags\n        });\n      }\n    }\n  }, {\n    key: \"_updateStateBinary\",\n    value: function _updateStateBinary(_ref2) {\n      var props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n      var layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n      this.setState({\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"_updateStateJSON\",\n    value: function _updateStateJSON(_ref3) {\n      var props = _ref3.props,\n          changeFlags = _ref3.changeFlags;\n      var features = getGeojsonFeatures(props.data);\n      var wrapFeature = this.getSubLayerRow.bind(this);\n      var newFeatures = {};\n      var featuresDiff = {};\n\n      if (Array.isArray(changeFlags.dataChanged)) {\n        var oldFeatures = this.state.features;\n\n        for (var key in oldFeatures) {\n          newFeatures[key] = oldFeatures[key].slice();\n          featuresDiff[key] = [];\n        }\n\n        var _iterator = _createForOfIteratorHelper(changeFlags.dataChanged),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dataRange = _step.value;\n            var partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n\n            for (var _key in oldFeatures) {\n              featuresDiff[_key].push(replaceInRange({\n                data: newFeatures[_key],\n                getIndex: function getIndex(f) {\n                  return f.__source.index;\n                },\n                dataRange: dataRange,\n                replace: partialFeatures[_key]\n              }));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        newFeatures = separateGeojsonFeatures(features, wrapFeature);\n      }\n\n      var layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n      this.setState({\n        features: newFeatures,\n        featuresDiff: featuresDiff,\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$props = this.props,\n          stroked = _this$props.stroked,\n          filled = _this$props.filled,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe,\n          material = _this$props.material,\n          transitions = _this$props.transitions;\n      var _this$props2 = this.props,\n          lineWidthUnits = _this$props2.lineWidthUnits,\n          lineWidthScale = _this$props2.lineWidthScale,\n          lineWidthMinPixels = _this$props2.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props2.lineWidthMaxPixels,\n          lineJointRounded = _this$props2.lineJointRounded,\n          lineMiterLimit = _this$props2.lineMiterLimit,\n          pointRadiusUnits = _this$props2.pointRadiusUnits,\n          pointRadiusScale = _this$props2.pointRadiusScale,\n          pointRadiusMinPixels = _this$props2.pointRadiusMinPixels,\n          pointRadiusMaxPixels = _this$props2.pointRadiusMaxPixels,\n          elevationScale = _this$props2.elevationScale,\n          lineDashJustified = _this$props2.lineDashJustified;\n      var _this$props3 = this.props,\n          getLineColor = _this$props3.getLineColor,\n          getFillColor = _this$props3.getFillColor,\n          getRadius = _this$props3.getRadius,\n          getLineWidth = _this$props3.getLineWidth,\n          getLineDashArray = _this$props3.getLineDashArray,\n          getElevation = _this$props3.getElevation,\n          updateTriggers = _this$props3.updateTriggers;\n      var PolygonFillLayer = this.getSubLayerClass('polygons-fill', SolidPolygonLayer);\n      var PolygonStrokeLayer = this.getSubLayerClass('polygons-stroke', PathLayer);\n      var LineStringsLayer = this.getSubLayerClass('line-strings', PathLayer);\n      var PointsLayer = this.getSubLayerClass('points', ScatterplotLayer);\n      var layerProps = this.state.layerProps;\n      var polygonFillLayer = this.shouldRenderSubLayer('polygons-fill', layerProps.polygons.data) && new PolygonFillLayer({\n        extruded: extruded,\n        elevationScale: elevationScale,\n        filled: filled,\n        wireframe: wireframe,\n        material: material,\n        getElevation: this.getSubLayerAccessor(getElevation),\n        getFillColor: this.getSubLayerAccessor(getFillColor),\n        getLineColor: this.getSubLayerAccessor(extruded && wireframe ? getLineColor : defaultLineColor),\n        transitions: transitions && {\n          getPolygon: transitions.geometry,\n          getElevation: transitions.getElevation,\n          getFillColor: transitions.getFillColor,\n          getLineColor: transitions.getLineColor\n        }\n      }, this.getSubLayerProps({\n        id: 'polygons-fill',\n        updateTriggers: {\n          getElevation: updateTriggers.getElevation,\n          getFillColor: updateTriggers.getFillColor,\n          lineColors: extruded && wireframe,\n          getLineColor: updateTriggers.getLineColor\n        }\n      }), layerProps.polygons);\n      var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('polygons-stroke', layerProps.polygonsOutline.data) && new PolygonStrokeLayer({\n        widthUnits: lineWidthUnits,\n        widthScale: lineWidthScale,\n        widthMinPixels: lineWidthMinPixels,\n        widthMaxPixels: lineWidthMaxPixels,\n        rounded: lineJointRounded,\n        miterLimit: lineMiterLimit,\n        dashJustified: lineDashJustified,\n        getColor: this.getSubLayerAccessor(getLineColor),\n        getWidth: this.getSubLayerAccessor(getLineWidth),\n        getDashArray: this.getSubLayerAccessor(getLineDashArray),\n        transitions: transitions && {\n          getPath: transitions.geometry,\n          getColor: transitions.getLineColor,\n          getWidth: transitions.getLineWidth\n        }\n      }, this.getSubLayerProps({\n        id: 'polygons-stroke',\n        updateTriggers: {\n          getColor: updateTriggers.getLineColor,\n          getWidth: updateTriggers.getLineWidth,\n          getDashArray: updateTriggers.getLineDashArray\n        }\n      }), layerProps.polygonsOutline);\n      var pathLayer = this.shouldRenderSubLayer('linestrings', layerProps.lines.data) && new LineStringsLayer({\n        widthUnits: lineWidthUnits,\n        widthScale: lineWidthScale,\n        widthMinPixels: lineWidthMinPixels,\n        widthMaxPixels: lineWidthMaxPixels,\n        rounded: lineJointRounded,\n        miterLimit: lineMiterLimit,\n        dashJustified: lineDashJustified,\n        getColor: this.getSubLayerAccessor(getLineColor),\n        getWidth: this.getSubLayerAccessor(getLineWidth),\n        getDashArray: this.getSubLayerAccessor(getLineDashArray),\n        transitions: transitions && {\n          getPath: transitions.geometry,\n          getColor: transitions.getLineColor,\n          getWidth: transitions.getLineWidth\n        }\n      }, this.getSubLayerProps({\n        id: 'line-strings',\n        updateTriggers: {\n          getColor: updateTriggers.getLineColor,\n          getWidth: updateTriggers.getLineWidth,\n          getDashArray: updateTriggers.getLineDashArray\n        }\n      }), layerProps.lines);\n      var pointLayer = this.shouldRenderSubLayer('points', layerProps.points.data) && new PointsLayer({\n        stroked: stroked,\n        filled: filled,\n        radiusUnits: pointRadiusUnits,\n        radiusScale: pointRadiusScale,\n        radiusMinPixels: pointRadiusMinPixels,\n        radiusMaxPixels: pointRadiusMaxPixels,\n        lineWidthUnits: lineWidthUnits,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        getFillColor: this.getSubLayerAccessor(getFillColor),\n        getLineColor: this.getSubLayerAccessor(getLineColor),\n        getRadius: this.getSubLayerAccessor(getRadius),\n        getLineWidth: this.getSubLayerAccessor(getLineWidth),\n        transitions: transitions && {\n          getPosition: transitions.geometry,\n          getFillColor: transitions.getFillColor,\n          getLineColor: transitions.getLineColor,\n          getRadius: transitions.getRadius,\n          getLineWidth: transitions.getLineWidth\n        }\n      }, this.getSubLayerProps({\n        id: 'points',\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getLineColor: updateTriggers.getLineColor,\n          getRadius: updateTriggers.getRadius,\n          getLineWidth: updateTriggers.getLineWidth\n        }\n      }), _objectSpread(_objectSpread({}, layerProps.points), {}, {\n        highlightedObjectIndex: this._getHighlightedIndex(layerProps.points.data)\n      }));\n      return [!extruded && polygonFillLayer, polygonLineLayer, pathLayer, pointLayer, extruded && polygonFillLayer];\n    }\n  }, {\n    key: \"_getHighlightedIndex\",\n    value: function _getHighlightedIndex(data) {\n      var highlightedObjectIndex = this.props.highlightedObjectIndex;\n      var binary = this.state.binary;\n\n      if (!binary) {\n        return Number.isFinite(highlightedObjectIndex) ? data.findIndex(function (d) {\n          return d.__source.index === highlightedObjectIndex;\n        }) : null;\n      }\n\n      return highlightedObjectIndex;\n    }\n  }, {\n    key: \"getSubLayerAccessor\",\n    value: function getSubLayerAccessor(accessor) {\n      var binary = this.state.binary;\n\n      if (!binary || typeof accessor !== 'function') {\n        return _get(_getPrototypeOf(GeoJsonLayer.prototype), \"getSubLayerAccessor\", this).call(this, accessor);\n      }\n\n      return function (object, info) {\n        var data = info.data,\n            index = info.index;\n        var feature = binaryToFeatureForAccesor(data, index);\n        return accessor(feature, info);\n      };\n    }\n  }]);\n\n  return GeoJsonLayer;\n}(CompositeLayer);\n\nexport { GeoJsonLayer as default };\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/geojson-layer/geojson-layer.js"],"names":["defaultLineColor","defaultFillColor","defaultProps","stroked","filled","extruded","wireframe","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","Number","lineJointRounded","lineMiterLimit","elevationScale","pointRadiusUnits","pointRadiusScale","pointRadiusMinPixels","pointRadiusMaxPixels","getLineColor","type","value","getFillColor","getRadius","getLineWidth","getElevation","material","GeoJsonLayer","CompositeLayer","layerProps","features","log","props","changeFlags","data","binary","createLayerPropsFromBinary","getGeojsonFeatures","wrapFeature","newFeatures","featuresDiff","Array","oldFeatures","dataRange","partialFeatures","separateGeojsonFeatures","replaceInRange","getIndex","f","replace","createLayerPropsFromFeatures","transitions","lineDashJustified","getLineDashArray","updateTriggers","PolygonFillLayer","PolygonStrokeLayer","LineStringsLayer","PointsLayer","polygonFillLayer","getPolygon","id","lineColors","polygonLineLayer","widthUnits","widthScale","widthMinPixels","widthMaxPixels","rounded","miterLimit","dashJustified","getColor","getWidth","getDashArray","getPath","pathLayer","pointLayer","radiusUnits","radiusScale","radiusMinPixels","radiusMaxPixels","getPosition","highlightedObjectIndex","d","accessor","index","info","feature","binaryToFeatureForAccesor"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, log} from '@deck.gl/core';\nimport ScatterplotLayer from '../scatterplot-layer/scatterplot-layer';\nimport PathLayer from '../path-layer/path-layer';\n// Use primitive layer to avoid \"Composite Composite\" layers for now\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport {replaceInRange} from '../utils';\nimport {binaryToFeatureForAccesor} from './geojson-binary';\n\nimport {getGeojsonFeatures, separateGeojsonFeatures} from './geojson';\nimport {createLayerPropsFromFeatures, createLayerPropsFromBinary} from './geojson-layer-props';\n\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\n\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n\n  elevationScale: 1,\n\n  pointRadiusUnits: 'meters',\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 0, //  min point radius in pixels\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER, // max point radius in pixels\n\n  // Line and polygon outline color\n  getLineColor: {type: 'accessor', value: defaultLineColor},\n  // Point and polygon fill color\n  getFillColor: {type: 'accessor', value: defaultFillColor},\n  // Point radius\n  getRadius: {type: 'accessor', value: 1},\n  // Line and polygon outline accessors\n  getLineWidth: {type: 'accessor', value: 1},\n  // Polygon extrusion accessor\n  getElevation: {type: 'accessor', value: 1000},\n  // Optional material for 'lighting' shader module\n  material: true\n};\nexport default class GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({props, changeFlags}) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  _updateStateBinary({props, changeFlags}) {\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  _updateStateJSON({props, changeFlags}) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  /* eslint-disable complexity */\n  renderLayers() {\n    // Layer composition props\n    const {stroked, filled, extruded, wireframe, material, transitions} = this.props;\n\n    // Rendering props underlying layer\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      pointRadiusUnits,\n      pointRadiusScale,\n      pointRadiusMinPixels,\n      pointRadiusMaxPixels,\n      elevationScale,\n      lineDashJustified\n    } = this.props;\n\n    // Accessor props for underlying layers\n    const {\n      getLineColor,\n      getFillColor,\n      getRadius,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      updateTriggers\n    } = this.props;\n\n    const PolygonFillLayer = this.getSubLayerClass('polygons-fill', SolidPolygonLayer);\n    const PolygonStrokeLayer = this.getSubLayerClass('polygons-stroke', PathLayer);\n    const LineStringsLayer = this.getSubLayerClass('line-strings', PathLayer);\n    const PointsLayer = this.getSubLayerClass('points', ScatterplotLayer);\n\n    const {layerProps} = this.state;\n\n    // Filled Polygon Layer\n    const polygonFillLayer =\n      this.shouldRenderSubLayer('polygons-fill', layerProps.polygons.data) &&\n      new PolygonFillLayer(\n        {\n          extruded,\n          elevationScale,\n          filled,\n          wireframe,\n          material,\n          getElevation: this.getSubLayerAccessor(getElevation),\n          getFillColor: this.getSubLayerAccessor(getFillColor),\n          getLineColor: this.getSubLayerAccessor(\n            extruded && wireframe ? getLineColor : defaultLineColor\n          ),\n          transitions: transitions && {\n            getPolygon: transitions.geometry,\n            getElevation: transitions.getElevation,\n            getFillColor: transitions.getFillColor,\n            getLineColor: transitions.getLineColor\n          }\n        },\n        this.getSubLayerProps({\n          id: 'polygons-fill',\n          updateTriggers: {\n            getElevation: updateTriggers.getElevation,\n            getFillColor: updateTriggers.getFillColor,\n            // using a legacy API to invalid lineColor attributes\n            // if (extruded && wireframe) has changed\n            lineColors: extruded && wireframe,\n            getLineColor: updateTriggers.getLineColor\n          }\n        }),\n        layerProps.polygons\n      );\n\n    const polygonLineLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer('polygons-stroke', layerProps.polygonsOutline.data) &&\n      new PolygonStrokeLayer(\n        {\n          widthUnits: lineWidthUnits,\n          widthScale: lineWidthScale,\n          widthMinPixels: lineWidthMinPixels,\n          widthMaxPixels: lineWidthMaxPixels,\n          rounded: lineJointRounded,\n          miterLimit: lineMiterLimit,\n          dashJustified: lineDashJustified,\n\n          getColor: this.getSubLayerAccessor(getLineColor),\n          getWidth: this.getSubLayerAccessor(getLineWidth),\n          getDashArray: this.getSubLayerAccessor(getLineDashArray),\n\n          transitions: transitions && {\n            getPath: transitions.geometry,\n            getColor: transitions.getLineColor,\n            getWidth: transitions.getLineWidth\n          }\n        },\n        this.getSubLayerProps({\n          id: 'polygons-stroke',\n          updateTriggers: {\n            getColor: updateTriggers.getLineColor,\n            getWidth: updateTriggers.getLineWidth,\n            getDashArray: updateTriggers.getLineDashArray\n          }\n        }),\n        layerProps.polygonsOutline\n      );\n\n    const pathLayer =\n      this.shouldRenderSubLayer('linestrings', layerProps.lines.data) &&\n      new LineStringsLayer(\n        {\n          widthUnits: lineWidthUnits,\n          widthScale: lineWidthScale,\n          widthMinPixels: lineWidthMinPixels,\n          widthMaxPixels: lineWidthMaxPixels,\n          rounded: lineJointRounded,\n          miterLimit: lineMiterLimit,\n          dashJustified: lineDashJustified,\n\n          getColor: this.getSubLayerAccessor(getLineColor),\n          getWidth: this.getSubLayerAccessor(getLineWidth),\n          getDashArray: this.getSubLayerAccessor(getLineDashArray),\n\n          transitions: transitions && {\n            getPath: transitions.geometry,\n            getColor: transitions.getLineColor,\n            getWidth: transitions.getLineWidth\n          }\n        },\n        this.getSubLayerProps({\n          id: 'line-strings',\n          updateTriggers: {\n            getColor: updateTriggers.getLineColor,\n            getWidth: updateTriggers.getLineWidth,\n            getDashArray: updateTriggers.getLineDashArray\n          }\n        }),\n        layerProps.lines\n      );\n\n    const pointLayer =\n      this.shouldRenderSubLayer('points', layerProps.points.data) &&\n      new PointsLayer(\n        {\n          stroked,\n          filled,\n          radiusUnits: pointRadiusUnits,\n          radiusScale: pointRadiusScale,\n          radiusMinPixels: pointRadiusMinPixels,\n          radiusMaxPixels: pointRadiusMaxPixels,\n          lineWidthUnits,\n          lineWidthScale,\n          lineWidthMinPixels,\n          lineWidthMaxPixels,\n\n          getFillColor: this.getSubLayerAccessor(getFillColor),\n          getLineColor: this.getSubLayerAccessor(getLineColor),\n          getRadius: this.getSubLayerAccessor(getRadius),\n          getLineWidth: this.getSubLayerAccessor(getLineWidth),\n\n          transitions: transitions && {\n            getPosition: transitions.geometry,\n            getFillColor: transitions.getFillColor,\n            getLineColor: transitions.getLineColor,\n            getRadius: transitions.getRadius,\n            getLineWidth: transitions.getLineWidth\n          }\n        },\n        this.getSubLayerProps({\n          id: 'points',\n          updateTriggers: {\n            getFillColor: updateTriggers.getFillColor,\n            getLineColor: updateTriggers.getLineColor,\n            getRadius: updateTriggers.getRadius,\n            getLineWidth: updateTriggers.getLineWidth\n          }\n        }),\n        {\n          ...layerProps.points,\n          highlightedObjectIndex: this._getHighlightedIndex(layerProps.points.data)\n        }\n      );\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      polygonLineLayer,\n      pathLayer,\n      pointLayer,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n  _getHighlightedIndex(data) {\n    const {highlightedObjectIndex} = this.props;\n    const {binary} = this.state;\n\n    if (!binary) {\n      return Number.isFinite(highlightedObjectIndex)\n        ? data.findIndex(d => d.__source.index === highlightedObjectIndex)\n        : null;\n    }\n    return highlightedObjectIndex;\n  }\n\n  getSubLayerAccessor(accessor) {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      return accessor(feature, info);\n    };\n  }\n}\n\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}