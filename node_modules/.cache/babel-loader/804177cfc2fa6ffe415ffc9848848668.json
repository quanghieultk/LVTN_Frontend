{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport View from './view';\nimport Viewport from '../viewports/viewport';\nimport { getMeterZoom } from '@math.gl/web-mercator';\nimport { Matrix4, _SphericalCoordinates as SphericalCoordinates } from 'math.gl';\nimport FirstPersonController from '../controllers/first-person-controller';\n\nfunction getDirectionFromBearingAndPitch(_ref) {\n  var bearing = _ref.bearing,\n      pitch = _ref.pitch;\n  var spherical = new SphericalCoordinates({\n    bearing: bearing,\n    pitch: pitch\n  });\n  var direction = spherical.toVector3().normalize();\n  return direction;\n}\n\nvar FirstPersonViewport = function (_Viewport) {\n  _inherits(FirstPersonViewport, _Viewport);\n\n  var _super = _createSuper(FirstPersonViewport);\n\n  function FirstPersonViewport(props) {\n    _classCallCheck(this, FirstPersonViewport);\n\n    var _props$modelMatrix = props.modelMatrix,\n        modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix,\n        _props$bearing = props.bearing,\n        bearing = _props$bearing === void 0 ? 0 : _props$bearing,\n        _props$pitch = props.pitch,\n        pitch = _props$pitch === void 0 ? 0 : _props$pitch,\n        _props$up = props.up,\n        up = _props$up === void 0 ? [0, 0, 1] : _props$up;\n    var dir = getDirectionFromBearingAndPitch({\n      bearing: bearing,\n      pitch: pitch === -90 ? 0.0001 : 90 + pitch\n    });\n    var center = modelMatrix ? modelMatrix.transformDirection(dir) : dir;\n    var zoom = getMeterZoom(props);\n    var scale = Math.pow(2, zoom);\n    var viewMatrix = new Matrix4().lookAt({\n      eye: [0, 0, 0],\n      center: center,\n      up: up\n    }).scale(scale);\n    return _super.call(this, _objectSpread(_objectSpread({}, props), {}, {\n      zoom: zoom,\n      viewMatrix: viewMatrix\n    }));\n  }\n\n  return FirstPersonViewport;\n}(Viewport);\n\nvar FirstPersonView = function (_View) {\n  _inherits(FirstPersonView, _View);\n\n  var _super2 = _createSuper(FirstPersonView);\n\n  function FirstPersonView(props) {\n    _classCallCheck(this, FirstPersonView);\n\n    return _super2.call(this, Object.assign({}, props, {\n      type: FirstPersonViewport\n    }));\n  }\n\n  _createClass(FirstPersonView, [{\n    key: \"controller\",\n    get: function get() {\n      return this._getControllerProps({\n        type: FirstPersonController\n      });\n    }\n  }]);\n\n  return FirstPersonView;\n}(View);\n\nexport { FirstPersonView as default };\nFirstPersonView.displayName = 'FirstPersonView';","map":{"version":3,"sources":["../../../src/views/first-person-view.js"],"names":["_SphericalCoordinates","bearing","pitch","spherical","direction","FirstPersonViewport","Viewport","modelMatrix","up","props","dir","getDirectionFromBearingAndPitch","center","zoom","getMeterZoom","scale","Math","viewMatrix","eye","FirstPersonView","View","type","FirstPersonController"],"mappings":"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","sourcesContent":["import View from './view';\nimport Viewport from '../viewports/viewport';\nimport {getMeterZoom} from '@math.gl/web-mercator';\nimport {Matrix4, _SphericalCoordinates as SphericalCoordinates} from 'math.gl';\nimport FirstPersonController from '../controllers/first-person-controller';\n\nfunction getDirectionFromBearingAndPitch({bearing, pitch}) {\n  const spherical = new SphericalCoordinates({bearing, pitch});\n  const direction = spherical.toVector3().normalize();\n  return direction;\n}\n\nclass FirstPersonViewport extends Viewport {\n  constructor(props) {\n    // TODO - push direction handling into Matrix4.lookAt\n    const {\n      // view matrix arguments\n      modelMatrix = null,\n      bearing = 0,\n      pitch = 0,\n      up = [0, 0, 1] // Defines up direction, default positive z axis,\n    } = props;\n\n    // Always calculate direction from bearing and pitch\n    const dir = getDirectionFromBearingAndPitch({\n      bearing,\n      // Avoid \"pixel project matrix not invertible\" error\n      pitch: pitch === -90 ? 0.0001 : 90 + pitch\n    });\n\n    // Direction is relative to model coordinates, of course\n    const center = modelMatrix ? modelMatrix.transformDirection(dir) : dir;\n\n    // Just the direction. All the positioning is done in viewport.js\n    const zoom = getMeterZoom(props);\n    const scale = Math.pow(2, zoom);\n    const viewMatrix = new Matrix4().lookAt({eye: [0, 0, 0], center, up}).scale(scale);\n\n    super({\n      ...props,\n      zoom,\n      viewMatrix\n    });\n  }\n}\n\nexport default class FirstPersonView extends View {\n  constructor(props) {\n    super(\n      Object.assign({}, props, {\n        type: FirstPersonViewport\n      })\n    );\n  }\n\n  get controller() {\n    return this._getControllerProps({\n      type: FirstPersonController\n    });\n  }\n}\n\nFirstPersonView.displayName = 'FirstPersonView';\n"]},"metadata":{},"sourceType":"module"}