{"ast":null,"code":"function systemIsLittleEndian() {\n  var a = new Uint32Array([0x12345678]);\n  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nvar LITTLE_ENDIAN_OS = systemIsLittleEndian();\nvar DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  var view = new DataView(arrayBuffer);\n\n  var _parseHeader = parseHeader(view),\n      header = _parseHeader.header,\n      headerEndOffset = _parseHeader.headerEndOffset;\n\n  var numpyType = header.descr;\n  var ArrayType = DTYPES[numpyType.slice(1, 3)];\n\n  if (!ArrayType) {\n    console.warn(\"Decoding of npy dtype not implemented: \".concat(numpyType));\n    return null;\n  }\n\n  var nArrayElements = header.shape.reduce(function (a, b) {\n    return a * b;\n  });\n  var arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n  var data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  if (numpyType[0] === '>' && LITTLE_ENDIAN_OS || numpyType[0] === '<' && !LITTLE_ENDIAN_OS) {\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data: data,\n    header: header\n  };\n}\n\nfunction parseHeader(view) {\n  var majorVersion = view.getUint8(6);\n  var offset = 8;\n  var headerLength;\n\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  var encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  var decoder = new TextDecoder(encoding);\n  var headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  var headerText = decoder.decode(headerArray);\n  offset += headerLength;\n  var header = JSON.parse(headerText.replace(/'/g, '\"').replace('False', 'false').replace('(', '[').replace(/,*\\),*/g, ']'));\n  return {\n    header: header,\n    headerEndOffset: offset\n  };\n}","map":{"version":3,"sources":["../../../src/lib/parse-npy.js"],"names":["a","b","LITTLE_ENDIAN_OS","systemIsLittleEndian","DTYPES","u1","i1","u2","i2","u4","i4","f4","f8","Float64Array","view","header","headerEndOffset","parseHeader","numpyType","ArrayType","console","nArrayElements","arrayByteLength","data","arrayBuffer","majorVersion","offset","headerLength","encoding","decoder","headerArray","headerText","JSON"],"mappings":"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","sourcesContent":["/* globals TextDecoder */\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer, options) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn(`Decoding of npy dtype not implemented: ${numpyType}`);\n    return null;\n  }\n\n  const nArrayElements = header.shape.reduce((a, b) => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  {DataView} view\n * @return {Object}\n */\nfunction parseHeader(view) {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n"]},"metadata":{},"sourceType":"module"}