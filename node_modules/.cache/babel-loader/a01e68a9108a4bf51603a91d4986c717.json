{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport assert from '../env-utils/assert';\nimport * as node from '../node/buffer-utils.node';\nexport function toArrayBuffer(data) {\n  if (node.toArrayBuffer) {\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    var text = data;\n    var uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  if (data && _typeof(data) === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  return assert(false);\n}\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n\n  var array1 = new Uint8Array(arrayBuffer1);\n  var array2 = new Uint8Array(arrayBuffer2);\n\n  for (var i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function concatenateArrayBuffers() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  var sourceArrays = sources.map(function (source2) {\n    return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;\n  });\n  var byteLength = sourceArrays.reduce(function (length, typedArray) {\n    return length + typedArray.byteLength;\n  }, 0);\n  var result = new Uint8Array(byteLength);\n  var offset = 0;\n\n  var _iterator = _createForOfIteratorHelper(sourceArrays),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sourceArray = _step.value;\n      result.set(sourceArray, offset);\n      offset += sourceArray.byteLength;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result.buffer;\n}\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  var subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  var arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}","map":{"version":3,"sources":["../../../../src/lib/binary-utils/array-buffer-utils.js"],"names":["node","data","ArrayBuffer","text","uint8Array","assert","byteLength","arrayBuffer1","arrayBuffer2","array1","array2","i","sources","sourceArrays","source2","length","typedArray","result","offset","sourceArray","subArray","byteOffset","arrayCopy"],"mappings":"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","sourcesContent":["/** @typedef {import('./array-buffer-utils')} types */\n/* global TextEncoder */\nimport assert from '../env-utils/assert';\nimport * as node from '../node/buffer-utils.node';\n\n/** @type {types['toArrayBuffer']} */\nexport function toArrayBuffer(data) {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  return assert(false);\n}\n\n/** @type {types['compareArrayBuffers']} */\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Concatenate ArrayBuffers\n/** @type {types['concatenateArrayBuffers']} */\nexport function concatenateArrayBuffers(...sources) {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map(\n    source2 => (source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2)\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"]},"metadata":{},"sourceType":"module"}