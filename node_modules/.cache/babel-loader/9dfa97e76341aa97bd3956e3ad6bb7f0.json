{"ast":null,"code":"import Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport { assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { flipRows, scalePixels } from '../webgl-utils';\nimport { getTypedArrayFromGLType, getGLTypeFromTypedArray } from '../webgl-utils/typed-array-utils';\nimport { glFormatToComponents, glTypeToBytes } from '../webgl-utils/format-utils';\nimport { toFramebuffer } from '../webgl-utils/texture-utils';\nimport { assert } from '../utils';\nexport function readPixelsToArray(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$sourceX = options.sourceX,\n      sourceX = _options$sourceX === void 0 ? 0 : _options$sourceX,\n      _options$sourceY = options.sourceY,\n      sourceY = _options$sourceY === void 0 ? 0 : _options$sourceY,\n      _options$sourceFormat = options.sourceFormat,\n      sourceFormat = _options$sourceFormat === void 0 ? 6408 : _options$sourceFormat;\n  var _options$sourceAttach = options.sourceAttachment,\n      sourceAttachment = _options$sourceAttach === void 0 ? 36064 : _options$sourceAttach,\n      _options$target = options.target,\n      target = _options$target === void 0 ? null : _options$target,\n      sourceWidth = options.sourceWidth,\n      sourceHeight = options.sourceHeight,\n      sourceType = options.sourceType;\n\n  var _getFramebuffer = getFramebuffer(source),\n      framebuffer = _getFramebuffer.framebuffer,\n      deleteFramebuffer = _getFramebuffer.deleteFramebuffer;\n\n  assert(framebuffer);\n  var gl = framebuffer.gl,\n      handle = framebuffer.handle,\n      attachments = framebuffer.attachments;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  if (sourceAttachment === 36064 && handle === null) {\n    sourceAttachment = 1028;\n  }\n\n  assert(attachments[sourceAttachment]);\n  sourceType = sourceType || attachments[sourceAttachment].type;\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n  var prevHandle = gl.bindFramebuffer(36160, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.bindFramebuffer(36160, prevHandle || null);\n\n  if (deleteFramebuffer) {\n    framebuffer[\"delete\"]();\n  }\n\n  return target;\n}\nexport function readPixelsToBuffer(source, _ref) {\n  var _ref$sourceX = _ref.sourceX,\n      sourceX = _ref$sourceX === void 0 ? 0 : _ref$sourceX,\n      _ref$sourceY = _ref.sourceY,\n      sourceY = _ref$sourceY === void 0 ? 0 : _ref$sourceY,\n      _ref$sourceFormat = _ref.sourceFormat,\n      sourceFormat = _ref$sourceFormat === void 0 ? 6408 : _ref$sourceFormat,\n      _ref$target = _ref.target,\n      target = _ref$target === void 0 ? null : _ref$target,\n      _ref$targetByteOffset = _ref.targetByteOffset,\n      targetByteOffset = _ref$targetByteOffset === void 0 ? 0 : _ref$targetByteOffset,\n      sourceWidth = _ref.sourceWidth,\n      sourceHeight = _ref.sourceHeight,\n      sourceType = _ref.sourceType;\n\n  var _getFramebuffer2 = getFramebuffer(source),\n      framebuffer = _getFramebuffer2.framebuffer,\n      deleteFramebuffer = _getFramebuffer2.deleteFramebuffer;\n\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n  var gl2 = assertWebGL2Context(framebuffer.gl);\n  sourceType = sourceType || (target ? target.type : 5121);\n\n  if (!target) {\n    var components = glFormatToComponents(sourceFormat);\n    var byteCount = glTypeToBytes(sourceType);\n    var byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {\n      byteLength: byteLength,\n      accessor: {\n        type: sourceType,\n        size: components\n      }\n    });\n  }\n\n  target.bind({\n    target: 35051\n  });\n  withParameters(gl2, {\n    framebuffer: framebuffer\n  }, function () {\n    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);\n  });\n  target.unbind({\n    target: 35051\n  });\n\n  if (deleteFramebuffer) {\n    framebuffer[\"delete\"]();\n  }\n\n  return target;\n}\nexport function copyToDataUrl(source) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$sourceAttachmen = _ref2.sourceAttachment,\n      sourceAttachment = _ref2$sourceAttachmen === void 0 ? 36064 : _ref2$sourceAttachmen,\n      _ref2$targetMaxHeight = _ref2.targetMaxHeight,\n      targetMaxHeight = _ref2$targetMaxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref2$targetMaxHeight;\n\n  var data = readPixelsToArray(source, {\n    sourceAttachment: sourceAttachment\n  });\n  var width = source.width,\n      height = source.height;\n\n  while (height > targetMaxHeight) {\n    var _scalePixels = scalePixels({\n      data: data,\n      width: width,\n      height: height\n    });\n\n    data = _scalePixels.data;\n    width = _scalePixels.width;\n    height = _scalePixels.height;\n  }\n\n  flipRows({\n    data: data,\n    width: width,\n    height: height\n  });\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d');\n  var imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n}\nexport function copyToImage(source) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$sourceAttachmen = _ref3.sourceAttachment,\n      sourceAttachment = _ref3$sourceAttachmen === void 0 ? 36064 : _ref3$sourceAttachmen,\n      _ref3$targetImage = _ref3.targetImage,\n      targetImage = _ref3$targetImage === void 0 ? null : _ref3$targetImage;\n\n  var dataUrl = copyToDataUrl(source, {\n    sourceAttachment: sourceAttachment\n  });\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\nexport function copyToTexture(source, target) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$sourceX2 = options.sourceX,\n      sourceX = _options$sourceX2 === void 0 ? 0 : _options$sourceX2,\n      _options$sourceY2 = options.sourceY,\n      sourceY = _options$sourceY2 === void 0 ? 0 : _options$sourceY2,\n      _options$targetMipmap = options.targetMipmaplevel,\n      targetMipmaplevel = _options$targetMipmap === void 0 ? 0 : _options$targetMipmap,\n      _options$targetIntern = options.targetInternalFormat,\n      targetInternalFormat = _options$targetIntern === void 0 ? 6408 : _options$targetIntern;\n  var targetX = options.targetX,\n      targetY = options.targetY,\n      targetZ = options.targetZ,\n      width = options.width,\n      height = options.height;\n\n  var _getFramebuffer3 = getFramebuffer(source),\n      framebuffer = _getFramebuffer3.framebuffer,\n      deleteFramebuffer = _getFramebuffer3.deleteFramebuffer;\n\n  assert(framebuffer);\n  var gl = framebuffer.gl,\n      handle = framebuffer.handle;\n  var isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  var prevHandle = gl.bindFramebuffer(36160, handle);\n  assert(target);\n  var texture = null;\n\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);\n  } else {\n    switch (target) {\n      case 3553:\n      case 34067:\n        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);\n        break;\n\n      case 35866:\n      case 32879:\n        var gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);\n        break;\n\n      default:\n    }\n  }\n\n  if (texture) {\n    texture.unbind();\n  }\n\n  gl.bindFramebuffer(36160, prevHandle || null);\n\n  if (deleteFramebuffer) {\n    framebuffer[\"delete\"]();\n  }\n\n  return texture;\n}\nexport function blit(source, target) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$sourceX3 = options.sourceX0,\n      sourceX0 = _options$sourceX3 === void 0 ? 0 : _options$sourceX3,\n      _options$sourceY3 = options.sourceY0,\n      sourceY0 = _options$sourceY3 === void 0 ? 0 : _options$sourceY3,\n      _options$targetX = options.targetX0,\n      targetX0 = _options$targetX === void 0 ? 0 : _options$targetX,\n      _options$targetY = options.targetY0,\n      targetY0 = _options$targetY === void 0 ? 0 : _options$targetY,\n      _options$color = options.color,\n      color = _options$color === void 0 ? true : _options$color,\n      _options$depth = options.depth,\n      depth = _options$depth === void 0 ? false : _options$depth,\n      _options$stencil = options.stencil,\n      stencil = _options$stencil === void 0 ? false : _options$stencil,\n      _options$filter = options.filter,\n      filter = _options$filter === void 0 ? 9728 : _options$filter;\n  var sourceX1 = options.sourceX1,\n      sourceY1 = options.sourceY1,\n      targetX1 = options.targetX1,\n      targetY1 = options.targetY1,\n      _options$sourceAttach2 = options.sourceAttachment,\n      sourceAttachment = _options$sourceAttach2 === void 0 ? 36064 : _options$sourceAttach2,\n      _options$mask = options.mask,\n      mask = _options$mask === void 0 ? 0 : _options$mask;\n\n  var _getFramebuffer4 = getFramebuffer(source),\n      srcFramebuffer = _getFramebuffer4.framebuffer,\n      deleteSrcFramebuffer = _getFramebuffer4.deleteFramebuffer;\n\n  var _getFramebuffer5 = getFramebuffer(target),\n      dstFramebuffer = _getFramebuffer5.framebuffer,\n      deleteDstFramebuffer = _getFramebuffer5.deleteFramebuffer;\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  var gl = dstFramebuffer.gl,\n      handle = dstFramebuffer.handle,\n      width = dstFramebuffer.width,\n      height = dstFramebuffer.height,\n      readBuffer = dstFramebuffer.readBuffer;\n  var gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === 36064) {\n    sourceAttachment = 1028;\n  }\n\n  if (color) {\n    mask |= 16384;\n  }\n\n  if (depth) {\n    mask |= 256;\n  }\n\n  if (stencil) {\n    mask |= 1024;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    if (mask & (256 | 1024)) {\n      mask = 16384;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n\n  assert(mask);\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n  var prevDrawHandle = gl.bindFramebuffer(36009, handle);\n  var prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);\n  gl2.readBuffer(readBuffer);\n  gl2.bindFramebuffer(36008, prevReadHandle || null);\n  gl2.bindFramebuffer(36009, prevDrawHandle || null);\n\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer[\"delete\"]();\n  }\n\n  if (deleteDstFramebuffer) {\n    dstFramebuffer[\"delete\"]();\n  }\n\n  return dstFramebuffer;\n}\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {\n      framebuffer: toFramebuffer(source),\n      deleteFramebuffer: true\n    };\n  }\n\n  return {\n    framebuffer: source,\n    deleteFramebuffer: false\n  };\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n\n  type = type || 5121;\n  var ArrayType = getTypedArrayFromGLType(type, {\n    clamped: false\n  });\n  var components = glFormatToComponents(format);\n  return new ArrayType(width * height * components);\n}","map":{"version":3,"sources":["../../../src/classes/copy-and-blit.js"],"names":["options","sourceX","sourceY","sourceFormat","sourceAttachment","target","sourceWidth","sourceHeight","sourceType","framebuffer","deleteFramebuffer","getFramebuffer","assert","gl","handle","attachments","getPixelArray","getGLTypeFromTypedArray","prevHandle","targetByteOffset","gl2","assertWebGL2Context","components","glFormatToComponents","byteCount","glTypeToBytes","byteLength","accessor","type","size","withParameters","targetMaxHeight","Number","MAX_SAFE_INTEGER","data","readPixelsToArray","width","height","source","scalePixels","flipRows","canvas","document","context","imageData","targetImage","dataUrl","copyToDataUrl","targetMipmaplevel","targetInternalFormat","targetX","targetY","targetZ","isSubCopy","texture","sourceX0","sourceY0","targetX0","targetY0","color","depth","stencil","filter","sourceX1","sourceY1","targetX1","targetY1","mask","srcFramebuffer","deleteSrcFramebuffer","dstFramebuffer","deleteDstFramebuffer","readBuffer","log","prevDrawHandle","prevReadHandle","toFramebuffer","ArrayType","getTypedArrayFromGLType","clamped"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport {assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {flipRows, scalePixels} from '../webgl-utils';\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {toFramebuffer} from '../webgl-utils/texture-utils';\nimport {assert} from '../utils';\n\n// NOTE: Slow requires roundtrip to GPU\n// Copies data from a Framebuffer or a Texture object into ArrayBuffer object.\n// App can provide targetPixelArray or have it auto allocated by this method\n// @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n//  newly allocated by this method unless provided by app.\nexport function readPixelsToArray(source, options = {}) {\n  const {sourceX = 0, sourceY = 0, sourceFormat = GL.RGBA} = options;\n  let {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle, attachments} = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // TODO - Set and unset gl.readBuffer\n  if (sourceAttachment === GL.COLOR_ATTACHMENT0 && handle === null) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  assert(attachments[sourceAttachment]);\n\n  // Deduce the type from color attachment if not provided.\n  sourceType = sourceType || attachments[sourceAttachment].type;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\n\n// NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n// Copies data from a Framebuffer or a Texture object into a Buffer object.\nexport function readPixelsToBuffer(\n  source,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    target = null, // A new Buffer object is created when not provided.\n    targetByteOffset = 0, // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  }\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const gl2 = assertWebGL2Context(framebuffer.gl);\n\n  // deduce type if not available.\n  sourceType = sourceType || (target ? target.type : GL.UNSIGNED_BYTE);\n\n  if (!target) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {byteLength, accessor: {type: sourceType, size: components}});\n  }\n\n  target.bind({target: GL.PIXEL_PACK_BUFFER});\n  withParameters(gl2, {framebuffer}, () => {\n    gl2.readPixels(\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      targetByteOffset\n    );\n  });\n  target.unbind({target: GL.PIXEL_PACK_BUFFER});\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\n\n// Reads pixels from a Framebuffer or Texture object to a dataUrl\nexport function copyToDataUrl(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = {}\n) {\n  let data = readPixelsToArray(source, {sourceAttachment});\n\n  // Scale down\n  let {width, height} = source;\n  while (height > targetMaxHeight) {\n    ({data, width, height} = scalePixels({data, width, height}));\n  }\n\n  // Flip to top down coordinate system\n  flipRows({data, width, height});\n\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  // Copy the pixels to a 2D canvas\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL();\n}\n\n// Reads pixels from a Framebuffer or Texture object into an HTML Image\nexport function copyToImage(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetImage = null\n  } = {}\n) {\n  const dataUrl = copyToDataUrl(source, {sourceAttachment});\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\n\n// Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(source, target, options = {}) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA\n  } = options;\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width, // defaults to target width\n    height // defaults to target height\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle} = framebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  assert(target);\n  let texture = null;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(\n      target,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (target) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        gl.copyTexSubImage2D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return texture;\n}\n\n// NOTE: WEBLG2 only\n// Copies a rectangle of pixels between Framebuffer or Texture objects\n// eslint-disable-next-line max-statements, complexity\nexport function blit(source, target, options = {}) {\n  const {\n    sourceX0 = 0,\n    sourceY0 = 0,\n    targetX0 = 0,\n    targetY0 = 0,\n    color = true,\n    depth = false,\n    stencil = false,\n    filter = GL.NEAREST\n  } = options;\n\n  let {\n    sourceX1,\n    sourceY1,\n    targetX1,\n    targetY1,\n    sourceAttachment = GL.COLOR_ATTACHMENT0,\n    mask = 0\n  } = options;\n\n  const {framebuffer: srcFramebuffer, deleteFramebuffer: deleteSrcFramebuffer} = getFramebuffer(\n    source\n  );\n  const {framebuffer: dstFramebuffer, deleteFramebuffer: deleteDstFramebuffer} = getFramebuffer(\n    target\n  );\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  // @ts-ignore\n  const {gl, handle, width, height, readBuffer} = dstFramebuffer;\n  const gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === GL.COLOR_ATTACHMENT0) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  if (color) {\n    mask |= GL.COLOR_BUFFER_BIT;\n  }\n  if (depth) {\n    mask |= GL.DEPTH_BUFFER_BIT;\n  }\n  if (stencil) {\n    mask |= GL.STENCIL_BUFFER_BIT;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    // Either source or destiantion was a texture object, which is wrapped in a Framebuffer objecgt as color attachment.\n    // Overwrite the mask to `COLOR_BUFFER_BIT`\n    if (mask & (GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT)) {\n      mask = GL.COLOR_BUFFER_BIT;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n  assert(mask);\n\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n\n  const prevDrawHandle = gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, handle);\n  const prevReadHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(\n    sourceX0,\n    sourceY0,\n    sourceX1,\n    sourceY1,\n    targetX0,\n    targetY0,\n    targetX1,\n    targetY1,\n    mask,\n    filter\n  );\n  gl2.readBuffer(readBuffer);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, prevReadHandle || null);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.DRAW_FRAMEBUFFER, prevDrawHandle || null);\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\n// Helper methods\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source, deleteFramebuffer: false};\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // Allocate pixel array if not already available, using supplied type\n  type = type || GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n  const components = glFormatToComponents(format);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}\n"]},"metadata":{},"sourceType":"module"}